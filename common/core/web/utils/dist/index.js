//Autogenerated file - do not modify!
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var environment;
        (function (environment) {
            environment.VERSION = "15.0";
            environment.BUILD = 163;
            environment.ENVIRONMENT = "local";
            environment.SENTRY_RELEASE = "release-15.0.163-alpha-local";
        })(environment = keyman.environment || (keyman.environment = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Function     deepCopy
             * Scope        Private
             * @param       {Object}      p           object to copy
             * @param       {Array=}      c0          array member being copied
             * @return      {Object}                  clone ('deep copy') of object
             * Description  Makes an actual copy (not a reference) of an object, copying simple members,
             *              arrays and member objects but not functions, so use with care!
             */
            function deepCopy(p, c0) {
                var c = c0 || {};
                for (var i in p) {
                    if (typeof p[i] === 'object' && p[i] != null) {
                        c[i] = (p[i].constructor === Array) ? [] : {};
                        deepCopy(p[i], c[i]);
                    }
                    else {
                        c[i] = p[i];
                    }
                }
                return c;
            }
            utils.deepCopy = deepCopy;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            var Browser;
            (function (Browser) {
                Browser["Chrome"] = "chrome";
                Browser["Edge"] = "edge";
                Browser["Firefox"] = "firefox";
                Browser["Native"] = "native";
                Browser["Opera"] = "opera";
                Browser["Safari"] = "safari";
                Browser["Other"] = "other";
            })(Browser = utils.Browser || (utils.Browser = {}));
            var OperatingSystem;
            (function (OperatingSystem) {
                OperatingSystem["Windows"] = "windows";
                OperatingSystem["macOS"] = "macosx";
                OperatingSystem["Linux"] = "linux";
                OperatingSystem["Android"] = "android";
                OperatingSystem["iOS"] = "ios";
                OperatingSystem["Other"] = "other";
            })(OperatingSystem = utils.OperatingSystem || (utils.OperatingSystem = {}));
            var FormFactor;
            (function (FormFactor) {
                FormFactor["Desktop"] = "desktop";
                FormFactor["Phone"] = "phone";
                FormFactor["Tablet"] = "tablet";
            })(FormFactor = utils.FormFactor || (utils.FormFactor = {}));
            /**
             * This class provides an abstract version of com.keyman.Device that is core-friendly,
             * containing only the information needed by web-core for text processing use, devoid
             * of any direct references to the DOM.
             */
            var DeviceSpec = /** @class */ (function () {
                function DeviceSpec(browser, formFactor, OS, touchable) {
                    switch (browser.toLowerCase()) {
                        case Browser.Chrome:
                        case Browser.Edge:
                        case Browser.Firefox:
                        case Browser.Native:
                        case Browser.Opera:
                        case Browser.Safari:
                            this.browser = browser.toLowerCase();
                            break;
                        default:
                            this.browser = Browser.Other;
                    }
                    switch (formFactor.toLowerCase()) {
                        case FormFactor.Desktop:
                        case FormFactor.Phone:
                        case FormFactor.Tablet:
                            this.formFactor = formFactor.toLowerCase();
                            break;
                        default:
                            throw ("Invalid form factor specified for device: " + formFactor);
                    }
                    switch (OS.toLowerCase()) {
                        case OperatingSystem.Windows.toLowerCase():
                        case OperatingSystem.macOS.toLowerCase():
                        case OperatingSystem.Linux.toLowerCase():
                        case OperatingSystem.Android.toLowerCase():
                        case OperatingSystem.iOS.toLowerCase():
                            this.OS = OS.toLowerCase();
                            break;
                        default:
                            this.OS = OperatingSystem.Other;
                    }
                    this.touchable = touchable;
                }
                return DeviceSpec;
            }());
            utils.DeviceSpec = DeviceSpec;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Returns the base global object available to the current JS platform.
             * - In browsers, returns `window`.
             * - In WebWorkers, returns `self`.
             * - In Node, returns `global`.
             */
            function getGlobalObject() {
                // Evergreen browsers have started defining 'globalThis'.  
                // Refer to https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#type-checking-for-globalthis
                // and its referenced polyfill.  Said polyfill is very complex, so we opt for this far leaner variant.
                if (typeof globalThis != 'undefined') {
                    return globalThis; // Not available in IE or older Edge versions
                    // @ts-ignore (TS will throw errors for whatever platform we're not compiling for.)
                }
                else if (typeof window != 'undefined') {
                    // @ts-ignore
                    return window; // The browser-based classic
                    // @ts-ignore
                }
                else if (typeof self != 'undefined') {
                    // @ts-ignore
                    return self; // WebWorker global
                }
                else {
                    // Assumption - if neither of the above exist, we're in Node, for unit-testing.
                    // Node doesn't have as many methods and properties as the other two, but what 
                    // matters for us is that it's the base global.
                    //
                    // Some other headless JS solutions use 'this' instead, but Node's enough for our needs.
                    // @ts-ignore
                    return global;
                }
            }
            utils.getGlobalObject = getGlobalObject;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Ensure that this class contains no reference into core KMW code - it is referenced
// by components intended to be modular and possible to separate from core KMW.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            // Dotted-decimal version
            var Version = /** @class */ (function () {
                /**
                 * Parses version information, preparing it for use in comparisons.
                 * @param text Either a string representing a version number (ex: "9.0.0") or an array representing
                 *             its components (ex: [9, 0, 0]).
                 */
                function Version(text) {
                    // If a keyboard doesn't specify a version, use the DEVELOPER_VERSION_FALLBACK values.
                    if (text === undefined || text === null) {
                        this.components = [].concat(Version.DEVELOPER_VERSION_FALLBACK.components);
                        return;
                    }
                    if (Array.isArray(text)) {
                        var components = text;
                        if (components.length < 2) {
                            throw new Error("Version string must have at least a major and minor component!");
                        }
                        else {
                            this.components = [].concat(components);
                            return;
                        }
                    }
                    // else, standard constructor path.
                    var parts = text.split('.');
                    var componentArray = [];
                    if (parts.length < 2) {
                        throw new Error("Version string must have at least a major and minor component!");
                    }
                    for (var i = 0; i < parts.length; i++) {
                        var value = parseInt(parts[i], 10);
                        if (isNaN(value)) {
                            throw new Error("Version string components must be numerical!");
                        }
                        componentArray.push(value);
                    }
                    this.components = componentArray;
                }
                Object.defineProperty(Version.prototype, "major", {
                    get: function () {
                        return this.components[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Version.prototype, "minor", {
                    get: function () {
                        return this.components[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Version.prototype.toString = function () {
                    return this.components.join('.');
                };
                Version.prototype.toJSON = function () {
                    return this.toString();
                };
                Version.prototype.equals = function (other) {
                    return this.compareTo(other) == 0;
                };
                Version.prototype.precedes = function (other) {
                    return this.compareTo(other) < 0;
                };
                Version.prototype.compareTo = function (other) {
                    // If the version info depth differs, we need a flag to indicate which instance is shorter.
                    var isShorter = this.components.length < other.components.length;
                    var maxDepth = (this.components.length < other.components.length) ? this.components.length : other.components.length;
                    var i;
                    for (i = 0; i < maxDepth; i++) {
                        var delta = this.components[i] - other.components[i];
                        if (delta != 0) {
                            return delta;
                        }
                    }
                    var longList = isShorter ? other.components : this.components;
                    do {
                        if (longList[i] > 0) {
                            return isShorter ? -1 : 1;
                        }
                        i++;
                    } while (i < longList.length);
                    // Equal.
                    return 0;
                };
                Version.CURRENT = new Version(com.keyman.environment.VERSION);
                // Represents a default version value for keyboards compiled before this was compiled into keyboards.
                // The exact version is unknown at this point, but the value is "good enough" for what we need.
                Version.DEVELOPER_VERSION_FALLBACK = new Version([9, 0, 0]);
                // For 12.0, the old default behavior of adding missing keycaps to the default layers was removed,
                // as it results in unexpected, bug-like behavior for keyboard designers when it is unwanted.
                Version.NO_DEFAULT_KEYCAPS = new Version([12, 0]);
                Version.MAC_POSSIBLE_IPAD_ALIAS = new Version([10, 15]);
                return Version;
            }());
            utils.Version = Version;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 14.0
   Copyright 2020 SIL International
***/
/**
 * Constructs a string from one or more Unicode character codepoint values
 * passed as integer parameters.
 *
 * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
 * @return {string|null}      The new String object.
 */
String.kmwFromCharCode = function (cp0) {
    var chars = [], i;
    for (i = 0; i < arguments.length; i++) {
        var c = Number(arguments[i]);
        if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
            throw new RangeError("Invalid code point " + c);
        }
        if (c < 0x10000) {
            chars.push(c);
        }
        else {
            c -= 0x10000;
            chars.push((c >> 10) + 0xD800);
            chars.push((c % 0x400) + 0xDC00);
        }
    }
    return String.fromCharCode.apply(undefined, chars);
};
/**
 * Returns a number indicating the Unicode value of the character at the given
 * code point index, with support for supplementary plane characters.
 *
 * @param  {number}  codePointIndex  The code point index into the string (not
                                     the code unit index) to return
 * @return {number}                  The Unicode character value
 */
String.prototype.kmwCharCodeAt = function (codePointIndex) {
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0 || codePointIndex >= str.length) {
        return NaN;
    }
    for (var i = 0; i < codePointIndex; i++) {
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        if (codeUnitIndex === null)
            return NaN;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
        }
    }
    return first;
};
/**
 * Returns the code point index within the calling String object of the first occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  [fromIndex]    Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.indexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the code point index within the calling String object of the last occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  fromIndex      Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the length of the string in code points, as opposed to code units.
 *
 * @return {number}                 The length of the string in code points
 */
String.prototype.kmwLength = function () {
    var str = String(this);
    if (str.length == 0)
        return 0;
    for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return i;
};
/**
 * Extracts a section of a string and returns a new string.
 *
 * @param  {number}  beginSlice    The start code point index in the string to
 *                                 extract from
 * @param  {number}  endSlice      Optional end code point index in the string
 *                                 to extract to
 * @return {string}                The substring as selected by beginSlice and
 *                                 endSlice
 */
String.prototype.kmwSlice = function (beginSlice, endSlice) {
    var str = String(this);
    var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
    var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
    if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
        return '';
    else
        return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
};
/**
 * Returns the characters in a string beginning at the specified location through
 * the specified number of characters.
 *
 * @param  {number}  start         The start code point index in the string to
 *                                 extract from
 * @param  {number=}  length        Optional length to extract
 * @return {string}                The substring as selected by start and length
 */
String.prototype.kmwSubstr = function (start, length) {
    var str = String(this);
    if (start < 0) {
        start = str.kmwLength() + start;
    }
    if (start < 0)
        start = 0;
    var startCodeUnit = str.kmwCodePointToCodeUnit(start);
    var endCodeUnit = startCodeUnit;
    if (startCodeUnit === null)
        return '';
    if (arguments.length < 2) {
        endCodeUnit = str.length;
    }
    else {
        for (var i = 0; i < length; i++)
            endCodeUnit = str.kmwNextChar(endCodeUnit);
    }
    if (endCodeUnit === null)
        return str.substring(startCodeUnit);
    else
        return str.substring(startCodeUnit, endCodeUnit);
};
/**
 * Returns the characters in a string between two indexes into the string.
 *
 * @param  {number}  indexA        The start code point index in the string to
 *                                 extract from
 * @param  {number}  indexB        The end code point index in the string to
 *                                 extract to
 * @return {string}                The substring as selected by indexA and indexB
 */
String.prototype.kmwSubstring = function (indexA, indexB) {
    var str = String(this), indexACodeUnit, indexBCodeUnit;
    if (typeof (indexB) == 'undefined') {
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.length;
    }
    else {
        if (indexA > indexB) {
            var c = indexA;
            indexA = indexB;
            indexB = c;
        }
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
    }
    if (isNaN(indexACodeUnit) || indexACodeUnit === null)
        indexACodeUnit = 0;
    if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
        indexBCodeUnit = str.length;
    return str.substring(indexACodeUnit, indexBCodeUnit);
};
/*
  Helper functions
*/
/**
 * Returns the code unit index for the next code point in the string, accounting for
 * supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to increment
 * @return {number|null}                 The index of the next code point in the string,
 *                                       in code units
 */
String.prototype.kmwNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            if (codeUnitIndex == str.length - 2) {
                return null;
            }
            return codeUnitIndex + 2;
        }
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string, accounting
 * for supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to decrement
 * @return {number|null}                 The index of the previous code point in the
 *                                       string, in code units
*/
String.prototype.kmwPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    var second = str.charCodeAt(codeUnitIndex - 1);
    if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
        var first = str.charCodeAt(codeUnitIndex - 2);
        if (first >= 0xD800 && first <= 0xDBFF) {
            return codeUnitIndex - 2;
        }
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the corresponding code unit index to the code point index passed
 *
 * @param  {number|null} codePointIndex  A code point index in the string
 * @return {number|null}                 The corresponding code unit index
 */
String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
    if (codePointIndex === null)
        return null;
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0) {
        codeUnitIndex = str.length;
        for (var i = 0; i > codePointIndex; i--)
            codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
        return codeUnitIndex;
    }
    if (codePointIndex == str.kmwLength())
        return str.length;
    for (var i = 0; i < codePointIndex; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return codeUnitIndex;
};
/**
 * Returns the corresponding code point index to the code unit index passed
 *
 * @param  {number|null}  codeUnitIndex  A code unit index in the string
 * @return {number|null}                 The corresponding code point index
 */
String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null)
        return null;
    else if (codeUnitIndex == 0)
        return 0;
    else if (codeUnitIndex < 0)
        return str.substr(codeUnitIndex).kmwLength();
    else
        return str.substr(0, codeUnitIndex).kmwLength();
};
/**
 * Returns the character at a the code point index passed
 *
 * @param  {number}  codePointIndex  A code point index in the string
 * @return {string}                  The corresponding character
 */
String.prototype.kmwCharAt = function (codePointIndex) {
    var str = String(this);
    if (codePointIndex >= 0)
        return str.kmwSubstr(codePointIndex, 1);
    else
        return '';
};
/**
 * String prototype library extensions for basic plane characters,
 * to simplify enabling or disabling supplementary plane functionality (I3319)
 */
/**
 * Returns the code unit index for the next code point in the string
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string
 *
 * @param  {number}  codeUnitIndex    A code unit index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the code unit index for a code point index
 *
 * @param  {number}  codePointIndex   A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
    return codePointIndex;
};
/**
 * Returns the code point index for a code unit index
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
    return codeUnitIndex;
};
/**
 * Returns the length of a BMP string
 *
 * @return {number}                   The length in code points
 */
String.prototype.kmwBMPLength = function () {
    var str = String(this);
    return str.length;
};
/**
 * Returns a substring
 *
 * @param  {number}  n
 * @param  {number=}  ln
 * @return {string}
 */
String.prototype.kmwBMPSubstr = function (n, ln) {
    var str = String(this);
    if (n > -1)
        return str.substr(n, ln);
    else
        return str.substr(str.length + n, -n);
};
/**
 * Enable or disable supplementary plane string handling
 *
 * @param  {boolean}  bEnable
 */
String.kmwEnableSupplementaryPlane = function (bEnable) {
    var p = String.prototype;
    String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
    p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
    p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
    p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
    p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
    p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
    p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
    p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
    p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
    p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
    p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
    p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
    p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
};
// References all utility includes from a single file, making import/export simple.
///<reference path="deepCopy.ts" />
///<reference path="globalObject.ts" />
///<reference path="version.ts" />
///<reference path="kmwstring.ts" />
///<reference path="deviceSpec.ts" />
//# sourceMappingURL=index.js.map