//Autogenerated file - do not modify!
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var environment;
        (function (environment) {
            environment.VERSION = "15.0";
            environment.BUILD = 86;
            environment.ENVIRONMENT = "local";
            environment.SENTRY_RELEASE = "release-15.0.86-alpha-local";
        })(environment = keyman.environment || (keyman.environment = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Function     deepCopy
             * Scope        Private
             * @param       {Object}      p           object to copy
             * @param       {Array=}      c0          array member being copied
             * @return      {Object}                  clone ('deep copy') of object
             * Description  Makes an actual copy (not a reference) of an object, copying simple members,
             *              arrays and member objects but not functions, so use with care!
             */
            function deepCopy(p, c0) {
                var c = c0 || {};
                for (var i in p) {
                    if (typeof p[i] === 'object' && p[i] != null) {
                        c[i] = (p[i].constructor === Array) ? [] : {};
                        deepCopy(p[i], c[i]);
                    }
                    else {
                        c[i] = p[i];
                    }
                }
                return c;
            }
            utils.deepCopy = deepCopy;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Returns the base global object available to the current JS platform.
             * - In browsers, returns `window`.
             * - In WebWorkers, returns `self`.
             * - In Node, returns `global`.
             */
            function getGlobalObject() {
                // Evergreen browsers have started defining 'globalThis'.  
                // Refer to https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#type-checking-for-globalthis
                // and its referenced polyfill.  Said polyfill is very complex, so we opt for this far leaner variant.
                if (typeof globalThis != 'undefined') {
                    return globalThis; // Not available in IE or older Edge versions
                    // @ts-ignore (TS will throw errors for whatever platform we're not compiling for.)
                }
                else if (typeof window != 'undefined') {
                    // @ts-ignore
                    return window; // The browser-based classic
                    // @ts-ignore
                }
                else if (typeof self != 'undefined') {
                    // @ts-ignore
                    return self; // WebWorker global
                }
                else {
                    // Assumption - if neither of the above exist, we're in Node, for unit-testing.
                    // Node doesn't have as many methods and properties as the other two, but what 
                    // matters for us is that it's the base global.
                    //
                    // Some other headless JS solutions use 'this' instead, but Node's enough for our needs.
                    // @ts-ignore
                    return global;
                }
            }
            utils.getGlobalObject = getGlobalObject;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Ensure that this class contains no reference into core KMW code - it is referenced
// by components intended to be modular and possible to separate from core KMW.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            // Dotted-decimal version
            var Version = /** @class */ (function () {
                /**
                 * Parses version information, preparing it for use in comparisons.
                 * @param text Either a string representing a version number (ex: "9.0.0") or an array representing
                 *             its components (ex: [9, 0, 0]).
                 */
                function Version(text) {
                    // If a keyboard doesn't specify a version, use the DEVELOPER_VERSION_FALLBACK values.
                    if (text === undefined || text === null) {
                        this.components = [].concat(Version.DEVELOPER_VERSION_FALLBACK.components);
                        return;
                    }
                    if (Array.isArray(text)) {
                        var components = text;
                        if (components.length < 2) {
                            throw new Error("Version string must have at least a major and minor component!");
                        }
                        else {
                            this.components = [].concat(components);
                            return;
                        }
                    }
                    // else, standard constructor path.
                    var parts = text.split('.');
                    var componentArray = [];
                    if (parts.length < 2) {
                        throw new Error("Version string must have at least a major and minor component!");
                    }
                    for (var i = 0; i < parts.length; i++) {
                        var value = parseInt(parts[i], 10);
                        if (isNaN(value)) {
                            throw new Error("Version string components must be numerical!");
                        }
                        componentArray.push(value);
                    }
                    this.components = componentArray;
                }
                Object.defineProperty(Version.prototype, "major", {
                    get: function () {
                        return this.components[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Version.prototype, "minor", {
                    get: function () {
                        return this.components[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Version.prototype.toString = function () {
                    return this.components.join('.');
                };
                Version.prototype.toJSON = function () {
                    return this.toString();
                };
                Version.prototype.equals = function (other) {
                    return this.compareTo(other) == 0;
                };
                Version.prototype.precedes = function (other) {
                    return this.compareTo(other) < 0;
                };
                Version.prototype.compareTo = function (other) {
                    // If the version info depth differs, we need a flag to indicate which instance is shorter.
                    var isShorter = this.components.length < other.components.length;
                    var maxDepth = (this.components.length < other.components.length) ? this.components.length : other.components.length;
                    var i;
                    for (i = 0; i < maxDepth; i++) {
                        var delta = this.components[i] - other.components[i];
                        if (delta != 0) {
                            return delta;
                        }
                    }
                    var longList = isShorter ? other.components : this.components;
                    do {
                        if (longList[i] > 0) {
                            return isShorter ? -1 : 1;
                        }
                        i++;
                    } while (i < longList.length);
                    // Equal.
                    return 0;
                };
                Version.CURRENT = new Version(com.keyman.environment.VERSION);
                // Represents a default version value for keyboards compiled before this was compiled into keyboards.
                // The exact version is unknown at this point, but the value is "good enough" for what we need.
                Version.DEVELOPER_VERSION_FALLBACK = new Version([9, 0, 0]);
                // For 12.0, the old default behavior of adding missing keycaps to the default layers was removed,
                // as it results in unexpected, bug-like behavior for keyboard designers when it is unwanted.
                Version.NO_DEFAULT_KEYCAPS = new Version([12, 0]);
                Version.MAC_POSSIBLE_IPAD_ALIAS = new Version([10, 15]);
                return Version;
            }());
            utils.Version = Version;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 14.0
   Copyright 2020 SIL International
***/
/**
 * Constructs a string from one or more Unicode character codepoint values
 * passed as integer parameters.
 *
 * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
 * @return {string|null}      The new String object.
 */
String.kmwFromCharCode = function (cp0) {
    var chars = [], i;
    for (i = 0; i < arguments.length; i++) {
        var c = Number(arguments[i]);
        if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
            throw new RangeError("Invalid code point " + c);
        }
        if (c < 0x10000) {
            chars.push(c);
        }
        else {
            c -= 0x10000;
            chars.push((c >> 10) + 0xD800);
            chars.push((c % 0x400) + 0xDC00);
        }
    }
    return String.fromCharCode.apply(undefined, chars);
};
/**
 * Returns a number indicating the Unicode value of the character at the given
 * code point index, with support for supplementary plane characters.
 *
 * @param  {number}  codePointIndex  The code point index into the string (not
                                     the code unit index) to return
 * @return {number}                  The Unicode character value
 */
String.prototype.kmwCharCodeAt = function (codePointIndex) {
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0 || codePointIndex >= str.length) {
        return NaN;
    }
    for (var i = 0; i < codePointIndex; i++) {
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        if (codeUnitIndex === null)
            return NaN;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
        }
    }
    return first;
};
/**
 * Returns the code point index within the calling String object of the first occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  [fromIndex]    Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.indexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the code point index within the calling String object of the last occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  fromIndex      Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the length of the string in code points, as opposed to code units.
 *
 * @return {number}                 The length of the string in code points
 */
String.prototype.kmwLength = function () {
    var str = String(this);
    if (str.length == 0)
        return 0;
    for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return i;
};
/**
 * Extracts a section of a string and returns a new string.
 *
 * @param  {number}  beginSlice    The start code point index in the string to
 *                                 extract from
 * @param  {number}  endSlice      Optional end code point index in the string
 *                                 to extract to
 * @return {string}                The substring as selected by beginSlice and
 *                                 endSlice
 */
String.prototype.kmwSlice = function (beginSlice, endSlice) {
    var str = String(this);
    var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
    var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
    if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
        return '';
    else
        return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
};
/**
 * Returns the characters in a string beginning at the specified location through
 * the specified number of characters.
 *
 * @param  {number}  start         The start code point index in the string to
 *                                 extract from
 * @param  {number=}  length        Optional length to extract
 * @return {string}                The substring as selected by start and length
 */
String.prototype.kmwSubstr = function (start, length) {
    var str = String(this);
    if (start < 0) {
        start = str.kmwLength() + start;
    }
    if (start < 0)
        start = 0;
    var startCodeUnit = str.kmwCodePointToCodeUnit(start);
    var endCodeUnit = startCodeUnit;
    if (startCodeUnit === null)
        return '';
    if (arguments.length < 2) {
        endCodeUnit = str.length;
    }
    else {
        for (var i = 0; i < length; i++)
            endCodeUnit = str.kmwNextChar(endCodeUnit);
    }
    if (endCodeUnit === null)
        return str.substring(startCodeUnit);
    else
        return str.substring(startCodeUnit, endCodeUnit);
};
/**
 * Returns the characters in a string between two indexes into the string.
 *
 * @param  {number}  indexA        The start code point index in the string to
 *                                 extract from
 * @param  {number}  indexB        The end code point index in the string to
 *                                 extract to
 * @return {string}                The substring as selected by indexA and indexB
 */
String.prototype.kmwSubstring = function (indexA, indexB) {
    var str = String(this), indexACodeUnit, indexBCodeUnit;
    if (typeof (indexB) == 'undefined') {
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.length;
    }
    else {
        if (indexA > indexB) {
            var c = indexA;
            indexA = indexB;
            indexB = c;
        }
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
    }
    if (isNaN(indexACodeUnit) || indexACodeUnit === null)
        indexACodeUnit = 0;
    if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
        indexBCodeUnit = str.length;
    return str.substring(indexACodeUnit, indexBCodeUnit);
};
/*
  Helper functions
*/
/**
 * Returns the code unit index for the next code point in the string, accounting for
 * supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to increment
 * @return {number|null}                 The index of the next code point in the string,
 *                                       in code units
 */
String.prototype.kmwNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            if (codeUnitIndex == str.length - 2) {
                return null;
            }
            return codeUnitIndex + 2;
        }
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string, accounting
 * for supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to decrement
 * @return {number|null}                 The index of the previous code point in the
 *                                       string, in code units
*/
String.prototype.kmwPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    var second = str.charCodeAt(codeUnitIndex - 1);
    if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
        var first = str.charCodeAt(codeUnitIndex - 2);
        if (first >= 0xD800 && first <= 0xDBFF) {
            return codeUnitIndex - 2;
        }
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the corresponding code unit index to the code point index passed
 *
 * @param  {number|null} codePointIndex  A code point index in the string
 * @return {number|null}                 The corresponding code unit index
 */
String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
    if (codePointIndex === null)
        return null;
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0) {
        codeUnitIndex = str.length;
        for (var i = 0; i > codePointIndex; i--)
            codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
        return codeUnitIndex;
    }
    if (codePointIndex == str.kmwLength())
        return str.length;
    for (var i = 0; i < codePointIndex; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return codeUnitIndex;
};
/**
 * Returns the corresponding code point index to the code unit index passed
 *
 * @param  {number|null}  codeUnitIndex  A code unit index in the string
 * @return {number|null}                 The corresponding code point index
 */
String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null)
        return null;
    else if (codeUnitIndex == 0)
        return 0;
    else if (codeUnitIndex < 0)
        return str.substr(codeUnitIndex).kmwLength();
    else
        return str.substr(0, codeUnitIndex).kmwLength();
};
/**
 * Returns the character at a the code point index passed
 *
 * @param  {number}  codePointIndex  A code point index in the string
 * @return {string}                  The corresponding character
 */
String.prototype.kmwCharAt = function (codePointIndex) {
    var str = String(this);
    if (codePointIndex >= 0)
        return str.kmwSubstr(codePointIndex, 1);
    else
        return '';
};
/**
 * String prototype library extensions for basic plane characters,
 * to simplify enabling or disabling supplementary plane functionality (I3319)
 */
/**
 * Returns the code unit index for the next code point in the string
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string
 *
 * @param  {number}  codeUnitIndex    A code unit index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the code unit index for a code point index
 *
 * @param  {number}  codePointIndex   A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
    return codePointIndex;
};
/**
 * Returns the code point index for a code unit index
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
    return codeUnitIndex;
};
/**
 * Returns the length of a BMP string
 *
 * @return {number}                   The length in code points
 */
String.prototype.kmwBMPLength = function () {
    var str = String(this);
    return str.length;
};
/**
 * Returns a substring
 *
 * @param  {number}  n
 * @param  {number=}  ln
 * @return {string}
 */
String.prototype.kmwBMPSubstr = function (n, ln) {
    var str = String(this);
    if (n > -1)
        return str.substr(n, ln);
    else
        return str.substr(str.length + n, -n);
};
/**
 * Enable or disable supplementary plane string handling
 *
 * @param  {boolean}  bEnable
 */
String.kmwEnableSupplementaryPlane = function (bEnable) {
    var p = String.prototype;
    String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
    p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
    p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
    p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
    p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
    p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
    p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
    p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
    p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
    p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
    p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
    p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
    p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
};
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            var Browser;
            (function (Browser) {
                Browser["Chrome"] = "chrome";
                Browser["Edge"] = "edge";
                Browser["Firefox"] = "firefox";
                Browser["Native"] = "native";
                Browser["Opera"] = "opera";
                Browser["Safari"] = "safari";
                Browser["Other"] = "other";
            })(Browser = utils.Browser || (utils.Browser = {}));
            var OperatingSystem;
            (function (OperatingSystem) {
                OperatingSystem["Windows"] = "windows";
                OperatingSystem["macOS"] = "macosx";
                OperatingSystem["Linux"] = "linux";
                OperatingSystem["Android"] = "android";
                OperatingSystem["iOS"] = "ios";
                OperatingSystem["Other"] = "other";
            })(OperatingSystem = utils.OperatingSystem || (utils.OperatingSystem = {}));
            var FormFactor;
            (function (FormFactor) {
                FormFactor["Desktop"] = "desktop";
                FormFactor["Phone"] = "phone";
                FormFactor["Tablet"] = "tablet";
            })(FormFactor = utils.FormFactor || (utils.FormFactor = {}));
            /**
             * This class provides an abstract version of com.keyman.Device that is core-friendly,
             * containing only the information needed by web-core for text processing use, devoid
             * of any direct references to the DOM.
             */
            var DeviceSpec = /** @class */ (function () {
                function DeviceSpec(browser, formFactor, OS, touchable) {
                    switch (browser.toLowerCase()) {
                        case Browser.Chrome:
                        case Browser.Edge:
                        case Browser.Firefox:
                        case Browser.Native:
                        case Browser.Opera:
                        case Browser.Safari:
                            this.browser = browser.toLowerCase();
                            break;
                        default:
                            this.browser = Browser.Other;
                    }
                    switch (formFactor.toLowerCase()) {
                        case FormFactor.Desktop:
                        case FormFactor.Phone:
                        case FormFactor.Tablet:
                            this.formFactor = formFactor.toLowerCase();
                            break;
                        default:
                            throw ("Invalid form factor specified for device: " + formFactor);
                    }
                    switch (OS.toLowerCase()) {
                        case OperatingSystem.Windows.toLowerCase():
                        case OperatingSystem.macOS.toLowerCase():
                        case OperatingSystem.Linux.toLowerCase():
                        case OperatingSystem.Android.toLowerCase():
                        case OperatingSystem.iOS.toLowerCase():
                            this.OS = OS.toLowerCase();
                            break;
                        default:
                            this.OS = OperatingSystem.Other;
                    }
                    this.touchable = touchable;
                }
                return DeviceSpec;
            }());
            utils.DeviceSpec = DeviceSpec;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// References all utility includes from a single file, making import/export simple.
///<reference path="deepCopy.ts" />
///<reference path="globalObject.ts" />
///<reference path="version.ts" />
///<reference path="kmwstring.ts" />
///<reference path="deviceSpec.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            // Defines the base Deadkey-tracking object.
            var Deadkey = /** @class */ (function () {
                function Deadkey(pos, id) {
                    this.p = pos;
                    this.d = id;
                    this.o = Deadkey.ordinalSeed++;
                }
                Deadkey.prototype.match = function (p, d) {
                    var result = (this.p == p && this.d == d);
                    return result;
                };
                Deadkey.prototype.set = function () {
                    this.matched = 1;
                };
                Deadkey.prototype.reset = function () {
                    this.matched = 0;
                };
                Deadkey.prototype.before = function (other) {
                    return this.o < other.o;
                };
                Deadkey.prototype.clone = function () {
                    var dk = new Deadkey(this.p, this.d);
                    dk.o = this.o;
                    return dk;
                };
                Deadkey.ordinalSeed = 0;
                /**
                 * Sorts the deadkeys in reverse order.
                 */
                Deadkey.sortFunc = function (a, b) {
                    // We want descending order, so we want 'later' deadkeys first.
                    if (a.p != b.p) {
                        return b.p - a.p;
                    }
                    else {
                        return b.o - a.o;
                    }
                };
                return Deadkey;
            }());
            text.Deadkey = Deadkey;
            // Object-orients deadkey management.
            var DeadkeyTracker = /** @class */ (function () {
                function DeadkeyTracker() {
                    this.dks = [];
                }
                DeadkeyTracker.prototype.toSortedArray = function () {
                    this.dks = this.dks.sort(Deadkey.sortFunc);
                    return [].concat(this.dks);
                };
                DeadkeyTracker.prototype.clone = function () {
                    var dkt = new DeadkeyTracker();
                    var dks = this.toSortedArray();
                    // Make sure to clone the deadkeys themselves - the Deadkey object is mutable.
                    dkt.dks = [];
                    dks.forEach(function (value) {
                        dkt.dks.push(value.clone());
                    });
                    return dkt;
                };
                /**
                 * Function     isMatch
                 * Scope        Public
                 * @param       {number}      caretPos  current cursor position
                 * @param       {number}      n         expected offset of deadkey from cursor
                 * @param       {number}      d         deadkey
                 * @return      {boolean}               True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                DeadkeyTracker.prototype.isMatch = function (caretPos, n, d) {
                    if (this.dks.length == 0) {
                        return false; // I3318
                    }
                    var sp = caretPos;
                    n = sp - n;
                    for (var i = 0; i < this.dks.length; i++) {
                        // Don't re-match an already-matched deadkey.  It's possible to have two identical 
                        // entries, and they should be kept separately.
                        if (this.dks[i].match(n, d) && !this.dks[i].matched) {
                            this.dks[i].set();
                            // Assumption:  since we match the first possible entry in the array, we
                            // match the entry with the lower ordinal - the 'first' deadkey in the position.
                            return true; // I3318
                        }
                    }
                    this.resetMatched(); // I3318
                    return false;
                };
                DeadkeyTracker.prototype.add = function (dk) {
                    this.dks = this.dks.concat(dk);
                };
                DeadkeyTracker.prototype.remove = function (dk) {
                    var index = this.dks.indexOf(dk);
                    this.dks.splice(index, 1);
                };
                DeadkeyTracker.prototype.clear = function () {
                    this.dks = [];
                };
                DeadkeyTracker.prototype.resetMatched = function () {
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        dk.reset();
                    }
                };
                DeadkeyTracker.prototype.deleteMatched = function () {
                    for (var Li = 0; Li < this.dks.length; Li++) {
                        if (this.dks[Li].matched) {
                            this.dks.splice(Li--, 1); // Don't forget to decrement!
                        }
                    }
                };
                /**
                 * Function     adjustPositions (formerly _DeadkeyAdjustPos)
                 * Scope        Private
                 * @param       {number}      Lstart      start position in context
                 * @param       {number}      Ldelta      characters to adjust by
                 * Description  Adjust saved positions of deadkeys in context
                 */
                DeadkeyTracker.prototype.adjustPositions = function (Lstart, Ldelta) {
                    if (Ldelta == 0) {
                        return;
                    }
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        if (dk.p > Lstart) {
                            dk.p += Ldelta;
                        }
                    }
                };
                DeadkeyTracker.prototype.count = function () {
                    return this.dks.length;
                };
                return DeadkeyTracker;
            }());
            text.DeadkeyTracker = DeadkeyTracker;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines deadkey management in a manner attachable to each element interface.
///<reference path="../text/deadkeys.ts" />
// Defines the KeyEvent type.
///<reference path="keyEvent.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Also relies on string-extensions provided by the web-utils package.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text_1) {
            var TextTransform = /** @class */ (function () {
                function TextTransform(insert, deleteLeft, deleteRight) {
                    this.insert = insert;
                    this.deleteLeft = deleteLeft;
                    this.deleteRight = deleteRight || 0;
                }
                TextTransform.nil = new TextTransform('', 0, 0);
                return TextTransform;
            }());
            text_1.TextTransform = TextTransform;
            var Transcription = /** @class */ (function () {
                function Transcription(keystroke, transform, preInput, alternates /*, removedDks: Deadkey[], insertedDks: Deadkey[]*/) {
                    var token = this.token = Transcription.tokenSeed++;
                    this.keystroke = keystroke;
                    this.transform = transform;
                    this.alternates = alternates;
                    this.preInput = preInput;
                    this.transform.id = this.token;
                    // Assign the ID to each alternate, as well.
                    if (alternates) {
                        alternates.forEach(function (alt) {
                            alt.sample.id = token;
                        });
                    }
                }
                Transcription.tokenSeed = 0;
                return Transcription;
            }());
            text_1.Transcription = Transcription;
            var OutputTarget = /** @class */ (function () {
                function OutputTarget() {
                    this._dks = new text.DeadkeyTracker();
                }
                Object.defineProperty(OutputTarget.prototype, "isSynthetic", {
                    /**
                     * Signifies that this OutputTarget has no default key processing behaviors.  This should be false
                     * for OutputTargets backed by web elements like HTMLInputElement or HTMLTextAreaElement.
                     */
                    get: function () {
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                OutputTarget.prototype.resetContext = function () {
                    this.deadkeys().clear();
                };
                OutputTarget.prototype.deadkeys = function () {
                    return this._dks;
                };
                OutputTarget.prototype.hasDeadkeyMatch = function (n, d) {
                    return this.deadkeys().isMatch(this.getDeadkeyCaret(), n, d);
                };
                OutputTarget.prototype.insertDeadkeyBeforeCaret = function (d) {
                    var dk = new text_1.Deadkey(this.getDeadkeyCaret(), d);
                    this.deadkeys().add(dk);
                };
                /**
                 * Should be called by each output target immediately before text mutation operations occur.
                 *
                 * Maintains solutions to old issues:  I3318,I3319
                 * @param {number} delta  Use negative values if characters were deleted, positive if characters were added.
                 */
                OutputTarget.prototype.adjustDeadkeys = function (delta) {
                    this.deadkeys().adjustPositions(this.getDeadkeyCaret(), delta);
                };
                /**
                 * Needed to properly clone deadkeys for use with Mock element interfaces toward predictive text purposes.
                 * @param {object}  dks   An existing set of deadkeys to deep-copy for use by this element interface.
                 */
                OutputTarget.prototype.setDeadkeys = function (dks) {
                    this._dks = dks.clone();
                };
                /**
                 * Determines the basic operations needed to reconstruct the current OutputTarget's text from the prior state specified
                 * by another OutputTarget based on their text and caret positions.
                 *
                 * This is designed for use as a "before and after" comparison to determine the effect of a single keyboard rule at a time.
                 * As such, it assumes that the caret is immediately after any inserted text.
                 * @param from An output target (preferably a Mock) representing the prior state of the input/output system.
                 */
                OutputTarget.prototype.buildTransformFrom = function (original) {
                    var to = this.getText();
                    var from = original.getText();
                    var fromCaret = original.getDeadkeyCaret();
                    var toCaret = this.getDeadkeyCaret();
                    // Step 1:  Determine the number of left-deletions.
                    var maxSMPLeftMatch = fromCaret < toCaret ? fromCaret : toCaret;
                    // We need the corresponding non-SMP caret location in order to binary-search efficiently.
                    // (Examining code units is much more computationally efficient.)
                    var maxLeftMatch = to._kmwCodePointToCodeUnit(maxSMPLeftMatch);
                    // 1.1:  use a non-SMP-aware binary search to determine the divergence point.
                    var start = 0;
                    var end = maxLeftMatch; // the index AFTER the last possible matching char.
                    // This search is O(maxLeftMatch).  1/2 + 1/4 + 1/8 + ... converges to = 1.
                    while (start < end) {
                        var mid = Math.floor((end + start + 1) / 2); // round up (compare more)
                        var fromLeft = from.substr(start, mid - start);
                        var toLeft = to.substr(start, mid - start);
                        if (fromLeft == toLeft) {
                            start = mid;
                        }
                        else {
                            end = mid - 1;
                        }
                    }
                    // At the loop's end:  `end` now holds the non-SMP-aware divergence point.
                    // The 'caret' is after the last matching code unit.
                    // 1.2:  detect a possible surrogate-pair split scenario, correcting for it
                    //       (by moving the split before the high-surrogate) if detected.
                    // If the split location is precisely on either end of the context, we can't
                    // have split a surrogate pair.
                    if (end > 0 && end < maxLeftMatch) {
                        var potentialHigh = from.charCodeAt(end - 1);
                        var potentialFromLow = from.charCodeAt(end);
                        var potentialToLow = to.charCodeAt(end);
                        // if potentialHigh is a possible high surrogate...
                        if (potentialHigh >= 0xD800 && potentialHigh <= 0xDBFF) {
                            // and at least one potential 'low' is a possible low surrogate...
                            var flag = potentialFromLow >= 0xDC00 && potentialFromLow <= 0xDFFF;
                            flag = flag || (potentialToLow >= 0XDC00 && potentialToLow <= 0xDFFF);
                            // Correct the split location, moving it 'before' the high surrogate.
                            if (flag) {
                                end = end - 1;
                            }
                        }
                    }
                    // 1.3:  take substring from start to the split point; determine SMP-aware length.
                    //       This yields the SMP-aware divergence index, which gives the number of left-deletes.
                    var newCaret = from._kmwCodeUnitToCodePoint(end);
                    var deletedLeft = fromCaret - newCaret;
                    // Step 2:  Determine the other properties.
                    // Since the 'after' OutputTarget's caret indicates the end of any inserted text, we
                    // can easily calculate the rest.
                    var insertedLength = toCaret - newCaret;
                    var delta = to._kmwSubstr(newCaret, insertedLength);
                    var undeletedRight = to._kmwLength() - toCaret;
                    var originalRight = from._kmwLength() - fromCaret;
                    var deletedRight = originalRight - undeletedRight;
                    // May occur when reverting a suggestion that had been applied mid-word.
                    if (deletedRight < 0) {
                        // Restores deleteRight characters.
                        delta = delta + to._kmwSubstr(toCaret, -deletedRight);
                        deletedRight = 0;
                    }
                    return new TextTransform(delta, deletedLeft, deletedRight);
                };
                OutputTarget.prototype.buildTranscriptionFrom = function (original, keyEvent, alternates) {
                    var transform = this.buildTransformFrom(original);
                    // If we ever decide to re-add deadkey tracking, this is the place for it.
                    return new Transcription(keyEvent, transform, Mock.from(original), alternates);
                };
                /**
                 * Restores the `OutputTarget` to the indicated state.  Designed for use with `Transcription.preInput`.
                 * @param original An `OutputTarget` (usually a `Mock`).
                 */
                OutputTarget.prototype.restoreTo = function (original) {
                    //
                    this.setTextBeforeCaret(original.getTextBeforeCaret());
                    this.setTextAfterCaret(original.getTextAfterCaret());
                    // Also, restore the deadkeys!
                    this._dks = original._dks.clone();
                };
                OutputTarget.prototype.apply = function (transform) {
                    if (transform.deleteRight) {
                        this.setTextAfterCaret(this.getTextAfterCaret()._kmwSubstr(transform.deleteRight));
                    }
                    if (transform.deleteLeft) {
                        this.deleteCharsBeforeCaret(transform.deleteLeft);
                    }
                    if (transform.insert) {
                        this.insertTextBeforeCaret(transform.insert);
                    }
                    // We assume that all deadkeys are invalidated after applying a Transform, since
                    // prediction implies we'll be completing a word, post-deadkeys.
                    this._dks.clear();
                };
                /**
                 * Helper to `restoreTo` - allows directly setting the 'before' context to that of another
                 * `OutputTarget`.
                 * @param s
                 */
                OutputTarget.prototype.setTextBeforeCaret = function (s) {
                    // This one's easy enough to provide a default implementation for.
                    this.deleteCharsBeforeCaret(this.getTextBeforeCaret()._kmwLength());
                    this.insertTextBeforeCaret(s);
                };
                /**
                 * Saves element-specific state properties prone to mutation, enabling restoration after
                 * text-output operations.
                 */
                OutputTarget.prototype.saveProperties = function () {
                    // Most element interfaces won't need anything here.
                };
                /**
                 * Restores previously-saved element-specific state properties.  Designed for use after text-output
                 * ops to facilitate more-seamless web-dev and user interactions.
                 */
                OutputTarget.prototype.restoreProperties = function () {
                    // Most element interfaces won't need anything here. 
                };
                return OutputTarget;
            }());
            text_1.OutputTarget = OutputTarget;
            // Due to some interesting requirements on compile ordering in TS,
            // this needs to be in the same file as OutputTarget now.
            var Mock = /** @class */ (function (_super) {
                __extends(Mock, _super);
                function Mock(text, caretPos) {
                    var _this = _super.call(this) || this;
                    _this.text = text ? text : "";
                    var defaultLength = _this.text._kmwLength();
                    // Ensures that `caretPos == 0` is handled correctly.
                    _this.caretIndex = typeof caretPos == "number" ? caretPos : defaultLength;
                    return _this;
                }
                // Clones the state of an existing EditableElement, creating a Mock version of its state.
                Mock.from = function (outputTarget) {
                    var clone;
                    if (outputTarget instanceof Mock) {
                        // Avoids the need to run expensive kmwstring.ts / `_kmwLength()`
                        // calculations when deep-copying Mock instances.
                        var priorMock = outputTarget;
                        clone = new Mock(priorMock.text, priorMock.caretIndex);
                    }
                    else {
                        // If we're 'cloning' a different OutputTarget type, we don't have a
                        // guaranteed way to more efficiently get these values; these are the
                        // best methods specified by the abstraction.
                        var preText = outputTarget.getTextBeforeCaret();
                        var caretIndex = preText._kmwLength();
                        // We choose to ignore (rather, pre-emptively remove) any actively-selected text,
                        // as since it's always removed instantly during any text mutation operations.
                        clone = new Mock(preText + outputTarget.getTextAfterCaret(), caretIndex);
                    }
                    // Also duplicate deadkey state!  (Needed for fat-finger ops.)
                    clone.setDeadkeys(outputTarget.deadkeys());
                    return clone;
                };
                Mock.prototype.clearSelection = function () {
                    return;
                };
                Mock.prototype.invalidateSelection = function () {
                    return;
                };
                Mock.prototype.hasSelection = function () {
                    return true;
                };
                Mock.prototype.getDeadkeyCaret = function () {
                    return this.caretIndex;
                };
                Mock.prototype.setDeadkeyCaret = function (index) {
                    if (index < 0 || index > this.text._kmwLength()) {
                        throw new Error("Provided caret index is out of range.");
                    }
                    this.caretIndex = index;
                };
                Mock.prototype.getTextBeforeCaret = function () {
                    return this.text.kmwSubstr(0, this.caretIndex);
                };
                Mock.prototype.getTextAfterCaret = function () {
                    return this.text.kmwSubstr(this.caretIndex);
                };
                Mock.prototype.getText = function () {
                    return this.text;
                };
                Mock.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn >= 0) {
                        if (dn > this.caretIndex) {
                            dn = this.caretIndex;
                        }
                        this.text = this.text.kmwSubstr(0, this.caretIndex - dn) + this.getTextAfterCaret();
                        this.caretIndex -= dn;
                    }
                };
                Mock.prototype.insertTextBeforeCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s + this.getTextAfterCaret();
                    this.caretIndex += s.kmwLength();
                };
                Mock.prototype.handleNewlineAtCaret = function () {
                    this.insertTextBeforeCaret('\n');
                };
                Mock.prototype.setTextAfterCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s;
                };
                Mock.prototype.doInputEvent = function () {
                    // Mock isn't backed by an element, so it won't have any event listeners.
                };
                return Mock;
            }(OutputTarget));
            text_1.Mock = Mock;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="outputTarget.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * This class is defined within its own file so that it can be loaded by code outside of KMW without
             * having to actually load the entirety of KMW.
             */
            var KeyEvent = /** @class */ (function () {
                function KeyEvent() {
                    /**
                     * `true` if this event was produced by sources other than a DOM-based KeyboardEvent.
                     */
                    this.isSynthetic = true;
                }
                return KeyEvent;
            }());
            text.KeyEvent = KeyEvent;
            ;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var KMWRecorder;
(function (KMWRecorder) {
    /**
     * Facilitates running Recorder-generated tests on various platforms.
     *
     * Note that DOM-aware KeymanWeb will implement a Browser-based version, while
     * keyboard-processor and input-processor will use a Node-based version instead.
     */
    var Proctor = /** @class */ (function () {
        function Proctor(device, assert) {
            this.device = device;
            this._assert = assert;
        }
        Proctor.prototype.assertEquals = function (s1, s2, msg) {
            if (this._assert) {
                this._assert(s1, s2, msg);
            }
        };
        return Proctor;
    }());
    KMWRecorder.Proctor = Proctor;
})(KMWRecorder || (KMWRecorder = {}));
/// <reference path="../node_modules/@keymanapp/keyboard-processor/src/text/keyEvent.ts" />
/// <reference path="proctor.ts" />
var KMWRecorder;
(function (KMWRecorder) {
    //#region Defines the InputEventSpec set, used to reconstruct DOM-based events for browser-based simulation
    var InputEventSpec = /** @class */ (function () {
        function InputEventSpec() {
        }
        InputEventSpec.fromJSONObject = function (obj) {
            if (obj && obj.type) {
                if (obj.type == "key") {
                    return new PhysicalInputEventSpec(obj);
                }
                else if (obj.type == "osk") {
                    return new OSKInputEventSpec(obj);
                }
            }
            else {
                throw new SyntaxError("Error in JSON format corresponding to an InputEventSpec!");
            }
        };
        InputEventSpec.prototype.toPrettyJSON = function () {
            // We want the default, non-spaced JSON for this class, even when otherwise adding whitespace.
            var str = JSON.stringify(this);
            return str;
        };
        return InputEventSpec;
    }());
    KMWRecorder.InputEventSpec = InputEventSpec;
    var PhysicalInputEventSpec = /** @class */ (function (_super) {
        __extends(PhysicalInputEventSpec, _super);
        function PhysicalInputEventSpec(e) {
            var _this = _super.call(this) || this;
            // KeyboardEvent properties
            _this.type = "key";
            if (e) {
                _this.key = e.key;
                _this.code = e.code;
                _this.keyCode = e.keyCode;
                _this.modifierSet = e.modifierSet;
                _this.location = e.location;
            }
            return _this;
        }
        PhysicalInputEventSpec.prototype.getModifierState = function (key) {
            return (PhysicalInputEventSpec.modifierCodes[key] & this.modifierSet) != 0;
        };
        PhysicalInputEventSpec.prototype.generateModifierString = function () {
            var list = "";
            for (var key in PhysicalInputEventSpec.modifierCodes) {
                if (this.getModifierState(key)) {
                    list += ((list != "" ? " " : "") + key);
                }
            }
            return list;
        };
        PhysicalInputEventSpec.modifierCodes = {
            "Shift": 0x0001,
            "Control": 0x0002,
            "Alt": 0x0004,
            "Meta": 0x0008,
            "CapsLock": 0x0010,
            "NumLock": 0x0020,
            "ScrollLock": 0x0040
        };
        return PhysicalInputEventSpec;
    }(InputEventSpec));
    KMWRecorder.PhysicalInputEventSpec = PhysicalInputEventSpec;
    var OSKInputEventSpec = /** @class */ (function (_super) {
        __extends(OSKInputEventSpec, _super);
        // The parameter may be used to reconstruct the item from raw JSON.
        function OSKInputEventSpec(e) {
            var _this = _super.call(this) || this;
            _this.type = "osk";
            if (e) {
                _this.keyID = e.keyID;
            }
            return _this;
        }
        return OSKInputEventSpec;
    }(InputEventSpec));
    KMWRecorder.OSKInputEventSpec = OSKInputEventSpec;
    //#endregion
    var RecordedKeystroke = /** @class */ (function () {
        function RecordedKeystroke() {
        }
        RecordedKeystroke.fromJSONObject = function (obj) {
            if (obj && obj.type) {
                if (obj.type == "key") {
                    return new RecordedPhysicalKeystroke(obj);
                }
                else if (obj && obj.type) {
                    return new RecordedSyntheticKeystroke(obj);
                }
            }
            else {
                throw new SyntaxError("Error in JSON format corresponding to a RecordedKeystroke!");
            }
        };
        RecordedKeystroke.prototype.toPrettyJSON = function () {
            // We want the default, non-spaced JSON for this class, even when otherwise adding whitespace.
            var str = JSON.stringify(this);
            return str;
        };
        return RecordedKeystroke;
    }());
    KMWRecorder.RecordedKeystroke = RecordedKeystroke;
    var RecordedPhysicalKeystroke = /** @class */ (function (_super) {
        __extends(RecordedPhysicalKeystroke, _super);
        function RecordedPhysicalKeystroke(keystroke, eventSpec) {
            var _this = _super.call(this) || this;
            // KeyboardEvent properties
            _this.type = "key";
            if (keystroke instanceof com.keyman.text.KeyEvent || typeof keystroke.type === 'undefined') {
                // Store what is necessary for headless event reconstruction.
                keystroke = keystroke;
                _this.keyCode = keystroke.Lcode;
                _this.states = keystroke.Lstates;
                _this.modifiers = keystroke.Lmodifiers;
                _this.modifierChanged = !!keystroke.LmodifierChange;
                _this.isVirtualKey = keystroke.LisVirtualKey;
                _this.vkCode = keystroke.vkCode;
                // Also store the DOM-based event spec for use in integrated testing.
                _this.eventSpec = eventSpec;
            }
            else {
                // It might be a raw object, from JSON.
                _this.keyCode = keystroke.keyCode;
                _this.states = keystroke.states;
                _this.modifiers = keystroke.modifiers;
                _this.modifierChanged = keystroke.modifierChanged;
                _this.isVirtualKey = keystroke.isVirtualKey;
                _this.vkCode = keystroke.vkCode;
                _this.eventSpec = new PhysicalInputEventSpec(keystroke.eventSpec); // must also be reconstructed.
            }
            return _this;
        }
        Object.defineProperty(RecordedPhysicalKeystroke.prototype, "inputEventSpec", {
            get: function () {
                return this.eventSpec;
            },
            enumerable: true,
            configurable: true
        });
        return RecordedPhysicalKeystroke;
    }(RecordedKeystroke));
    KMWRecorder.RecordedPhysicalKeystroke = RecordedPhysicalKeystroke;
    var RecordedSyntheticKeystroke = /** @class */ (function (_super) {
        __extends(RecordedSyntheticKeystroke, _super);
        function RecordedSyntheticKeystroke(keystroke) {
            var _this = _super.call(this) || this;
            // KeyboardEvent properties
            _this.type = "osk";
            if (keystroke instanceof com.keyman.text.KeyEvent || typeof keystroke.type === 'undefined') {
                keystroke = keystroke;
                // Store what is necessary for headless event reconstruction.
                // Also store the DOM-based event spec for use in integrated testing.
                _this.layer = keystroke.kbdLayer;
                _this.keyName = keystroke.kName;
                _this.keyDistribution = keystroke.keyDistribution;
            }
            else {
                // It might be a raw object, from JSON.
                _this.layer = keystroke.layer;
                _this.keyName = keystroke.keyName;
                _this.keyDistribution = keystroke.keyDistribution;
            }
            return _this;
        }
        Object.defineProperty(RecordedSyntheticKeystroke.prototype, "inputEventSpec", {
            get: function () {
                var eventSpec = new OSKInputEventSpec();
                eventSpec.keyID = this.layer + '-' + this.keyName;
                return eventSpec;
            },
            enumerable: true,
            configurable: true
        });
        return RecordedSyntheticKeystroke;
    }(RecordedKeystroke));
    KMWRecorder.RecordedSyntheticKeystroke = RecordedSyntheticKeystroke;
    var TestSequence = /** @class */ (function () {
        function TestSequence() {
        }
        TestSequence.prototype.test = function (proctor, target) {
            // Start with an empty OutputTarget and a fresh KeyboardProcessor.
            if (!target) {
                target = new com.keyman.text.Mock();
            }
            proctor.before();
            var result = proctor.simulateSequence(this, target);
            proctor.assertEquals(result, this.output, this.msg);
            return { success: (result == this.output), result: result };
        };
        TestSequence.prototype.toPrettyJSON = function () {
            var str = "{ ";
            if (this.output) {
                str += "\"output\": \"" + this.output + "\", ";
            }
            str += "\"inputs\": [\n";
            for (var i = 0; i < this.inputs.length; i++) {
                str += "  " + this.inputs[i].toPrettyJSON() + ((i == this.inputs.length - 1) ? "\n" : ",\n");
            }
            if (this.msg) {
                str += "], \"message\": \"" + this.msg + "\" }";
            }
            else {
                str += "]}";
            }
            return str;
        };
        return TestSequence;
    }());
    KMWRecorder.TestSequence = TestSequence;
    var InputEventSpecSequence = /** @class */ (function (_super) {
        __extends(InputEventSpecSequence, _super);
        function InputEventSpecSequence(ins, outs, msg) {
            var _this = _super.call(this) || this;
            if (ins) {
                if (ins instanceof Array) {
                    _this.inputs = [].concat(ins);
                }
                else {
                    // We're constructing from existing JSON.
                    _this.inputs = [];
                    for (var ie = 0; ie < ins.inputs.length; ie++) {
                        _this.inputs.push(InputEventSpec.fromJSONObject(ins.inputs[ie]));
                    }
                    _this.output = ins.output;
                    _this.msg = ins.msg;
                    return _this;
                }
            }
            else {
                _this.inputs = [];
            }
            if (outs) {
                _this.output = outs;
            }
            if (msg) {
                _this.msg = msg;
            }
            return _this;
        }
        InputEventSpecSequence.prototype.addInput = function (event, output) {
            this.inputs.push(event);
            this.output = output;
        };
        InputEventSpecSequence.prototype.hasOSKInteraction = function () {
            for (var i = 0; i < this.inputs.length; i++) {
                if (this.inputs[i] instanceof OSKInputEventSpec) {
                    return true;
                }
            }
            return false;
        };
        return InputEventSpecSequence;
    }(TestSequence));
    KMWRecorder.InputEventSpecSequence = InputEventSpecSequence;
    var RecordedKeystrokeSequence = /** @class */ (function (_super) {
        __extends(RecordedKeystrokeSequence, _super);
        function RecordedKeystrokeSequence(ins, outs, msg) {
            var _this = _super.call(this) || this;
            if (ins) {
                if (ins instanceof Array) {
                    _this.inputs = [].concat(ins);
                }
                else {
                    // We're constructing from existing JSON.
                    _this.inputs = [];
                    for (var ie = 0; ie < ins.inputs.length; ie++) {
                        _this.inputs.push(RecordedKeystroke.fromJSONObject(ins.inputs[ie]));
                    }
                    _this.output = ins.output;
                    _this.msg = ins.msg;
                    return _this;
                }
            }
            else {
                _this.inputs = [];
            }
            if (outs) {
                _this.output = outs;
            }
            if (msg) {
                _this.msg = msg;
            }
            return _this;
        }
        RecordedKeystrokeSequence.prototype.addInput = function (event, output) {
            this.inputs.push(event);
            this.output = output;
        };
        RecordedKeystrokeSequence.prototype.hasOSKInteraction = function () {
            for (var i = 0; i < this.inputs.length; i++) {
                if (this.inputs[i] instanceof RecordedSyntheticKeystroke) {
                    return true;
                }
            }
            return false;
        };
        return RecordedKeystrokeSequence;
    }(TestSequence));
    KMWRecorder.RecordedKeystrokeSequence = RecordedKeystrokeSequence;
    var FontStubForLanguage = /** @class */ (function () {
        function FontStubForLanguage(activeStubEntry) {
            this.family = activeStubEntry.family;
            var src = activeStubEntry.files;
            if (!(src instanceof Array)) {
                src = [src];
            }
            this.source = [];
            for (var i = 0; i < src.length; i++) {
                this.source.push(activeStubEntry.path + src[i]);
            }
        }
        return FontStubForLanguage;
    }());
    var LanguageStubForKeyboard = /** @class */ (function () {
        function LanguageStubForKeyboard(activeStub) {
            if (activeStub.KLC) {
                this.id = activeStub.KLC;
                this.name = activeStub.KL;
                this.region = activeStub.KR;
                // Fonts.
                if (activeStub.KFont) {
                    this.font = new FontStubForLanguage(activeStub.KFont);
                }
                if (activeStub.KOskFont) {
                    this.oskFont = new FontStubForLanguage(activeStub.KOskFont);
                }
            }
            else {
                this.id = activeStub.id;
                this.name = activeStub.name;
                this.region = activeStub.region;
                // If we end up adding functionality to FontStubForLanguage, we'll need to properly reconstruct these.
                this.font = activeStub.font;
                this.oskFont = activeStub.oskFont;
            }
        }
        return LanguageStubForKeyboard;
    }());
    KMWRecorder.LanguageStubForKeyboard = LanguageStubForKeyboard;
    var KeyboardStub = /** @class */ (function () {
        // Constructs a stub usable with KeymanWeb's addKeyboards() API function from
        // the internally-tracked ActiveStub value for that keyboard.
        function KeyboardStub(json) {
            if (json) {
                this.id = json.id;
                this.name = json.name;
                this.filename = json.filename;
                if (!Array.isArray(json.languages)) {
                    this.languages = new LanguageStubForKeyboard(json.languages);
                }
                else {
                    this.languages = [];
                    for (var i = 0; i < json.languages.length; i++) {
                        this.languages.push(new LanguageStubForKeyboard(json.languages[i]));
                    }
                }
            }
        }
        KeyboardStub.prototype.getFirstLanguage = function () {
            if (this.languages instanceof LanguageStubForKeyboard) {
                return this.languages.id;
            }
            else {
                return this.languages[0].id;
            }
        };
        return KeyboardStub;
    }());
    KMWRecorder.KeyboardStub = KeyboardStub;
    var Constraint = /** @class */ (function () {
        function Constraint(target, validOSList, validBrowsers) {
            if (typeof (target) == 'string') {
                this.target = target;
                this.validOSList = validOSList;
                this.validBrowsers = validBrowsers;
            }
            else {
                var json = target;
                this.target = json.target;
                this.validOSList = json.validOSList;
                this.validBrowsers = json.validBrowsers;
            }
        }
        Constraint.prototype.matchesClient = function (device, usingOSK) {
            // #1:  Platform check.
            if (usingOSK === true) {
                if (this.target != device.formFactor) {
                    return false;
                }
            }
            else if (usingOSK === false) {
                if (this.target != 'hardware') {
                    return false;
                }
            }
            else if (this.target != device.formFactor && this.target != 'hardware') {
                return false;
            }
            if (this.validOSList) {
                if (this.validOSList.indexOf(device.OS) == -1) {
                    return false;
                }
            }
            if (this.validBrowsers) {
                if (this.validBrowsers.indexOf(device.browser) == -1) {
                    return false;
                }
            }
            return true;
        };
        // Checks if another Constraint instance is functionally identical to this one.
        Constraint.prototype.equals = function (other) {
            if (this.target != other.target) {
                return false;
            }
            var list1 = this.validOSList ? this.validOSList : ['any'];
            var list2 = other.validOSList ? other.validOSList : ['any'];
            if (list1.sort().join(',') != list2.sort().join(',')) {
                return false;
            }
            list1 = this.validBrowsers ? this.validBrowsers : ['web'];
            list2 = other.validBrowsers ? other.validBrowsers : ['web'];
            if (list1.sort().join(',') != list2.sort().join(',')) {
                return false;
            }
            return true;
        };
        return Constraint;
    }());
    KMWRecorder.Constraint = Constraint;
    var TestFailure = /** @class */ (function () {
        function TestFailure(constraint, test, output) {
            this.constraint = constraint;
            this.test = test;
            this.result = output;
        }
        return TestFailure;
    }());
    KMWRecorder.TestFailure = TestFailure;
    /**
     * The core constraint-specific test set definition used for testing versions 10.0 to 13.0.
     */
    var EventSpecTestSet = /** @class */ (function () {
        function EventSpecTestSet(constraint) {
            if ("target" in constraint) {
                this.constraint = constraint;
                this.testSet = [];
            }
            else {
                var json = constraint;
                this.constraint = new Constraint(json.constraint);
                this.testSet = [];
                // Clone each test sequence / reconstruct from methodless JSON object.
                for (var i = 0; i < json.testSet.length; i++) {
                    this.testSet.push(new InputEventSpecSequence(json.testSet[i]));
                }
            }
        }
        EventSpecTestSet.prototype.addTest = function (seq) {
            this.testSet.push(seq);
        };
        // Used to determine if the current EventSpecTestSet is applicable to be run on a device.
        EventSpecTestSet.prototype.isValidForDevice = function (device, usingOSK) {
            return this.constraint.matchesClient(device, usingOSK);
        };
        // Validity should be checked before calling this method.
        EventSpecTestSet.prototype.test = function (proctor) {
            var failures = [];
            var testSet = this.testSet;
            for (var i = 0; i < testSet.length; i++) {
                var testSeq = this[i];
                var simResult = testSet[i].test(proctor);
                if (!simResult.success) {
                    // Failed test!
                    failures.push(new TestFailure(this.constraint, testSeq, simResult.result));
                }
            }
            return failures.length > 0 ? failures : null;
        };
        return EventSpecTestSet;
    }());
    KMWRecorder.EventSpecTestSet = EventSpecTestSet;
    /**
     * The core constraint-specific test set definition used for testing versions 10.0 to 13.0.
     */
    var RecordedSequenceTestSet = /** @class */ (function () {
        function RecordedSequenceTestSet(constraint) {
            if ("target" in constraint) {
                this.constraint = constraint;
                this.testSet = [];
            }
            else {
                var json = constraint;
                this.constraint = new Constraint(json.constraint);
                this.testSet = [];
                // Clone each test sequence / reconstruct from methodless JSON object.
                for (var i = 0; i < json.testSet.length; i++) {
                    this.testSet.push(new RecordedKeystrokeSequence(json.testSet[i]));
                }
            }
        }
        RecordedSequenceTestSet.prototype.addTest = function (seq) {
            this.testSet.push(seq);
        };
        // Used to determine if the current EventSpecTestSet is applicable to be run on a device.
        RecordedSequenceTestSet.prototype.isValidForDevice = function (device, usingOSK) {
            return this.constraint.matchesClient(device, usingOSK);
        };
        // Validity should be checked before calling this method.
        RecordedSequenceTestSet.prototype.test = function (proctor) {
            var failures = [];
            var testSet = this.testSet;
            for (var i = 0; i < testSet.length; i++) {
                var testSeq = this[i];
                var simResult = testSet[i].test(proctor);
                if (!simResult.success) {
                    // Failed test!
                    failures.push(new TestFailure(this.constraint, testSeq, simResult.result));
                }
            }
            return failures.length > 0 ? failures : null;
        };
        RecordedSequenceTestSet.prototype.toTestName = function () {
            var name = "constraint: for " + this.constraint.target;
            if (this.constraint.target == 'hardware') {
                name += " keyboard";
            }
            else {
                name += " OSK";
            }
            if (this.constraint.validOSList) {
                name += " on OS of " + JSON.stringify(this.constraint.validOSList);
            }
            if (this.constraint.validBrowsers) {
                name += " in browser of " + JSON.stringify(this.constraint.validBrowsers);
            }
            return name;
        };
        return RecordedSequenceTestSet;
    }());
    KMWRecorder.RecordedSequenceTestSet = RecordedSequenceTestSet;
    var KeyboardTest = /** @class */ (function () {
        /**
         * Reconstructs a KeyboardTest object from its JSON representation, restoring its methods.
         * @param fromJSON
         */
        function KeyboardTest(fromJSON) {
            /**
             * Indicates what version of KMW's recorder the spec conforms to.
             */
            this.specVersion = KeyboardTest.CURRENT_VERSION;
            if (!fromJSON) {
                this.keyboard = null;
                this.inputTestSets = [];
                return;
            }
            else if (typeof (fromJSON) == 'string') {
                fromJSON = JSON.parse(fromJSON);
            }
            else if (fromJSON instanceof KeyboardStub) {
                this.keyboard = fromJSON;
                this.inputTestSets = [];
                return;
            }
            if (!fromJSON.specVersion) {
                fromJSON.specVersion = KeyboardTest.FALLBACK_VERSION;
            }
            else {
                // Is serialized to a String when saved.
                fromJSON.specVersion = new com.keyman.utils.Version(fromJSON.specVersion);
            }
            this.keyboard = new KeyboardStub(fromJSON.keyboard);
            this.inputTestSets = [];
            this.specVersion = fromJSON.specVersion;
            if (this.specVersion.equals(KeyboardTest.FALLBACK_VERSION)) {
                // Top-level test spec:  EventSpecTestSet, based entirely on browser events.
                for (var i = 0; i < fromJSON.inputTestSets.length; i++) {
                    this.inputTestSets[i] = new EventSpecTestSet(fromJSON.inputTestSets[i]);
                }
            }
            else {
                for (var i = 0; i < fromJSON.inputTestSets.length; i++) {
                    this.inputTestSets[i] = new RecordedSequenceTestSet(fromJSON.inputTestSets[i]);
                }
            }
        }
        KeyboardTest.prototype.addTest = function (constraint, seq) {
            if (!this.specVersion.equals(KeyboardTest.CURRENT_VERSION)) {
                throw new Error("The currently-loaded test was built to an outdated specification and may not be altered.");
            }
            for (var i = 0; i < this.inputTestSets.length; i++) {
                if (this.inputTestSets[i].constraint.equals(constraint)) {
                    this.inputTestSets[i].addTest(seq);
                    return;
                }
            }
            var newSet = new RecordedSequenceTestSet(new Constraint(constraint));
            this.inputTestSets.push(newSet);
            newSet.addTest(seq);
        };
        KeyboardTest.prototype.test = function (proctor) {
            var setHasRun = false;
            var failures = [];
            proctor.beforeAll();
            // The original test spec requires a browser environment and thus requires its own `.run` implementation.
            if (!(proctor.compatibleWithSuite(this))) {
                throw Error("Cannot perform version " + KeyboardTest.FALLBACK_VERSION + "-based testing outside of browser-based environments.");
            }
            // Otherwise, the test spec instances will know how to run in any currently-supported environment.
            for (var i = 0; i < this.inputTestSets.length; i++) {
                var testSet = this.inputTestSets[i];
                if (proctor.matchesTestSet(testSet)) {
                    var testFailures = testSet.test(proctor);
                    if (testFailures) {
                        failures = failures.concat(testFailures);
                    }
                    setHasRun = true;
                }
            }
            if (!setHasRun) {
                // The sets CAN be empty, allowing silent failure if/when we actually want that.
                console.warn("No test sets for this keyboard were applicable for this device!");
            }
            // Allow the method's caller to trigger a 'fail'.
            if (failures.length > 0) {
                return failures;
            }
            else {
                return null;
            }
        };
        KeyboardTest.prototype.isEmpty = function () {
            return this.inputTestSets.length == 0;
        };
        KeyboardTest.prototype.toPrettyJSON = function () {
            return JSON.stringify(this, null, '  ');
        };
        Object.defineProperty(KeyboardTest.prototype, "isLegacy", {
            get: function () {
                return !this.specVersion.equals(KeyboardTest.CURRENT_VERSION);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * The version of KMW in which the Recorder was first written.  Worked from 10.0 to 13.0 with
         * only backward-compatible changes and minor tweaks to conform to internal API shifts.
         */
        KeyboardTest.FALLBACK_VERSION = new com.keyman.utils.Version("10.0");
        KeyboardTest.CURRENT_VERSION = new com.keyman.utils.Version("14.0");
        return KeyboardTest;
    }());
    KMWRecorder.KeyboardTest = KeyboardTest;
})(KMWRecorder || (KMWRecorder = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC93ZWItZW52aXJvbm1lbnQvZW52aXJvbm1lbnQuaW5jLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAvd2ViLXV0aWxzL3NyYy9kZWVwQ29weS50cyIsIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL3dlYi11dGlscy9zcmMvZ2xvYmFsT2JqZWN0LnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAvd2ViLXV0aWxzL3NyYy92ZXJzaW9uLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAvd2ViLXV0aWxzL3NyYy9rbXdzdHJpbmcudHMiLCIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC93ZWItdXRpbHMvc3JjL2RldmljZVNwZWMudHMiLCIuLi9ub2RlX21vZHVsZXMvQGtleW1hbmFwcC93ZWItdXRpbHMvc3JjL2luZGV4LnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L2RlYWRrZXlzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL0BrZXltYW5hcHAva2V5Ym9hcmQtcHJvY2Vzc29yL3NyYy90ZXh0L291dHB1dFRhcmdldC50cyIsIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL2tleWJvYXJkLXByb2Nlc3Nvci9zcmMvdGV4dC9rZXlFdmVudC50cyIsIi4uL3NyYy9wcm9jdG9yLnRzIiwiLi4vc3JjL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFDQUFxQztBQUNyQyxJQUFVLEdBQUcsQ0FLWjtBQUxELFdBQVUsR0FBRztJQUFDLElBQUEsTUFBTSxDQUtuQjtJQUxhLFdBQUEsTUFBTTtRQUFDLElBQUEsV0FBVyxDQUsvQjtRQUxvQixXQUFBLFdBQVc7WUFDbkIsbUJBQU8sR0FBRyxNQUFNLENBQUM7WUFDakIsaUJBQUssR0FBRyxFQUFFLENB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QUFBLENBQUMsQ0FBQyxPQUFPLENBQUM7SUFDbEQsQ0FBQyxDQUFDLGVBQWUsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUU7SUFDaEUsQ0FBQyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDN0MsQ0FBQyxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDekQsQ0FBQyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFDdEQsQ0FBQyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFDdEQsQ0FBQyxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7SUFDNUQsQ0FBQyxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7SUFDNUQsQ0FBQyxDQUFDLHVCQUF1QixHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMseUJBQXlCLENBQUM7SUFDN0YsQ0FBQyxDQUFDLHVCQUF1QixHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMseUJBQXlCLENBQUM7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XG5uYW1lc3BhY2UgY29tLmtleW1hbi5lbnZpcm9ubWVudCB7XG4gIGV4cG9ydCB2YXIgVkVSU0lPTiA9IFwiMTUuMFwiO1xuICBleHBvcnQgdmFyIEJVSUxEID0gODY7XG4gIGV4cG9ydCB2YXIgRU5WSVJPTk1FTlQgPSBcImxvY2FsXCI7XG4gIGV4cG9ydCB2YXIgU0VOVFJZX1JFTEVBU0UgPSBcInJlbGVhc2UtMTUuMC44Ni1hbHBoYS1sb2NhbFwiO1xufVxuXG4iLCJuYW1lc3BhY2UgY29tLmtleW1hbi51dGlscyB7XHJcbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gICAgIGRlZXBDb3B5XHJcbiAgICogU2NvcGUgICAgICAgIFByaXZhdGVcclxuICAgKiBAcGFyYW0gICAgICAge09iamVjdH0gICAgICBwICAgICAgICAgICBvYmplY3QgdG8gY29weVxyXG4gICAqIEBwYXJhbSAgICAgICB7QXJyYXk9fSAgICAgIGMwICAgICAgICAgIGFycmF5IG1lbWJlciBiZWluZyBjb3BpZWRcclxuICAgKiBAcmV0dXJuICAgICAge09iamVjdH0gICAgICAgICAgICAgICAgICBjbG9uZSAoJ2RlZXAgY29weScpIG9mIG9iamVjdFxyXG4gICAqIERlc2NyaXB0aW9uICBNYWtlcyBhbiBhY3R1YWwgY29weSAobm90IGEgcmVmZXJlbmNlKSBvZiBhbiBvYmplY3QsIGNvcHlpbmcgc2ltcGxlIG1lbWJlcnMsXHJcbiAgICogICAgICAgICAgICAgIGFycmF5cyBhbmQgbWVtYmVyIG9iamVjdHMgYnV0IG5vdCBmdW5jdGlvbnMsIHNvIHVzZSB3aXRoIGNhcmUhXHJcbiAgICovXHJcbiAgZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5PFQ+KHA6VCwgYzA/KTogVCB7XHJcbiAgICB2YXIgYyA9IGMwIHx8IHt9O1xyXG4gICAgZm9yICh2YXIgaSBpbiBwKSB7XHJcbiAgICAgIGlmKHR5cGVvZiBwW2ldID09PSAnb2JqZWN0JyAmJiBwW2ldICE9IG51bGwpIHtcclxuICAgICAgICBjW2ldID0gKHBbaV0uY29uc3RydWN0b3IgPT09IEFycmF5ICkgPyBbXSA6IHt9O1xyXG4gICAgICAgIGRlZXBDb3B5KHBbaV0sY1tpXSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY1tpXSA9IHBbaV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYztcclxuICB9XHJcbn0iLCJuYW1lc3BhY2UgY29tLmtleW1hbi51dGlscyB7XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgYmFzZSBnbG9iYWwgb2JqZWN0IGF2YWlsYWJsZSB0byB0aGUgY3VycmVudCBKUyBwbGF0Zm9ybS5cclxuICAgKiAtIEluIGJyb3dzZXJzLCByZXR1cm5zIGB3aW5kb3dgLlxyXG4gICAqIC0gSW4gV2ViV29ya2VycywgcmV0dXJucyBgc2VsZmAuXHJcbiAgICogLSBJbiBOb2RlLCByZXR1cm5zIGBnbG9iYWxgLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRHbG9iYWxPYmplY3QoKTogdHlwZW9mIGdsb2JhbFRoaXMge1xyXG4gICAgLy8gRXZlcmdyZWVuIGJyb3dzZXJzIGhhdmUgc3RhcnRlZCBkZWZpbmluZyAnZ2xvYmFsVGhpcycuICBcclxuICAgIC8vIFJlZmVyIHRvIGh0dHBzOi8vZGV2YmxvZ3MubWljcm9zb2Z0LmNvbS90eXBlc2NyaXB0L2Fubm91bmNpbmctdHlwZXNjcmlwdC0zLTQvI3R5cGUtY2hlY2tpbmctZm9yLWdsb2JhbHRoaXNcclxuICAgIC8vIGFuZCBpdHMgcmVmZXJlbmNlZCBwb2x5ZmlsbC4gIFNhaWQgcG9seWZpbGwgaXMgdmVyeSBjb21wbGV4LCBzbyB3ZSBvcHQgZm9yIHRoaXMgZmFyIGxlYW5lciB2YXJpYW50LlxyXG4gICAgaWYodHlwZW9mIGdsb2JhbFRoaXMgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7ICAvLyBOb3QgYXZhaWxhYmxlIGluIElFIG9yIG9sZGVyIEVkZ2UgdmVyc2lvbnNcclxuICAgICAgLy8gQHRzLWlnbm9yZSAoVFMgd2lsbCB0aHJvdyBlcnJvcnMgZm9yIHdoYXRldmVyIHBsYXRmb3JtIHdlJ3JlIG5vdCBjb21waWxpbmcgZm9yLilcclxuICAgIH0gZWxzZSBpZih0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgcmV0dXJuIHdpbmRvdzsgLy8gVGhlIGJyb3dzZXItYmFzZWQgY2xhc3NpY1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICB9IGVsc2UgaWYodHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICByZXR1cm4gc2VsZjsgLy8gV2ViV29ya2VyIGdsb2JhbFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQXNzdW1wdGlvbiAtIGlmIG5laXRoZXIgb2YgdGhlIGFib3ZlIGV4aXN0LCB3ZSdyZSBpbiBOb2RlLCBmb3IgdW5pdC10ZXN0aW5nLlxyXG4gICAgICAvLyBOb2RlIGRvZXNuJ3QgaGF2ZSBhcyBtYW55IG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXMgdGhlIG90aGVyIHR3bywgYnV0IHdoYXQgXHJcbiAgICAgIC8vIG1hdHRlcnMgZm9yIHVzIGlzIHRoYXQgaXQncyB0aGUgYmFzZSBnbG9iYWwuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFNvbWUgb3RoZXIgaGVhZGxlc3MgSlMgc29sdXRpb25zIHVzZSAndGhpcycgaW5zdGVhZCwgYnV0IE5vZGUncyBlbm91Z2ggZm9yIG91ciBuZWVkcy5cclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICByZXR1cm4gKGdsb2JhbCBhcyBhbnkpIGFzIHR5cGVvZiBnbG9iYWxUaGlzO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIEVuc3VyZSB0aGF0IHRoaXMgY2xhc3MgY29udGFpbnMgbm8gcmVmZXJlbmNlIGludG8gY29yZSBLTVcgY29kZSAtIGl0IGlzIHJlZmVyZW5jZWRcclxuLy8gYnkgY29tcG9uZW50cyBpbnRlbmRlZCB0byBiZSBtb2R1bGFyIGFuZCBwb3NzaWJsZSB0byBzZXBhcmF0ZSBmcm9tIGNvcmUgS01XLlxyXG5cclxubmFtZXNwYWNlIGNvbS5rZXltYW4udXRpbHMge1xyXG4gIC8vIERvdHRlZC1kZWNpbWFsIHZlcnNpb25cclxuICBleHBvcnQgY2xhc3MgVmVyc2lvbiB7XHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENVUlJFTlQgPSBuZXcgVmVyc2lvbihjb20ua2V5bWFuLmVudmlyb25tZW50LlZFUlNJT04pO1xyXG5cclxuICAgIC8vIFJlcHJlc2VudHMgYSBkZWZhdWx0IHZlcnNpb24gdmFsdWUgZm9yIGtleWJvYXJkcyBjb21waWxlZCBiZWZvcmUgdGhpcyB3YXMgY29tcGlsZWQgaW50byBrZXlib2FyZHMuXHJcbiAgICAvLyBUaGUgZXhhY3QgdmVyc2lvbiBpcyB1bmtub3duIGF0IHRoaXMgcG9pbnQsIGJ1dCB0aGUgdmFsdWUgaXMgXCJnb29kIGVub3VnaFwiIGZvciB3aGF0IHdlIG5lZWQuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFVkVMT1BFUl9WRVJTSU9OX0ZBTExCQUNLID0gbmV3IFZlcnNpb24oWzksIDAsIDBdKTtcclxuXHJcbiAgICAvLyBGb3IgMTIuMCwgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIG9mIGFkZGluZyBtaXNzaW5nIGtleWNhcHMgdG8gdGhlIGRlZmF1bHQgbGF5ZXJzIHdhcyByZW1vdmVkLFxyXG4gICAgLy8gYXMgaXQgcmVzdWx0cyBpbiB1bmV4cGVjdGVkLCBidWctbGlrZSBiZWhhdmlvciBmb3Iga2V5Ym9hcmQgZGVzaWduZXJzIHdoZW4gaXQgaXMgdW53YW50ZWQuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE5PX0RFRkFVTFRfS0VZQ0FQUyA9IG5ldyBWZXJzaW9uKFsxMiwgMF0pO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTUFDX1BPU1NJQkxFX0lQQURfQUxJQVMgPSBuZXcgVmVyc2lvbihbMTAsIDE1XSk7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb21wb25lbnRzOiBudW1iZXJbXVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHZlcnNpb24gaW5mb3JtYXRpb24sIHByZXBhcmluZyBpdCBmb3IgdXNlIGluIGNvbXBhcmlzb25zLlxyXG4gICAgICogQHBhcmFtIHRleHQgRWl0aGVyIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHZlcnNpb24gbnVtYmVyIChleDogXCI5LjAuMFwiKSBvciBhbiBhcnJheSByZXByZXNlbnRpbmdcclxuICAgICAqICAgICAgICAgICAgIGl0cyBjb21wb25lbnRzIChleDogWzksIDAsIDBdKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGV4dDogU3RyaW5nIHwgbnVtYmVyW10pIHtcclxuICAgICAgLy8gSWYgYSBrZXlib2FyZCBkb2Vzbid0IHNwZWNpZnkgYSB2ZXJzaW9uLCB1c2UgdGhlIERFVkVMT1BFUl9WRVJTSU9OX0ZBTExCQUNLIHZhbHVlcy5cclxuICAgICAgaWYodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXS5jb25jYXQoVmVyc2lvbi5ERVZFTE9QRVJfVkVSU0lPTl9GQUxMQkFDSy5jb21wb25lbnRzKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcclxuICAgICAgICBsZXQgY29tcG9uZW50cyA9IHRleHQgYXMgbnVtYmVyW107XHJcbiAgICAgICAgaWYoY29tcG9uZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZXJzaW9uIHN0cmluZyBtdXN0IGhhdmUgYXQgbGVhc3QgYSBtYWpvciBhbmQgbWlub3IgY29tcG9uZW50IVwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW10uY29uY2F0KGNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZWxzZSwgc3RhbmRhcmQgY29uc3RydWN0b3IgcGF0aC5cclxuICAgICAgbGV0IHBhcnRzID0gdGV4dC5zcGxpdCgnLicpO1xyXG4gICAgICBsZXQgY29tcG9uZW50QXJyYXk6IG51bWJlcltdID0gW107XHJcblxyXG4gICAgICBpZihwYXJ0cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBzdHJpbmcgbXVzdCBoYXZlIGF0IGxlYXN0IGEgbWFqb3IgYW5kIG1pbm9yIGNvbXBvbmVudCFcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcihsZXQgaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xyXG4gICAgICAgIGlmKGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBzdHJpbmcgY29tcG9uZW50cyBtdXN0IGJlIG51bWVyaWNhbCFcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb21wb25lbnRBcnJheS5wdXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50QXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG1ham9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG1pbm9yKCk6IG51bWJlciB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNbMV07XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5qb2luKCcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdG9KU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKG90aGVyOiBWZXJzaW9uKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwcmVjZWRlcyhvdGhlcjogVmVyc2lvbik6IGJvb2xlYW4ge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpIDwgMDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wYXJlVG8ob3RoZXI6IFZlcnNpb24pOiBudW1iZXIge1xyXG4gICAgICAvLyBJZiB0aGUgdmVyc2lvbiBpbmZvIGRlcHRoIGRpZmZlcnMsIHdlIG5lZWQgYSBmbGFnIHRvIGluZGljYXRlIHdoaWNoIGluc3RhbmNlIGlzIHNob3J0ZXIuXHJcbiAgICAgIHZhciBpc1Nob3J0ZXI6IGJvb2xlYW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoIDwgb3RoZXIuY29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICAgIHZhciBtYXhEZXB0aDogbnVtYmVyID0gKHRoaXMuY29tcG9uZW50cy5sZW5ndGggPCBvdGhlci5jb21wb25lbnRzLmxlbmd0aCkgPyB0aGlzLmNvbXBvbmVudHMubGVuZ3RoIDogb3RoZXIuY29tcG9uZW50cy5sZW5ndGg7XHJcblxyXG4gICAgICB2YXIgaTogbnVtYmVyO1xyXG4gICAgICBmb3IoaSA9IDA7IGkgPCBtYXhEZXB0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gdGhpcy5jb21wb25lbnRzW2ldIC0gb3RoZXIuY29tcG9uZW50c1tpXTtcclxuICAgICAgICBpZihkZWx0YSAhPSAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbG9uZ0xpc3QgPSBpc1Nob3J0ZXIgPyBvdGhlci5jb21wb25lbnRzIDogdGhpcy5jb21wb25lbnRzO1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgaWYobG9uZ0xpc3RbaV0gPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gaXNTaG9ydGVyID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICAgIH0gd2hpbGUgKGkgPCBsb25nTGlzdC5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gRXF1YWwuXHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8qKipcclxuICAgS2V5bWFuV2ViIDE0LjBcclxuICAgQ29weXJpZ2h0IDIwMjAgU0lMIEludGVybmF0aW9uYWxcclxuKioqL1xyXG5cclxuLypcclxuICogVE9ETzogIFJlbW92ZSB0aGlzIGZpbGUgYXMgcGFydCBvZiBhZGRyZXNzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXltYW5hcHAva2V5bWFuL2lzc3Vlcy8yNDkyLlxyXG4gKi9cclxuXHJcbmludGVyZmFjZSBTdHJpbmdDb25zdHJ1Y3RvciB7XHJcbiAga213RnJvbUNoYXJDb2RlKGNwMDogbnVtYmVyKTogc3RyaW5nLFxyXG4gIF9rbXdGcm9tQ2hhckNvZGUoY3AwOiBudW1iZXIpOiBzdHJpbmcsXHJcbiAga213RW5hYmxlU3VwcGxlbWVudGFyeVBsYW5lKGJFbmFibGU6IGJvb2xlYW4pXHJcbn1cclxuXHJcbmludGVyZmFjZSBTdHJpbmcge1xyXG4gIGttd0NoYXJDb2RlQXQoY29kZVBvaW50SW5kZXg6IG51bWJlcik6IG51bWJlcixcclxuICBrbXdDaGFyQXQoY29kZVBvaW50SW5kZXg6IG51bWJlcikgOiBzdHJpbmcsXHJcbiAga213SW5kZXhPZihzZWFyY2hWYWx1ZTogc3RyaW5nLCBmcm9tSW5kZXg/OiBudW1iZXIpIDogbnVtYmVyLFxyXG4gIGttd0xhc3RJbmRleE9mKHNlYXJjaFZhbHVlOiBzdHJpbmcsIGZyb21JbmRleD86IG51bWJlcikgOiBudW1iZXIsXHJcbiAga213U2xpY2UoYmVnaW5TbGljZTogbnVtYmVyLCBlbmRTbGljZTogbnVtYmVyKSA6IHN0cmluZyxcclxuICBrbXdTdWJzdHJpbmcoc3RhcnQ6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIGttd1N1YnN0cihzdGFydDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIGttd0JNUFN1YnN0cihzdGFydDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIGttd0xlbmd0aCgpOiBudW1iZXIsXHJcbiAga213Qk1QTGVuZ3RoKCk6IG51bWJlcixcclxuICBrbXdOZXh0Q2hhcihjb2RlVW5pdEluZGV4OiBudW1iZXIpOiBudW1iZXIsXHJcbiAga213Qk1QTmV4dENoYXIoY29kZVVuaXRJbmRleDogbnVtYmVyKTogbnVtYmVyLFxyXG4gIGttd1ByZXZDaGFyKGNvZGVVbml0SW5kZXg6IG51bWJlcik6IG51bWJlcixcclxuICBrbXdCTVBQcmV2Q2hhcihjb2RlVW5pdEluZGV4OiBudW1iZXIpOiBudW1iZXIsXHJcbiAga213Q29kZVBvaW50VG9Db2RlVW5pdChjb2RlUG9pbnRJbmRleDogbnVtYmVyKSA6IG51bWJlcixcclxuICBrbXdCTVBDb2RlUG9pbnRUb0NvZGVVbml0KGNvZGVQb2ludEluZGV4OiBudW1iZXIpIDogbnVtYmVyLFxyXG4gIGttd0NvZGVVbml0VG9Db2RlUG9pbnQoY29kZVVuaXRJbmRleDogbnVtYmVyKSA6IG51bWJlcixcclxuICBrbXdCTVBDb2RlVW5pdFRvQ29kZVBvaW50KGNvZGVVbml0SW5kZXg6IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd0NoYXJDb2RlQXQoY29kZVBvaW50SW5kZXg6IG51bWJlcik6IG51bWJlcixcclxuICBfa213Q2hhckF0KGNvZGVQb2ludEluZGV4OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIF9rbXdJbmRleE9mKHNlYXJjaFZhbHVlOiBzdHJpbmcsIGZyb21JbmRleD86IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd0xhc3RJbmRleE9mKHNlYXJjaFZhbHVlOiBzdHJpbmcsIGZyb21JbmRleD86IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd1NsaWNlKGJlZ2luU2xpY2U6IG51bWJlciwgZW5kU2xpY2U6IG51bWJlcikgOiBzdHJpbmcsXHJcbiAgX2ttd1N1YnN0cmluZyhzdGFydDogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpIDogc3RyaW5nLFxyXG4gIF9rbXdTdWJzdHIoc3RhcnQ6IG51bWJlciwgbGVuZ3RoPzogbnVtYmVyKSA6IHN0cmluZyxcclxuICBfa213TGVuZ3RoKCk6IG51bWJlcixcclxuICBfa213TmV4dENoYXIoY29kZVVuaXRJbmRleDogbnVtYmVyKTogbnVtYmVyLFxyXG4gIF9rbXdQcmV2Q2hhcihjb2RlVW5pdEluZGV4OiBudW1iZXIpOiBudW1iZXIsXHJcbiAgX2ttd0NvZGVQb2ludFRvQ29kZVVuaXQoY29kZVBvaW50SW5kZXg6IG51bWJlcikgOiBudW1iZXIsXHJcbiAgX2ttd0NvZGVVbml0VG9Db2RlUG9pbnQoY29kZVVuaXRJbmRleDogbnVtYmVyKSA6IG51bWJlcixcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBzdHJpbmcgZnJvbSBvbmUgb3IgbW9yZSBVbmljb2RlIGNoYXJhY3RlciBjb2RlcG9pbnQgdmFsdWVzIFxyXG4gKiBwYXNzZWQgYXMgaW50ZWdlciBwYXJhbWV0ZXJzLlxyXG4gKiBcclxuICogQHBhcmFtICB7bnVtYmVyfSBjcDAsLi4uICAgMSBvciBtb3JlIFVuaWNvZGUgY29kZXBvaW50cywgZS5nLiAweDAwNjUsIDB4MTAwMDBcclxuICogQHJldHVybiB7c3RyaW5nfG51bGx9ICAgICAgVGhlIG5ldyBTdHJpbmcgb2JqZWN0LlxyXG4gKi9cclxuU3RyaW5nLmttd0Zyb21DaGFyQ29kZSA9IGZ1bmN0aW9uKGNwMCkge1xyXG4gIHZhciBjaGFycyA9IFtdLCBpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBjID0gTnVtYmVyKGFyZ3VtZW50c1tpXSk7XHJcbiAgICBpZiAoIWlzRmluaXRlKGMpIHx8IGMgPCAwIHx8IGMgPiAweDEwRkZGRiB8fCBNYXRoLmZsb29yKGMpICE9PSBjKSB7XHJcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50IFwiICsgYyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcclxuICAgICAgY2hhcnMucHVzaChjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGMgLT0gMHgxMDAwMDtcclxuICAgICAgY2hhcnMucHVzaCgoYyA+PiAxMCkgKyAweEQ4MDApO1xyXG4gICAgICBjaGFycy5wdXNoKChjICUgMHg0MDApICsgMHhEQzAwKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkodW5kZWZpbmVkLCBjaGFycyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgdGhlIFVuaWNvZGUgdmFsdWUgb2YgdGhlIGNoYXJhY3RlciBhdCB0aGUgZ2l2ZW4gXHJcbiAqIGNvZGUgcG9pbnQgaW5kZXgsIHdpdGggc3VwcG9ydCBmb3Igc3VwcGxlbWVudGFyeSBwbGFuZSBjaGFyYWN0ZXJzLlxyXG4gKiBcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVBvaW50SW5kZXggIFRoZSBjb2RlIHBvaW50IGluZGV4IGludG8gdGhlIHN0cmluZyAobm90IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNvZGUgdW5pdCBpbmRleCkgdG8gcmV0dXJuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICBUaGUgVW5pY29kZSBjaGFyYWN0ZXIgdmFsdWVcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213Q2hhckNvZGVBdCA9IGZ1bmN0aW9uKGNvZGVQb2ludEluZGV4KSB7XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICB2YXIgY29kZVVuaXRJbmRleCA9IDA7XHJcbiAgXHJcbiAgaWYgKGNvZGVQb2ludEluZGV4IDwgMCB8fCBjb2RlUG9pbnRJbmRleCAgPj0gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIE5hTjtcclxuICB9XHJcblxyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRJbmRleDsgaSsrKSB7XHJcbiAgICBjb2RlVW5pdEluZGV4ID0gc3RyLmttd05leHRDaGFyKGNvZGVVbml0SW5kZXgpO1xyXG4gICAgaWYoY29kZVVuaXRJbmRleCA9PT0gbnVsbCkgcmV0dXJuIE5hTjtcclxuICB9XHJcbiAgXHJcbiAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCk7XHJcbiAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgc3RyLmxlbmd0aCA+IGNvZGVVbml0SW5kZXggKyAxKSB7XHJcbiAgICB2YXIgc2Vjb25kID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCArIDEpO1xyXG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xyXG4gICAgICByZXR1cm4gKChmaXJzdCAtIDB4RDgwMCkgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmlyc3Q7ICBcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvZGUgcG9pbnQgaW5kZXggd2l0aGluIHRoZSBjYWxsaW5nIFN0cmluZyBvYmplY3Qgb2YgdGhlIGZpcnN0IG9jY3VycmVuY2VcclxuICogb2YgdGhlIHNwZWNpZmllZCB2YWx1ZSwgb3IgLTEgaWYgbm90IGZvdW5kLlxyXG4gKiBcclxuICogQHBhcmFtICB7c3RyaW5nfSAgc2VhcmNoVmFsdWUgICAgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3JcclxuICogQHBhcmFtICB7bnVtYmVyfSAgW2Zyb21JbmRleF0gICAgT3B0aW9uYWwgY29kZSBwb2ludCBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICBUaGUgY29kZSBwb2ludCBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIHNlYXJjaCB2YWx1ZVxyXG4gKi9cclxuU3RyaW5nLnByb3RvdHlwZS5rbXdJbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUsIGZyb21JbmRleCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgdmFyIGNvZGVVbml0SW5kZXggPSBzdHIuaW5kZXhPZihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KTtcclxuICBcclxuICBpZihjb2RlVW5pdEluZGV4IDwgMCkge1xyXG4gICAgcmV0dXJuIGNvZGVVbml0SW5kZXg7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBjb2RlUG9pbnRJbmRleCA9IDA7XHJcbiAgZm9yKHZhciBpID0gMDsgaSAhPT0gbnVsbCAmJiBpIDwgY29kZVVuaXRJbmRleDsgaSA9IHN0ci5rbXdOZXh0Q2hhcihpKSkgY29kZVBvaW50SW5kZXgrKztcclxuICByZXR1cm4gY29kZVBvaW50SW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb2RlIHBvaW50IGluZGV4IHdpdGhpbiB0aGUgY2FsbGluZyBTdHJpbmcgb2JqZWN0IG9mIHRoZSBsYXN0IG9jY3VycmVuY2UgXHJcbiAqIG9mIHRoZSBzcGVjaWZpZWQgdmFsdWUsIG9yIC0xIGlmIG5vdCBmb3VuZC5cclxuICogXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gIHNlYXJjaFZhbHVlICAgIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIGZyb21JbmRleCAgICAgIE9wdGlvbmFsIGNvZGUgcG9pbnQgaW5kZXggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb21cclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgVGhlIGNvZGUgcG9pbnQgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBzZWFyY2ggdmFsdWVcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213TGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KVxyXG57XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICB2YXIgY29kZVVuaXRJbmRleCA9IHN0ci5sYXN0SW5kZXhPZihzZWFyY2hWYWx1ZSwgZnJvbUluZGV4KTtcclxuICBcclxuICBpZihjb2RlVW5pdEluZGV4IDwgMCkge1xyXG4gICAgcmV0dXJuIGNvZGVVbml0SW5kZXg7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBjb2RlUG9pbnRJbmRleCA9IDA7XHJcbiAgZm9yKHZhciBpID0gMDsgaSAhPT0gbnVsbCAmJiBpIDwgY29kZVVuaXRJbmRleDsgaSA9IHN0ci5rbXdOZXh0Q2hhcihpKSkgY29kZVBvaW50SW5kZXgrKztcclxuICByZXR1cm4gY29kZVBvaW50SW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBpbiBjb2RlIHBvaW50cywgYXMgb3Bwb3NlZCB0byBjb2RlIHVuaXRzLlxyXG4gKiBcclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgVGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGluIGNvZGUgcG9pbnRzXHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd0xlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgXHJcbiAgaWYoc3RyLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcclxuICBcclxuICBmb3IodmFyIGkgPSAwLCBjb2RlVW5pdEluZGV4ID0gMDsgY29kZVVuaXRJbmRleCAhPT0gbnVsbDsgaSsrKSBcclxuICAgIGNvZGVVbml0SW5kZXggPSBzdHIua213TmV4dENoYXIoY29kZVVuaXRJbmRleCk7XHJcbiAgcmV0dXJuIGk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBhIHNlY3Rpb24gb2YgYSBzdHJpbmcgYW5kIHJldHVybnMgYSBuZXcgc3RyaW5nLlxyXG4gKiBcclxuICogQHBhcmFtICB7bnVtYmVyfSAgYmVnaW5TbGljZSAgICBUaGUgc3RhcnQgY29kZSBwb2ludCBpbmRleCBpbiB0aGUgc3RyaW5nIHRvIFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3QgZnJvbVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRTbGljZSAgICAgIE9wdGlvbmFsIGVuZCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmdcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBleHRyYWN0IHRvXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgVGhlIHN1YnN0cmluZyBhcyBzZWxlY3RlZCBieSBiZWdpblNsaWNlIGFuZFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFNsaWNlXHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd1NsaWNlID0gZnVuY3Rpb24oYmVnaW5TbGljZSwgZW5kU2xpY2UpIHtcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpO1xyXG4gIHZhciBiZWdpblNsaWNlQ29kZVVuaXQgPSBzdHIua213Q29kZVBvaW50VG9Db2RlVW5pdChiZWdpblNsaWNlKTtcclxuICB2YXIgZW5kU2xpY2VDb2RlVW5pdCA9IHN0ci5rbXdDb2RlUG9pbnRUb0NvZGVVbml0KGVuZFNsaWNlKTtcclxuICBpZihiZWdpblNsaWNlQ29kZVVuaXQgPT09IG51bGwgfHwgZW5kU2xpY2VDb2RlVW5pdCA9PT0gbnVsbCkgXHJcbiAgICByZXR1cm4gJyc7XHJcbiAgZWxzZVxyXG4gICAgcmV0dXJuIHN0ci5zbGljZShiZWdpblNsaWNlQ29kZVVuaXQsIGVuZFNsaWNlQ29kZVVuaXQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY2hhcmFjdGVycyBpbiBhIHN0cmluZyBiZWdpbm5pbmcgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiB0aHJvdWdoXHJcbiAqIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXHJcbiAqIFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydCAgICAgICAgIFRoZSBzdGFydCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmcgdG8gXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdCBmcm9tXHJcbiAqIEBwYXJhbSAge251bWJlcj19ICBsZW5ndGggICAgICAgIE9wdGlvbmFsIGxlbmd0aCB0byBleHRyYWN0XHJcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgVGhlIHN1YnN0cmluZyBhcyBzZWxlY3RlZCBieSBzdGFydCBhbmQgbGVuZ3RoXHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd1N1YnN0ciA9IGZ1bmN0aW9uKHN0YXJ0LCBsZW5ndGg/KVxyXG57XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICBpZihzdGFydCA8IDApIFxyXG4gIHtcclxuICAgIHN0YXJ0ID0gc3RyLmttd0xlbmd0aCgpICsgc3RhcnQ7XHJcbiAgfVxyXG5cdGlmKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xyXG4gIHZhciBzdGFydENvZGVVbml0ID0gc3RyLmttd0NvZGVQb2ludFRvQ29kZVVuaXQoc3RhcnQpO1xyXG4gIHZhciBlbmRDb2RlVW5pdCA9IHN0YXJ0Q29kZVVuaXQ7XHJcbiAgXHJcbiAgaWYoc3RhcnRDb2RlVW5pdCA9PT0gbnVsbCkgcmV0dXJuICcnO1xyXG4gIFxyXG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICBlbmRDb2RlVW5pdCA9IHN0ci5sZW5ndGg7XHJcbiAgfSBlbHNlIHtcclxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgZW5kQ29kZVVuaXQgPSBzdHIua213TmV4dENoYXIoZW5kQ29kZVVuaXQpO1xyXG4gIH1cclxuICBpZihlbmRDb2RlVW5pdCA9PT0gbnVsbClcclxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0Q29kZVVuaXQpO1xyXG4gIGVsc2VcclxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0Q29kZVVuaXQsIGVuZENvZGVVbml0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcgYmV0d2VlbiB0d28gaW5kZXhlcyBpbnRvIHRoZSBzdHJpbmcuXHJcbiAqIFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBpbmRleEEgICAgICAgIFRoZSBzdGFydCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmcgdG8gXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdCBmcm9tXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIGluZGV4QiAgICAgICAgVGhlIGVuZCBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmcgdG8gXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdCB0b1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgICAgIFRoZSBzdWJzdHJpbmcgYXMgc2VsZWN0ZWQgYnkgaW5kZXhBIGFuZCBpbmRleEJcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213U3Vic3RyaW5nID0gZnVuY3Rpb24oaW5kZXhBLCBpbmRleEIpXHJcbntcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpLGluZGV4QUNvZGVVbml0LGluZGV4QkNvZGVVbml0O1xyXG4gIFxyXG4gIGlmKHR5cGVvZihpbmRleEIpID09ICd1bmRlZmluZWQnKSBcclxuICB7XHJcbiAgICBpbmRleEFDb2RlVW5pdCA9IHN0ci5rbXdDb2RlUG9pbnRUb0NvZGVVbml0KGluZGV4QSk7XHJcbiAgICBpbmRleEJDb2RlVW5pdCA9ICBzdHIubGVuZ3RoOyAgICBcclxuICB9IFxyXG4gIGVsc2VcclxuICB7XHJcbiAgICBpZihpbmRleEEgPiBpbmRleEIpIHsgdmFyIGMgPSBpbmRleEE7IGluZGV4QSA9IGluZGV4QjsgaW5kZXhCID0gYzsgfVxyXG4gIFxyXG4gICAgaW5kZXhBQ29kZVVuaXQgPSBzdHIua213Q29kZVBvaW50VG9Db2RlVW5pdChpbmRleEEpO1xyXG4gICAgaW5kZXhCQ29kZVVuaXQgPSBzdHIua213Q29kZVBvaW50VG9Db2RlVW5pdChpbmRleEIpO1xyXG4gIH1cclxuICBpZihpc05hTihpbmRleEFDb2RlVW5pdCkgfHwgaW5kZXhBQ29kZVVuaXQgPT09IG51bGwpIGluZGV4QUNvZGVVbml0ID0gMDtcclxuICBpZihpc05hTihpbmRleEJDb2RlVW5pdCkgfHwgaW5kZXhCQ29kZVVuaXQgPT09IG51bGwpIGluZGV4QkNvZGVVbml0ID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoaW5kZXhBQ29kZVVuaXQsIGluZGV4QkNvZGVVbml0KTtcclxufVxyXG5cclxuLypcclxuICBIZWxwZXIgZnVuY3Rpb25zXHJcbiovXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29kZSB1bml0IGluZGV4IGZvciB0aGUgbmV4dCBjb2RlIHBvaW50IGluIHRoZSBzdHJpbmcsIGFjY291bnRpbmcgZm9yXHJcbiAqIHN1cHBsZW1lbnRhcnkgcGFpcnMgXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcnxudWxsfSAgY29kZVVuaXRJbmRleCAgVGhlIGNvZGUgdW5pdCBwb3NpdGlvbiB0byBpbmNyZW1lbnRcclxuICogQHJldHVybiB7bnVtYmVyfG51bGx9ICAgICAgICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5leHQgY29kZSBwb2ludCBpbiB0aGUgc3RyaW5nLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGNvZGUgdW5pdHNcclxuICovXHJcblN0cmluZy5wcm90b3R5cGUua213TmV4dENoYXIgPSBmdW5jdGlvbihjb2RlVW5pdEluZGV4KSB7XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuXHJcbiAgaWYoY29kZVVuaXRJbmRleCA9PT0gbnVsbCB8fCBjb2RlVW5pdEluZGV4IDwgMCB8fCBjb2RlVW5pdEluZGV4ID49IHN0ci5sZW5ndGggLSAxKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgXHJcbiAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCk7XHJcbiAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgc3RyLmxlbmd0aCA+IGNvZGVVbml0SW5kZXggKyAxKSB7XHJcbiAgICB2YXIgc2Vjb25kID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCArIDEpO1xyXG4gICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xyXG4gICAgICBpZihjb2RlVW5pdEluZGV4ID09IHN0ci5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvZGVVbml0SW5kZXggKyAyO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY29kZVVuaXRJbmRleCArIDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgaW5kZXggZm9yIHRoZSBwcmV2aW91cyBjb2RlIHBvaW50IGluIHRoZSBzdHJpbmcsIGFjY291bnRpbmdcclxuICogZm9yIHN1cHBsZW1lbnRhcnkgcGFpcnMgXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcnxudWxsfSAgY29kZVVuaXRJbmRleCAgVGhlIGNvZGUgdW5pdCBwb3NpdGlvbiB0byBkZWNyZW1lbnRcclxuICogQHJldHVybiB7bnVtYmVyfG51bGx9ICAgICAgICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIGNvZGUgcG9pbnQgaW4gdGhlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLCBpbiBjb2RlIHVuaXRzXHJcbiovXHJcblN0cmluZy5wcm90b3R5cGUua213UHJldkNoYXIgPSBmdW5jdGlvbihjb2RlVW5pdEluZGV4KSB7XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuXHJcbiAgaWYoY29kZVVuaXRJbmRleCA9PSBudWxsIHx8IGNvZGVVbml0SW5kZXggPD0gMCB8fCBjb2RlVW5pdEluZGV4ID4gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIFxyXG4gIHZhciBzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChjb2RlVW5pdEluZGV4IC0gMSk7XHJcbiAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRiAmJiBjb2RlVW5pdEluZGV4ID4gMSkge1xyXG4gICAgdmFyIGZpcnN0ID0gc3RyLmNoYXJDb2RlQXQoY29kZVVuaXRJbmRleCAtIDIpO1xyXG4gICAgaWYoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRikge1xyXG4gICAgICByZXR1cm4gY29kZVVuaXRJbmRleCAtIDI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjb2RlVW5pdEluZGV4IC0gMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgY29kZSB1bml0IGluZGV4IHRvIHRoZSBjb2RlIHBvaW50IGluZGV4IHBhc3NlZFxyXG4gKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ8bnVsbH0gY29kZVBvaW50SW5kZXggIEEgY29kZSBwb2ludCBpbmRleCBpbiB0aGUgc3RyaW5nXHJcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfSAgICAgICAgICAgICAgICAgVGhlIGNvcnJlc3BvbmRpbmcgY29kZSB1bml0IGluZGV4XHJcbiAqL1xyXG5TdHJpbmcucHJvdG90eXBlLmttd0NvZGVQb2ludFRvQ29kZVVuaXQgPSBmdW5jdGlvbihjb2RlUG9pbnRJbmRleCkge1xyXG4gIFxyXG4gIGlmKGNvZGVQb2ludEluZGV4ID09PSBudWxsKSByZXR1cm4gbnVsbDtcclxuICBcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpO1xyXG4gIHZhciBjb2RlVW5pdEluZGV4ID0gMDtcclxuICBcclxuICBpZihjb2RlUG9pbnRJbmRleCA8IDApIHtcclxuICAgIGNvZGVVbml0SW5kZXggPSBzdHIubGVuZ3RoO1xyXG4gICAgZm9yKHZhciBpID0gMDsgaSA+IGNvZGVQb2ludEluZGV4OyBpLS0pIFxyXG4gICAgICBjb2RlVW5pdEluZGV4ID0gc3RyLmttd1ByZXZDaGFyKGNvZGVVbml0SW5kZXgpO1x0XHJcbiAgICByZXR1cm4gY29kZVVuaXRJbmRleDtcclxuICB9XHJcbiAgXHJcbiAgaWYoY29kZVBvaW50SW5kZXggPT0gc3RyLmttd0xlbmd0aCgpKSByZXR1cm4gc3RyLmxlbmd0aDtcclxuICBcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50SW5kZXg7IGkrKylcclxuICAgIGNvZGVVbml0SW5kZXggPSBzdHIua213TmV4dENoYXIoY29kZVVuaXRJbmRleCk7XHJcbiAgcmV0dXJuIGNvZGVVbml0SW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGNvZGUgcG9pbnQgaW5kZXggdG8gdGhlIGNvZGUgdW5pdCBpbmRleCBwYXNzZWRcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfG51bGx9ICBjb2RlVW5pdEluZGV4ICBBIGNvZGUgdW5pdCBpbmRleCBpbiB0aGUgc3RyaW5nXHJcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfSAgICAgICAgICAgICAgICAgVGhlIGNvcnJlc3BvbmRpbmcgY29kZSBwb2ludCBpbmRleFxyXG4gKi9cclxuU3RyaW5nLnByb3RvdHlwZS5rbXdDb2RlVW5pdFRvQ29kZVBvaW50ID0gZnVuY3Rpb24oY29kZVVuaXRJbmRleCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgXHJcbiAgaWYoY29kZVVuaXRJbmRleCA9PT0gbnVsbClcclxuICAgIHJldHVybiBudWxsO1xyXG4gIGVsc2UgaWYoY29kZVVuaXRJbmRleCA9PSAwKVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgZWxzZSBpZihjb2RlVW5pdEluZGV4IDwgMCkgICAgIFxyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoY29kZVVuaXRJbmRleCkua213TGVuZ3RoKCk7XHJcbiAgZWxzZVxyXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCxjb2RlVW5pdEluZGV4KS5rbXdMZW5ndGgoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNoYXJhY3RlciBhdCBhIHRoZSBjb2RlIHBvaW50IGluZGV4IHBhc3NlZFxyXG4gKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjb2RlUG9pbnRJbmRleCAgQSBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmdcclxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi9cclxuU3RyaW5nLnByb3RvdHlwZS5rbXdDaGFyQXQgPSBmdW5jdGlvbihjb2RlUG9pbnRJbmRleCkge1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcbiAgXHJcbiAgaWYoY29kZVBvaW50SW5kZXggPj0gMCkgcmV0dXJuIHN0ci5rbXdTdWJzdHIoY29kZVBvaW50SW5kZXgsMSk7IGVsc2UgcmV0dXJuICcnO1xyXG59XHJcblxyXG4vKipcclxuICogU3RyaW5nIHByb3RvdHlwZSBsaWJyYXJ5IGV4dGVuc2lvbnMgZm9yIGJhc2ljIHBsYW5lIGNoYXJhY3RlcnMsIFxyXG4gKiB0byBzaW1wbGlmeSBlbmFibGluZyBvciBkaXNhYmxpbmcgc3VwcGxlbWVudGFyeSBwbGFuZSBmdW5jdGlvbmFsaXR5IChJMzMxOSlcclxuICovXHJcbiBcclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvZGUgdW5pdCBpbmRleCBmb3IgdGhlIG5leHQgY29kZSBwb2ludCBpbiB0aGUgc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIGNvZGVVbml0SW5kZXggICAgQSBjb2RlIHBvaW50IGluZGV4IGluIHRoZSBzdHJpbmdcclxuICogQHJldHVybiB7bnVtYmVyfG51bGx9ICAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi8gXHJcblN0cmluZy5wcm90b3R5cGUua213Qk1QTmV4dENoYXIgPSBmdW5jdGlvbihjb2RlVW5pdEluZGV4KVxyXG57XHJcbiAgdmFyIHN0ciA9IFN0cmluZyh0aGlzKTtcclxuICBpZihjb2RlVW5pdEluZGV4IDwgMCB8fCBjb2RlVW5pdEluZGV4ID49IHN0ci5sZW5ndGggLSAxKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGNvZGVVbml0SW5kZXggKyAxO1xyXG59ICBcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgaW5kZXggZm9yIHRoZSBwcmV2aW91cyBjb2RlIHBvaW50IGluIHRoZSBzdHJpbmdcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVVuaXRJbmRleCAgICBBIGNvZGUgdW5pdCBpbmRleCBpbiB0aGUgc3RyaW5nXHJcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfSAgICAgICAgICAgICAgICAgICBUaGUgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJcclxuICovIFxyXG5TdHJpbmcucHJvdG90eXBlLmttd0JNUFByZXZDaGFyID0gZnVuY3Rpb24oY29kZVVuaXRJbmRleClcclxue1xyXG4gIHZhciBzdHIgPSBTdHJpbmcodGhpcyk7XHJcblxyXG4gIGlmKGNvZGVVbml0SW5kZXggPD0gMCB8fCBjb2RlVW5pdEluZGV4ID4gc3RyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBjb2RlVW5pdEluZGV4IC0gMTtcclxufSAgXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29kZSB1bml0IGluZGV4IGZvciBhIGNvZGUgcG9pbnQgaW5kZXhcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVBvaW50SW5kZXggICBBIGNvZGUgcG9pbnQgaW5kZXggaW4gdGhlIHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi8gXHJcblN0cmluZy5wcm90b3R5cGUua213Qk1QQ29kZVBvaW50VG9Db2RlVW5pdCA9IGZ1bmN0aW9uKGNvZGVQb2ludEluZGV4KVxyXG57XHJcbiAgcmV0dXJuIGNvZGVQb2ludEluZGV4O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29kZSBwb2ludCBpbmRleCBmb3IgYSBjb2RlIHVuaXQgaW5kZXhcclxuICpcclxuICogQHBhcmFtICB7bnVtYmVyfSAgY29kZVVuaXRJbmRleCAgICBBIGNvZGUgcG9pbnQgaW5kZXggaW4gdGhlIHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIFRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlclxyXG4gKi8gXHJcblN0cmluZy5wcm90b3R5cGUua213Qk1QQ29kZVVuaXRUb0NvZGVQb2ludCA9IGZ1bmN0aW9uKGNvZGVVbml0SW5kZXgpXHJcbntcclxuICByZXR1cm4gY29kZVVuaXRJbmRleDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIEJNUCBzdHJpbmdcclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICBUaGUgbGVuZ3RoIGluIGNvZGUgcG9pbnRzXHJcbiAqLyBcclxuU3RyaW5nLnByb3RvdHlwZS5rbXdCTVBMZW5ndGggPSBmdW5jdGlvbigpXHJcbntcclxuICB2YXIgc3RyID0gU3RyaW5nKHRoaXMpO1xyXG4gIHJldHVybiBzdHIubGVuZ3RoO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdWJzdHJpbmcgXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gIG5cclxuICogQHBhcmFtICB7bnVtYmVyPX0gIGxuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgXHJcbiAqLyBcclxuU3RyaW5nLnByb3RvdHlwZS5rbXdCTVBTdWJzdHIgPSBmdW5jdGlvbihuLGxuPylcclxue1xyXG4gIHZhciBzdHI9U3RyaW5nKHRoaXMpO1xyXG4gIGlmKG4gPiAtMSkgXHJcbiAgICByZXR1cm4gc3RyLnN1YnN0cihuLGxuKTtcclxuICBlbHNlXHJcbiAgICByZXR1cm4gc3RyLnN1YnN0cihzdHIubGVuZ3RoK24sLW4pOyAgXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBzdXBwbGVtZW50YXJ5IHBsYW5lIHN0cmluZyBoYW5kbGluZ1xyXG4gKlxyXG4gKiBAcGFyYW0gIHtib29sZWFufSAgYkVuYWJsZVxyXG4gKi8gXHJcblN0cmluZy5rbXdFbmFibGVTdXBwbGVtZW50YXJ5UGxhbmUgPSBmdW5jdGlvbihiRW5hYmxlKVxyXG57XHJcbiAgdmFyIHA9U3RyaW5nLnByb3RvdHlwZTtcclxuICBTdHJpbmcuX2ttd0Zyb21DaGFyQ29kZSA9IGJFbmFibGUgPyBTdHJpbmcua213RnJvbUNoYXJDb2RlIDogU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuICBwLl9rbXdDaGFyQXQgPSBiRW5hYmxlID8gcC5rbXdDaGFyQXQgOiBwLmNoYXJBdDtcclxuICBwLl9rbXdDaGFyQ29kZUF0ID0gYkVuYWJsZSA/IHAua213Q2hhckNvZGVBdCA6IHAuY2hhckNvZGVBdDtcclxuICBwLl9rbXdJbmRleE9mID0gYkVuYWJsZSA/IHAua213SW5kZXhPZiA6cC5pbmRleE9mO1xyXG4gIHAuX2ttd0xhc3RJbmRleE9mID0gYkVuYWJsZSA/IHAua213TGFzdEluZGV4T2YgOiBwLmxhc3RJbmRleE9mIDtcclxuICBwLl9rbXdTbGljZSA9IGJFbmFibGUgPyBwLmttd1NsaWNlIDogcC5zbGljZTtcclxuICBwLl9rbXdTdWJzdHJpbmcgPSBiRW5hYmxlID8gcC5rbXdTdWJzdHJpbmcgOiBwLnN1YnN0cmluZztcclxuICBwLl9rbXdTdWJzdHIgPSBiRW5hYmxlID8gcC5rbXdTdWJzdHIgOiBwLmttd0JNUFN1YnN0cjtcclxuICBwLl9rbXdMZW5ndGggPSBiRW5hYmxlID8gcC5rbXdMZW5ndGggOiBwLmttd0JNUExlbmd0aDtcclxuICBwLl9rbXdOZXh0Q2hhciA9IGJFbmFibGUgPyBwLmttd05leHRDaGFyIDogcC5rbXdCTVBOZXh0Q2hhcjtcclxuICBwLl9rbXdQcmV2Q2hhciA9IGJFbmFibGUgPyBwLmttd1ByZXZDaGFyIDogcC5rbXdCTVBQcmV2Q2hhcjtcclxuICBwLl9rbXdDb2RlUG9pbnRUb0NvZGVVbml0ID0gYkVuYWJsZSA/IHAua213Q29kZVBvaW50VG9Db2RlVW5pdCA6IHAua213Qk1QQ29kZVBvaW50VG9Db2RlVW5pdDtcclxuICBwLl9rbXdDb2RlVW5pdFRvQ29kZVBvaW50ID0gYkVuYWJsZSA/IHAua213Q29kZVVuaXRUb0NvZGVQb2ludCA6IHAua213Qk1QQ29kZVVuaXRUb0NvZGVQb2ludDtcclxufVxyXG5cclxuIiwibmFtZXNwYWNlIGNvbS5rZXltYW4udXRpbHMge1xyXG4gIGV4cG9ydCBlbnVtIEJyb3dzZXIge1xyXG4gICAgQ2hyb21lID0gJ2Nocm9tZScsXHJcbiAgICBFZGdlID0gJ2VkZ2UnLFxyXG4gICAgRmlyZWZveCA9ICdmaXJlZm94JyxcclxuICAgIE5hdGl2ZSA9ICduYXRpdmUnLCAvLyBVc2VkIGJ5IGVtYmVkZGVkIG1vZGVcclxuICAgIE9wZXJhID0gJ29wZXJhJyxcclxuICAgIFNhZmFyaSA9ICdzYWZhcmknLFxyXG4gICAgT3RoZXIgPSAnb3RoZXInXHJcbiAgfVxyXG5cclxuICBleHBvcnQgZW51bSBPcGVyYXRpbmdTeXN0ZW0ge1xyXG4gICAgV2luZG93cyA9ICd3aW5kb3dzJyxcclxuICAgIG1hY09TID0gJ21hY29zeCcsXHJcbiAgICBMaW51eCA9ICdsaW51eCcsXHJcbiAgICBBbmRyb2lkID0gJ2FuZHJvaWQnLFxyXG4gICAgaU9TID0gJ2lvcycsXHJcbiAgICBPdGhlciA9ICdvdGhlcidcclxuICB9XHJcblxyXG4gIGV4cG9ydCBlbnVtIEZvcm1GYWN0b3Ige1xyXG4gICAgRGVza3RvcCA9ICdkZXNrdG9wJyxcclxuICAgIFBob25lID0gJ3Bob25lJyxcclxuICAgIFRhYmxldCA9ICd0YWJsZXQnXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGFuIGFic3RyYWN0IHZlcnNpb24gb2YgY29tLmtleW1hbi5EZXZpY2UgdGhhdCBpcyBjb3JlLWZyaWVuZGx5LCBcclxuICAgKiBjb250YWluaW5nIG9ubHkgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBieSB3ZWItY29yZSBmb3IgdGV4dCBwcm9jZXNzaW5nIHVzZSwgZGV2b2lkXHJcbiAgICogb2YgYW55IGRpcmVjdCByZWZlcmVuY2VzIHRvIHRoZSBET00uXHJcbiAgICovXHJcbiAgZXhwb3J0IGNsYXNzIERldmljZVNwZWMge1xyXG4gICAgcmVhZG9ubHkgYnJvd3NlcjogQnJvd3NlcjtcclxuICAgIHJlYWRvbmx5IGZvcm1GYWN0b3I6IEZvcm1GYWN0b3I7XHJcbiAgICByZWFkb25seSBPUzogT3BlcmF0aW5nU3lzdGVtO1xyXG4gICAgcmVhZG9ubHkgdG91Y2hhYmxlOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJyb3dzZXI6IHN0cmluZywgZm9ybUZhY3Rvcjogc3RyaW5nLCBPUzogc3RyaW5nLCB0b3VjaGFibGU6IGJvb2xlYW4pIHtcclxuICAgICAgc3dpdGNoKGJyb3dzZXIudG9Mb3dlckNhc2UoKSBhcyBCcm93c2VyKSB7XHJcbiAgICAgICAgY2FzZSBCcm93c2VyLkNocm9tZTpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuRWRnZTpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuRmlyZWZveDpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuTmF0aXZlOlxyXG4gICAgICAgIGNhc2UgQnJvd3Nlci5PcGVyYTpcclxuICAgICAgICBjYXNlIEJyb3dzZXIuU2FmYXJpOlxyXG4gICAgICAgICAgdGhpcy5icm93c2VyID0gYnJvd3Nlci50b0xvd2VyQ2FzZSgpIGFzIEJyb3dzZXI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhpcy5icm93c2VyID0gQnJvd3Nlci5PdGhlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3dpdGNoKGZvcm1GYWN0b3IudG9Mb3dlckNhc2UoKSBhcyBGb3JtRmFjdG9yKSB7XHJcbiAgICAgICAgY2FzZSBGb3JtRmFjdG9yLkRlc2t0b3A6XHJcbiAgICAgICAgY2FzZSBGb3JtRmFjdG9yLlBob25lOlxyXG4gICAgICAgIGNhc2UgRm9ybUZhY3Rvci5UYWJsZXQ6XHJcbiAgICAgICAgICB0aGlzLmZvcm1GYWN0b3IgPSBmb3JtRmFjdG9yLnRvTG93ZXJDYXNlKCkgYXMgRm9ybUZhY3RvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyAoXCJJbnZhbGlkIGZvcm0gZmFjdG9yIHNwZWNpZmllZCBmb3IgZGV2aWNlOiBcIiArIGZvcm1GYWN0b3IpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzd2l0Y2goT1MudG9Mb3dlckNhc2UoKSBhcyBPcGVyYXRpbmdTeXN0ZW0pIHtcclxuICAgICAgICBjYXNlIE9wZXJhdGluZ1N5c3RlbS5XaW5kb3dzLnRvTG93ZXJDYXNlKCk6XHJcbiAgICAgICAgY2FzZSBPcGVyYXRpbmdTeXN0ZW0ubWFjT1MudG9Mb3dlckNhc2UoKTpcclxuICAgICAgICBjYXNlIE9wZXJhdGluZ1N5c3RlbS5MaW51eC50b0xvd2VyQ2FzZSgpOlxyXG4gICAgICAgIGNhc2UgT3BlcmF0aW5nU3lzdGVtLkFuZHJvaWQudG9Mb3dlckNhc2UoKTpcclxuICAgICAgICBjYXNlIE9wZXJhdGluZ1N5c3RlbS5pT1MudG9Mb3dlckNhc2UoKTpcclxuICAgICAgICAgIHRoaXMuT1MgPSBPUy50b0xvd2VyQ2FzZSgpIGFzIE9wZXJhdGluZ1N5c3RlbTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aGlzLk9TID0gT3BlcmF0aW5nU3lzdGVtLk90aGVyO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnRvdWNoYWJsZSA9IHRvdWNoYWJsZTtcclxuICAgIH1cclxuICB9XHJcbn0iLCIvLyBSZWZlcmVuY2VzIGFsbCB1dGlsaXR5IGluY2x1ZGVzIGZyb20gYSBzaW5nbGUgZmlsZSwgbWFraW5nIGltcG9ydC9leHBvcnQgc2ltcGxlLlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJkZWVwQ29weS50c1wiIC8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cImdsb2JhbE9iamVjdC50c1wiIC8+XHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cInZlcnNpb24udHNcIiAvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJrbXdzdHJpbmcudHNcIiAvPlxyXG4vLy88cmVmZXJlbmNlIHBhdGg9XCJkZXZpY2VTcGVjLnRzXCIgLz4iLCJuYW1lc3BhY2UgY29tLmtleW1hbi50ZXh0IHtcclxuICAvLyBEZWZpbmVzIHRoZSBiYXNlIERlYWRrZXktdHJhY2tpbmcgb2JqZWN0LlxyXG4gIFxyXG4gIGV4cG9ydCBjbGFzcyBEZWFka2V5IHtcclxuICAgIHA6IG51bWJlcjsgIC8vIFBvc2l0aW9uIG9mIGRlYWRrZXlcclxuICAgIGQ6IG51bWJlcjsgIC8vIE51bWVyaWNhbCBpZCBvZiB0aGUgZGVhZGtleVxyXG4gICAgbzogbnVtYmVyOyAgLy8gT3JkaW5hbCB2YWx1ZSBvZiB0aGUgZGVhZGtleSAocmVzb2x2ZXMgc2FtZS1wbGFjZSBjb25mbGljdHMpXHJcbiAgICBtYXRjaGVkOiBudW1iZXI7XHJcblxyXG4gICAgc3RhdGljIG9yZGluYWxTZWVkOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBvczogbnVtYmVyLCBpZDogbnVtYmVyKSB7XHJcbiAgICAgIHRoaXMucCA9IHBvcztcclxuICAgICAgdGhpcy5kID0gaWQ7XHJcbiAgICAgIHRoaXMubyA9IERlYWRrZXkub3JkaW5hbFNlZWQrKztcclxuICAgIH1cclxuXHJcbiAgICBtYXRjaChwOiBudW1iZXIsIGQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICB2YXIgcmVzdWx0OmJvb2xlYW4gPSAodGhpcy5wID09IHAgJiYgdGhpcy5kID09IGQpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubWF0Y2hlZCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgIHRoaXMubWF0Y2hlZCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgYmVmb3JlKG90aGVyOiBEZWFka2V5KTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0aGlzLm8gPCBvdGhlci5vO1xyXG4gICAgfVxyXG5cclxuICAgIGNsb25lKCk6IERlYWRrZXkge1xyXG4gICAgICBsZXQgZGsgPSBuZXcgRGVhZGtleSh0aGlzLnAsIHRoaXMuZCk7XHJcbiAgICAgIGRrLm8gPSB0aGlzLm87XHJcblxyXG4gICAgICByZXR1cm4gZGs7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0cyB0aGUgZGVhZGtleXMgaW4gcmV2ZXJzZSBvcmRlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNvcnRGdW5jID0gZnVuY3Rpb24oYTogRGVhZGtleSwgYjogRGVhZGtleSkge1xyXG4gICAgICAvLyBXZSB3YW50IGRlc2NlbmRpbmcgb3JkZXIsIHNvIHdlIHdhbnQgJ2xhdGVyJyBkZWFka2V5cyBmaXJzdC5cclxuICAgICAgaWYoYS5wICE9IGIucCkge1xyXG4gICAgICAgIHJldHVybiBiLnAgLSBhLnA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGIubyAtIGEubztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE9iamVjdC1vcmllbnRzIGRlYWRrZXkgbWFuYWdlbWVudC5cclxuICBleHBvcnQgY2xhc3MgRGVhZGtleVRyYWNrZXIge1xyXG4gICAgZGtzOiBEZWFka2V5W10gPSBbXTtcclxuXHJcbiAgICB0b1NvcnRlZEFycmF5KCk6IERlYWRrZXlbXSB7XHJcbiAgICAgIHRoaXMuZGtzID0gdGhpcy5ka3Muc29ydChEZWFka2V5LnNvcnRGdW5jKTtcclxuICAgICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLmRrcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKTogRGVhZGtleVRyYWNrZXIge1xyXG4gICAgICBsZXQgZGt0ID0gbmV3IERlYWRrZXlUcmFja2VyKCk7XHJcbiAgICAgIGxldCBka3MgPSB0aGlzLnRvU29ydGVkQXJyYXkoKTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byBjbG9uZSB0aGUgZGVhZGtleXMgdGhlbXNlbHZlcyAtIHRoZSBEZWFka2V5IG9iamVjdCBpcyBtdXRhYmxlLlxyXG4gICAgICBka3QuZGtzID0gW107XHJcbiAgICAgIGRrcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlOiBEZWFka2V5KSB7XHJcbiAgICAgICAgZGt0LmRrcy5wdXNoKHZhbHVlLmNsb25lKCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBka3Q7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBpc01hdGNoICAgICAgXHJcbiAgICAgKiBTY29wZSAgICAgICAgUHVibGljXHJcbiAgICAgKiBAcGFyYW0gICAgICAge251bWJlcn0gICAgICBjYXJldFBvcyAgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIG4gICAgICAgICBleHBlY3RlZCBvZmZzZXQgb2YgZGVhZGtleSBmcm9tIGN1cnNvclxyXG4gICAgICogQHBhcmFtICAgICAgIHtudW1iZXJ9ICAgICAgZCAgICAgICAgIGRlYWRrZXlcclxuICAgICAqIEByZXR1cm4gICAgICB7Ym9vbGVhbn0gICAgICAgICAgICAgICBUcnVlIGlmIGRlYWRrZXkgZm91bmQgc2VsZWN0ZWQgY29udGV4dCBtYXRjaGVzIHZhbFxyXG4gICAgICogRGVzY3JpcHRpb24gIE1hdGNoIGRlYWRrZXkgYXQgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgaXNNYXRjaChjYXJldFBvczogbnVtYmVyLCBuOiBudW1iZXIsIGQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICBpZih0aGlzLmRrcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSTMzMThcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNwPWNhcmV0UG9zO1xyXG4gICAgICBuID0gc3AgLSBuO1xyXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5ka3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBEb24ndCByZS1tYXRjaCBhbiBhbHJlYWR5LW1hdGNoZWQgZGVhZGtleS4gIEl0J3MgcG9zc2libGUgdG8gaGF2ZSB0d28gaWRlbnRpY2FsIFxyXG4gICAgICAgIC8vIGVudHJpZXMsIGFuZCB0aGV5IHNob3VsZCBiZSBrZXB0IHNlcGFyYXRlbHkuXHJcbiAgICAgICAgaWYodGhpcy5ka3NbaV0ubWF0Y2gobiwgZCkgJiYgIXRoaXMuZGtzW2ldLm1hdGNoZWQpIHtcclxuICAgICAgICAgIHRoaXMuZGtzW2ldLnNldCgpO1xyXG4gICAgICAgICAgLy8gQXNzdW1wdGlvbjogIHNpbmNlIHdlIG1hdGNoIHRoZSBmaXJzdCBwb3NzaWJsZSBlbnRyeSBpbiB0aGUgYXJyYXksIHdlXHJcbiAgICAgICAgICAvLyBtYXRjaCB0aGUgZW50cnkgd2l0aCB0aGUgbG93ZXIgb3JkaW5hbCAtIHRoZSAnZmlyc3QnIGRlYWRrZXkgaW4gdGhlIHBvc2l0aW9uLlxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEkzMzE4XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlc2V0TWF0Y2hlZCgpOyAvLyBJMzMxOFxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZChkazogRGVhZGtleSkge1xyXG4gICAgICB0aGlzLmRrcyA9IHRoaXMuZGtzLmNvbmNhdChkayk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKGRrOiBEZWFka2V5KSB7XHJcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZGtzLmluZGV4T2YoZGspO1xyXG4gICAgICB0aGlzLmRrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICB0aGlzLmRrcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0TWF0Y2hlZCgpIHtcclxuICAgICAgZm9yKGxldCBkayBvZiB0aGlzLmRrcykge1xyXG4gICAgICAgIGRrLnJlc2V0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZGVsZXRlTWF0Y2hlZCgpOiB2b2lkIHtcclxuICAgICAgZm9yKHZhciBMaSA9IDA7IExpIDwgdGhpcy5ka3MubGVuZ3RoOyBMaSsrKSB7XHJcbiAgICAgICAgaWYodGhpcy5ka3NbTGldLm1hdGNoZWQpIHtcclxuICAgICAgICAgIHRoaXMuZGtzLnNwbGljZShMaS0tLCAxKTsgLy8gRG9uJ3QgZm9yZ2V0IHRvIGRlY3JlbWVudCFcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uICAgICBhZGp1c3RQb3NpdGlvbnMgKGZvcm1lcmx5IF9EZWFka2V5QWRqdXN0UG9zKVxyXG4gICAgICogU2NvcGUgICAgICAgIFByaXZhdGVcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIExzdGFydCAgICAgIHN0YXJ0IHBvc2l0aW9uIGluIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSAgICAgICB7bnVtYmVyfSAgICAgIExkZWx0YSAgICAgIGNoYXJhY3RlcnMgdG8gYWRqdXN0IGJ5ICAgXHJcbiAgICAgKiBEZXNjcmlwdGlvbiAgQWRqdXN0IHNhdmVkIHBvc2l0aW9ucyBvZiBkZWFka2V5cyBpbiBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGFkanVzdFBvc2l0aW9ucyhMc3RhcnQ6IG51bWJlciwgTGRlbHRhOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgaWYoTGRlbHRhID09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGZvcihsZXQgZGsgb2YgdGhpcy5ka3MpIHtcclxuICAgICAgICBpZihkay5wID4gTHN0YXJ0KSB7XHJcbiAgICAgICAgICBkay5wICs9IExkZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb3VudCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5ka3MubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxufSIsIi8vIERlZmluZXMgZGVhZGtleSBtYW5hZ2VtZW50IGluIGEgbWFubmVyIGF0dGFjaGFibGUgdG8gZWFjaCBlbGVtZW50IGludGVyZmFjZS5cclxuLy8vPHJlZmVyZW5jZSBwYXRoPVwiLi4vdGV4dC9kZWFka2V5cy50c1wiIC8+XHJcbi8vIERlZmluZXMgdGhlIEtleUV2ZW50IHR5cGUuXHJcbi8vLzxyZWZlcmVuY2UgcGF0aD1cImtleUV2ZW50LnRzXCIgLz5cclxuXHJcbi8vIEFsc28gcmVsaWVzIG9uIHN0cmluZy1leHRlbnNpb25zIHByb3ZpZGVkIGJ5IHRoZSB3ZWItdXRpbHMgcGFja2FnZS5cclxuXHJcbm5hbWVzcGFjZSBjb20ua2V5bWFuLnRleHQge1xyXG4gIGV4cG9ydCBjbGFzcyBUZXh0VHJhbnNmb3JtIGltcGxlbWVudHMgVHJhbnNmb3JtIHtcclxuICAgIHJlYWRvbmx5IGluc2VydDogc3RyaW5nO1xyXG4gICAgcmVhZG9ubHkgZGVsZXRlTGVmdDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgZGVsZXRlUmlnaHQ/OiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW5zZXJ0OiBzdHJpbmcsIGRlbGV0ZUxlZnQ6IG51bWJlciwgZGVsZXRlUmlnaHQ/OiBudW1iZXIpIHtcclxuICAgICAgdGhpcy5pbnNlcnQgPSBpbnNlcnQ7XHJcbiAgICAgIHRoaXMuZGVsZXRlTGVmdCA9IGRlbGV0ZUxlZnQ7XHJcbiAgICAgIHRoaXMuZGVsZXRlUmlnaHQgPSBkZWxldGVSaWdodCB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgbmlsID0gbmV3IFRleHRUcmFuc2Zvcm0oJycsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFRyYW5zY3JpcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgdG9rZW46IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IGtleXN0cm9rZTogS2V5RXZlbnQ7XHJcbiAgICByZWFkb25seSB0cmFuc2Zvcm06IFRyYW5zZm9ybTtcclxuICAgIGFsdGVybmF0ZXM6IEFsdGVybmF0ZVtdOyAvLyBjb25zdHJ1Y3RlZCBhZnRlciB0aGUgcmVzdCBvZiB0aGUgdHJhbnNjcmlwdGlvbi5cclxuICAgIHJlYWRvbmx5IHByZUlucHV0OiBNb2NrO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHRva2VuU2VlZDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihrZXlzdHJva2U6IEtleUV2ZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcHJlSW5wdXQ6IE1vY2ssIGFsdGVybmF0ZXM/OiBBbHRlcm5hdGVbXS8qLCByZW1vdmVkRGtzOiBEZWFka2V5W10sIGluc2VydGVkRGtzOiBEZWFka2V5W10qLykge1xyXG4gICAgICBsZXQgdG9rZW4gPSB0aGlzLnRva2VuID0gVHJhbnNjcmlwdGlvbi50b2tlblNlZWQrKztcclxuXHJcbiAgICAgIHRoaXMua2V5c3Ryb2tlID0ga2V5c3Ryb2tlO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgdGhpcy5hbHRlcm5hdGVzID0gYWx0ZXJuYXRlcztcclxuICAgICAgdGhpcy5wcmVJbnB1dCA9IHByZUlucHV0O1xyXG5cclxuICAgICAgdGhpcy50cmFuc2Zvcm0uaWQgPSB0aGlzLnRva2VuO1xyXG5cclxuICAgICAgLy8gQXNzaWduIHRoZSBJRCB0byBlYWNoIGFsdGVybmF0ZSwgYXMgd2VsbC5cclxuICAgICAgaWYoYWx0ZXJuYXRlcykge1xyXG4gICAgICAgIGFsdGVybmF0ZXMuZm9yRWFjaChmdW5jdGlvbihhbHQpIHtcclxuICAgICAgICAgIGFsdC5zYW1wbGUuaWQgPSB0b2tlbjtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IHR5cGUgQWx0ZXJuYXRlID0gUHJvYmFiaWxpdHlNYXNzPFRyYW5zZm9ybT47XHJcblxyXG4gIGV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPdXRwdXRUYXJnZXQge1xyXG4gICAgcHJpdmF0ZSBfZGtzOiB0ZXh0LkRlYWRrZXlUcmFja2VyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICB0aGlzLl9ka3MgPSBuZXcgdGV4dC5EZWFka2V5VHJhY2tlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmlmaWVzIHRoYXQgdGhpcyBPdXRwdXRUYXJnZXQgaGFzIG5vIGRlZmF1bHQga2V5IHByb2Nlc3NpbmcgYmVoYXZpb3JzLiAgVGhpcyBzaG91bGQgYmUgZmFsc2VcclxuICAgICAqIGZvciBPdXRwdXRUYXJnZXRzIGJhY2tlZCBieSB3ZWIgZWxlbWVudHMgbGlrZSBIVE1MSW5wdXRFbGVtZW50IG9yIEhUTUxUZXh0QXJlYUVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc1N5bnRoZXRpYygpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXRDb250ZXh0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLmRlYWRrZXlzKCkuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWFka2V5cygpOiB0ZXh0LkRlYWRrZXlUcmFja2VyIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2RrcztcclxuICAgIH1cclxuXHJcbiAgICBoYXNEZWFka2V5TWF0Y2gobjogbnVtYmVyLCBkOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVhZGtleXMoKS5pc01hdGNoKHRoaXMuZ2V0RGVhZGtleUNhcmV0KCksIG4sIGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydERlYWRrZXlCZWZvcmVDYXJldChkOiBudW1iZXIpIHtcclxuICAgICAgdmFyIGRrOiBEZWFka2V5ID0gbmV3IERlYWRrZXkodGhpcy5nZXREZWFka2V5Q2FyZXQoKSwgZCk7XHJcbiAgICAgIHRoaXMuZGVhZGtleXMoKS5hZGQoZGspO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCBieSBlYWNoIG91dHB1dCB0YXJnZXQgaW1tZWRpYXRlbHkgYmVmb3JlIHRleHQgbXV0YXRpb24gb3BlcmF0aW9ucyBvY2N1ci5cclxuICAgICAqIFxyXG4gICAgICogTWFpbnRhaW5zIHNvbHV0aW9ucyB0byBvbGQgaXNzdWVzOiAgSTMzMTgsSTMzMTlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSAgVXNlIG5lZ2F0aXZlIHZhbHVlcyBpZiBjaGFyYWN0ZXJzIHdlcmUgZGVsZXRlZCwgcG9zaXRpdmUgaWYgY2hhcmFjdGVycyB3ZXJlIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWRqdXN0RGVhZGtleXMoZGVsdGE6IG51bWJlcikge1xyXG4gICAgICB0aGlzLmRlYWRrZXlzKCkuYWRqdXN0UG9zaXRpb25zKHRoaXMuZ2V0RGVhZGtleUNhcmV0KCksIGRlbHRhKTsgXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWVkZWQgdG8gcHJvcGVybHkgY2xvbmUgZGVhZGtleXMgZm9yIHVzZSB3aXRoIE1vY2sgZWxlbWVudCBpbnRlcmZhY2VzIHRvd2FyZCBwcmVkaWN0aXZlIHRleHQgcHVycG9zZXMuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIGRrcyAgIEFuIGV4aXN0aW5nIHNldCBvZiBkZWFka2V5cyB0byBkZWVwLWNvcHkgZm9yIHVzZSBieSB0aGlzIGVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc2V0RGVhZGtleXMoZGtzOiB0ZXh0LkRlYWRrZXlUcmFja2VyKSB7XHJcbiAgICAgIHRoaXMuX2RrcyA9IGRrcy5jbG9uZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgYmFzaWMgb3BlcmF0aW9ucyBuZWVkZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIGN1cnJlbnQgT3V0cHV0VGFyZ2V0J3MgdGV4dCBmcm9tIHRoZSBwcmlvciBzdGF0ZSBzcGVjaWZpZWRcclxuICAgICAqIGJ5IGFub3RoZXIgT3V0cHV0VGFyZ2V0IGJhc2VkIG9uIHRoZWlyIHRleHQgYW5kIGNhcmV0IHBvc2l0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBkZXNpZ25lZCBmb3IgdXNlIGFzIGEgXCJiZWZvcmUgYW5kIGFmdGVyXCIgY29tcGFyaXNvbiB0byBkZXRlcm1pbmUgdGhlIGVmZmVjdCBvZiBhIHNpbmdsZSBrZXlib2FyZCBydWxlIGF0IGEgdGltZS5cclxuICAgICAqIEFzIHN1Y2gsIGl0IGFzc3VtZXMgdGhhdCB0aGUgY2FyZXQgaXMgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55IGluc2VydGVkIHRleHQuXHJcbiAgICAgKiBAcGFyYW0gZnJvbSBBbiBvdXRwdXQgdGFyZ2V0IChwcmVmZXJhYmx5IGEgTW9jaykgcmVwcmVzZW50aW5nIHRoZSBwcmlvciBzdGF0ZSBvZiB0aGUgaW5wdXQvb3V0cHV0IHN5c3RlbS5cclxuICAgICAqL1xyXG4gICAgYnVpbGRUcmFuc2Zvcm1Gcm9tKG9yaWdpbmFsOiBPdXRwdXRUYXJnZXQpOiBUcmFuc2Zvcm0ge1xyXG4gICAgICBsZXQgdG8gPSB0aGlzLmdldFRleHQoKTtcclxuICAgICAgbGV0IGZyb20gPSBvcmlnaW5hbC5nZXRUZXh0KCk7XHJcblxyXG4gICAgICBsZXQgZnJvbUNhcmV0ID0gb3JpZ2luYWwuZ2V0RGVhZGtleUNhcmV0KCk7XHJcbiAgICAgIGxldCB0b0NhcmV0ID0gdGhpcy5nZXREZWFka2V5Q2FyZXQoKTtcclxuXHJcbiAgICAgIC8vIFN0ZXAgMTogIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGxlZnQtZGVsZXRpb25zLlxyXG4gICAgICBsZXQgbWF4U01QTGVmdE1hdGNoID0gZnJvbUNhcmV0IDwgdG9DYXJldCA/IGZyb21DYXJldCA6IHRvQ2FyZXQ7XHJcblxyXG4gICAgICAvLyBXZSBuZWVkIHRoZSBjb3JyZXNwb25kaW5nIG5vbi1TTVAgY2FyZXQgbG9jYXRpb24gaW4gb3JkZXIgdG8gYmluYXJ5LXNlYXJjaCBlZmZpY2llbnRseS5cclxuICAgICAgLy8gKEV4YW1pbmluZyBjb2RlIHVuaXRzIGlzIG11Y2ggbW9yZSBjb21wdXRhdGlvbmFsbHkgZWZmaWNpZW50LilcclxuICAgICAgbGV0IG1heExlZnRNYXRjaCA9IHRvLl9rbXdDb2RlUG9pbnRUb0NvZGVVbml0KG1heFNNUExlZnRNYXRjaCk7XHJcblxyXG4gICAgICAvLyAxLjE6ICB1c2UgYSBub24tU01QLWF3YXJlIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBkaXZlcmdlbmNlIHBvaW50LlxyXG4gICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICBsZXQgZW5kID0gbWF4TGVmdE1hdGNoOyAgLy8gdGhlIGluZGV4IEFGVEVSIHRoZSBsYXN0IHBvc3NpYmxlIG1hdGNoaW5nIGNoYXIuXHJcblxyXG4gICAgICAvLyBUaGlzIHNlYXJjaCBpcyBPKG1heExlZnRNYXRjaCkuICAxLzIgKyAxLzQgKyAxLzggKyAuLi4gY29udmVyZ2VzIHRvID0gMS5cclxuICAgICAgd2hpbGUoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigoZW5kK3N0YXJ0KzEpIC8gMik7IC8vIHJvdW5kIHVwIChjb21wYXJlIG1vcmUpXHJcbiAgICAgICAgbGV0IGZyb21MZWZ0ID0gZnJvbS5zdWJzdHIoc3RhcnQsIG1pZC1zdGFydCk7XHJcbiAgICAgICAgbGV0IHRvTGVmdCAgID0gdG8uc3Vic3RyKHN0YXJ0LCBtaWQtc3RhcnQpO1xyXG5cclxuICAgICAgICBpZihmcm9tTGVmdCA9PSB0b0xlZnQpIHtcclxuICAgICAgICAgIHN0YXJ0ID0gbWlkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXQgdGhlIGxvb3AncyBlbmQ6ICBgZW5kYCBub3cgaG9sZHMgdGhlIG5vbi1TTVAtYXdhcmUgZGl2ZXJnZW5jZSBwb2ludC5cclxuICAgICAgLy8gVGhlICdjYXJldCcgaXMgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hpbmcgY29kZSB1bml0LlxyXG5cclxuICAgICAgLy8gMS4yOiAgZGV0ZWN0IGEgcG9zc2libGUgc3Vycm9nYXRlLXBhaXIgc3BsaXQgc2NlbmFyaW8sIGNvcnJlY3RpbmcgZm9yIGl0XHJcbiAgICAgIC8vICAgICAgIChieSBtb3ZpbmcgdGhlIHNwbGl0IGJlZm9yZSB0aGUgaGlnaC1zdXJyb2dhdGUpIGlmIGRldGVjdGVkLlxyXG5cclxuICAgICAgLy8gSWYgdGhlIHNwbGl0IGxvY2F0aW9uIGlzIHByZWNpc2VseSBvbiBlaXRoZXIgZW5kIG9mIHRoZSBjb250ZXh0LCB3ZSBjYW4ndFxyXG4gICAgICAvLyBoYXZlIHNwbGl0IGEgc3Vycm9nYXRlIHBhaXIuXHJcbiAgICAgIGlmKGVuZCA+IDAgJiYgZW5kIDwgbWF4TGVmdE1hdGNoKSB7XHJcbiAgICAgICAgbGV0IHBvdGVudGlhbEhpZ2ggICAgPSBmcm9tLmNoYXJDb2RlQXQoZW5kLTEpO1xyXG4gICAgICAgIGxldCBwb3RlbnRpYWxGcm9tTG93ID0gZnJvbS5jaGFyQ29kZUF0KGVuZCk7XHJcbiAgICAgICAgbGV0IHBvdGVudGlhbFRvTG93ICAgPSB0by5jaGFyQ29kZUF0KGVuZCk7XHJcblxyXG4gICAgICAgIC8vIGlmIHBvdGVudGlhbEhpZ2ggaXMgYSBwb3NzaWJsZSBoaWdoIHN1cnJvZ2F0ZS4uLlxyXG4gICAgICAgIGlmKHBvdGVudGlhbEhpZ2ggPj0gMHhEODAwICYmIHBvdGVudGlhbEhpZ2ggPD0gMHhEQkZGKSB7XHJcbiAgICAgICAgICAvLyBhbmQgYXQgbGVhc3Qgb25lIHBvdGVudGlhbCAnbG93JyBpcyBhIHBvc3NpYmxlIGxvdyBzdXJyb2dhdGUuLi5cclxuICAgICAgICAgIGxldCBmbGFnID0gcG90ZW50aWFsRnJvbUxvdyA+PSAweERDMDAgJiYgcG90ZW50aWFsRnJvbUxvdyA8PSAweERGRkY7XHJcbiAgICAgICAgICBmbGFnID0gZmxhZyB8fCAocG90ZW50aWFsVG9Mb3cgPj0gMFhEQzAwICYmIHBvdGVudGlhbFRvTG93IDw9IDB4REZGRik7XHJcblxyXG4gICAgICAgICAgLy8gQ29ycmVjdCB0aGUgc3BsaXQgbG9jYXRpb24sIG1vdmluZyBpdCAnYmVmb3JlJyB0aGUgaGlnaCBzdXJyb2dhdGUuXHJcbiAgICAgICAgICBpZihmbGFnKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGVuZCAtIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAxLjM6ICB0YWtlIHN1YnN0cmluZyBmcm9tIHN0YXJ0IHRvIHRoZSBzcGxpdCBwb2ludDsgZGV0ZXJtaW5lIFNNUC1hd2FyZSBsZW5ndGguXHJcbiAgICAgIC8vICAgICAgIFRoaXMgeWllbGRzIHRoZSBTTVAtYXdhcmUgZGl2ZXJnZW5jZSBpbmRleCwgd2hpY2ggZ2l2ZXMgdGhlIG51bWJlciBvZiBsZWZ0LWRlbGV0ZXMuXHJcbiAgICAgIGxldCBuZXdDYXJldCA9IGZyb20uX2ttd0NvZGVVbml0VG9Db2RlUG9pbnQoZW5kKTtcclxuICAgICAgbGV0IGRlbGV0ZWRMZWZ0ID0gZnJvbUNhcmV0IC0gbmV3Q2FyZXQ7XHJcblxyXG4gICAgICAvLyBTdGVwIDI6ICBEZXRlcm1pbmUgdGhlIG90aGVyIHByb3BlcnRpZXMuXHJcbiAgICAgIC8vIFNpbmNlIHRoZSAnYWZ0ZXInIE91dHB1dFRhcmdldCdzIGNhcmV0IGluZGljYXRlcyB0aGUgZW5kIG9mIGFueSBpbnNlcnRlZCB0ZXh0LCB3ZVxyXG4gICAgICAvLyBjYW4gZWFzaWx5IGNhbGN1bGF0ZSB0aGUgcmVzdC5cclxuICAgICAgbGV0IGluc2VydGVkTGVuZ3RoID0gdG9DYXJldCAtIG5ld0NhcmV0O1xyXG4gICAgICBsZXQgZGVsdGEgPSB0by5fa213U3Vic3RyKG5ld0NhcmV0LCBpbnNlcnRlZExlbmd0aCk7XHJcblxyXG4gICAgICBsZXQgdW5kZWxldGVkUmlnaHQgPSB0by5fa213TGVuZ3RoKCkgLSB0b0NhcmV0O1xyXG4gICAgICBsZXQgb3JpZ2luYWxSaWdodCA9IGZyb20uX2ttd0xlbmd0aCgpIC0gZnJvbUNhcmV0O1xyXG4gICAgICBsZXQgZGVsZXRlZFJpZ2h0ID0gb3JpZ2luYWxSaWdodCAtIHVuZGVsZXRlZFJpZ2h0O1xyXG5cclxuICAgICAgLy8gTWF5IG9jY3VyIHdoZW4gcmV2ZXJ0aW5nIGEgc3VnZ2VzdGlvbiB0aGF0IGhhZCBiZWVuIGFwcGxpZWQgbWlkLXdvcmQuXHJcbiAgICAgIGlmKGRlbGV0ZWRSaWdodCA8IDApIHtcclxuICAgICAgICAvLyBSZXN0b3JlcyBkZWxldGVSaWdodCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGRlbHRhID0gZGVsdGEgKyB0by5fa213U3Vic3RyKHRvQ2FyZXQsIC1kZWxldGVkUmlnaHQpO1xyXG4gICAgICAgIGRlbGV0ZWRSaWdodCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgVGV4dFRyYW5zZm9ybShkZWx0YSwgZGVsZXRlZExlZnQsIGRlbGV0ZWRSaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRUcmFuc2NyaXB0aW9uRnJvbShvcmlnaW5hbDogT3V0cHV0VGFyZ2V0LCBrZXlFdmVudDogS2V5RXZlbnQsIGFsdGVybmF0ZXM/OiBBbHRlcm5hdGVbXSk6IFRyYW5zY3JpcHRpb24ge1xyXG4gICAgICBsZXQgdHJhbnNmb3JtID0gdGhpcy5idWlsZFRyYW5zZm9ybUZyb20ob3JpZ2luYWwpO1xyXG5cclxuICAgICAgLy8gSWYgd2UgZXZlciBkZWNpZGUgdG8gcmUtYWRkIGRlYWRrZXkgdHJhY2tpbmcsIHRoaXMgaXMgdGhlIHBsYWNlIGZvciBpdC5cclxuXHJcbiAgICAgIHJldHVybiBuZXcgVHJhbnNjcmlwdGlvbihrZXlFdmVudCwgdHJhbnNmb3JtLCBNb2NrLmZyb20ob3JpZ2luYWwpLCBhbHRlcm5hdGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmVzIHRoZSBgT3V0cHV0VGFyZ2V0YCB0byB0aGUgaW5kaWNhdGVkIHN0YXRlLiAgRGVzaWduZWQgZm9yIHVzZSB3aXRoIGBUcmFuc2NyaXB0aW9uLnByZUlucHV0YC5cclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbCBBbiBgT3V0cHV0VGFyZ2V0YCAodXN1YWxseSBhIGBNb2NrYCkuXHJcbiAgICAgKi9cclxuICAgIHJlc3RvcmVUbyhvcmlnaW5hbDogT3V0cHV0VGFyZ2V0KSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIHRoaXMuc2V0VGV4dEJlZm9yZUNhcmV0KG9yaWdpbmFsLmdldFRleHRCZWZvcmVDYXJldCgpKTtcclxuICAgICAgdGhpcy5zZXRUZXh0QWZ0ZXJDYXJldChvcmlnaW5hbC5nZXRUZXh0QWZ0ZXJDYXJldCgpKTtcclxuXHJcbiAgICAgIC8vIEFsc28sIHJlc3RvcmUgdGhlIGRlYWRrZXlzIVxyXG4gICAgICB0aGlzLl9ka3MgPSBvcmlnaW5hbC5fZGtzLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXBwbHkodHJhbnNmb3JtOiBUcmFuc2Zvcm0pIHtcclxuICAgICAgaWYodHJhbnNmb3JtLmRlbGV0ZVJpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5zZXRUZXh0QWZ0ZXJDYXJldCh0aGlzLmdldFRleHRBZnRlckNhcmV0KCkuX2ttd1N1YnN0cih0cmFuc2Zvcm0uZGVsZXRlUmlnaHQpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodHJhbnNmb3JtLmRlbGV0ZUxlZnQpIHtcclxuICAgICAgICB0aGlzLmRlbGV0ZUNoYXJzQmVmb3JlQ2FyZXQodHJhbnNmb3JtLmRlbGV0ZUxlZnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0cmFuc2Zvcm0uaW5zZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0QmVmb3JlQ2FyZXQodHJhbnNmb3JtLmluc2VydCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGFsbCBkZWFka2V5cyBhcmUgaW52YWxpZGF0ZWQgYWZ0ZXIgYXBwbHlpbmcgYSBUcmFuc2Zvcm0sIHNpbmNlXHJcbiAgICAgIC8vIHByZWRpY3Rpb24gaW1wbGllcyB3ZSdsbCBiZSBjb21wbGV0aW5nIGEgd29yZCwgcG9zdC1kZWFka2V5cy5cclxuICAgICAgdGhpcy5fZGtzLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gYHJlc3RvcmVUb2AgLSBhbGxvd3MgZGlyZWN0bHkgc2V0dGluZyB0aGUgJ2JlZm9yZScgY29udGV4dCB0byB0aGF0IG9mIGFub3RoZXJcclxuICAgICAqIGBPdXRwdXRUYXJnZXRgLlxyXG4gICAgICogQHBhcmFtIHMgXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzZXRUZXh0QmVmb3JlQ2FyZXQoczogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIC8vIFRoaXMgb25lJ3MgZWFzeSBlbm91Z2ggdG8gcHJvdmlkZSBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yLlxyXG4gICAgICB0aGlzLmRlbGV0ZUNoYXJzQmVmb3JlQ2FyZXQodGhpcy5nZXRUZXh0QmVmb3JlQ2FyZXQoKS5fa213TGVuZ3RoKCkpO1xyXG4gICAgICB0aGlzLmluc2VydFRleHRCZWZvcmVDYXJldChzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciB0byBgcmVzdG9yZVRvYCAtIGFsbG93cyBkaXJlY3RseSBzZXR0aW5nIHRoZSAnYWZ0ZXInIGNvbnRleHQgdG8gdGhhdCBvZiBhbm90aGVyXHJcbiAgICAgKiBgT3V0cHV0VGFyZ2V0YC5cclxuICAgICAqIEBwYXJhbSBzIFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2V0VGV4dEFmdGVyQ2FyZXQoczogc3RyaW5nKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbnkgc2VsZWN0ZWQgdGV4dCB3aXRoaW4gdGhlIHdyYXBwZXIncyBlbGVtZW50KHMpLlxyXG4gICAgICogU2lsZW50bHkgZG9lcyBub3RoaW5nIGlmIG5vIHN1Y2ggdGV4dCBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGNsZWFyU2VsZWN0aW9uKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYW55IGNhY2hlZCBzZWxlY3Rpb24tcmVsYXRlZCBzdGF0ZSB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGludmFsaWRhdGVTZWxlY3Rpb24oKTogdm9pZDtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIHVuZGVybHlpbmcgZWxlbWVudCBoYXMgaXRzIG93biBzZWxlY3Rpb24gKGlucHV0LCB0ZXh0YXJlYSlcclxuICAgICAqIG9yIGlzIHBhcnQgb2YgKG9yIHBvc3Nlc3NlcykgdGhlIERPTSdzIGFjdGl2ZSBzZWxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGhhc1NlbGVjdGlvbigpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpbmRleCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjYXJldCdzIHBvc2l0aW9uIGZvciB1c2Ugd2l0aCBkZWFka2V5cy5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0RGVhZGtleUNhcmV0KCk6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxhdGl2ZSB0byB0aGUgY2FyZXQsIGdldHMgdGhlIGN1cnJlbnQgY29udGV4dCB3aXRoaW4gdGhlIHdyYXBwZXIncyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXRUZXh0QmVmb3JlQ2FyZXQoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIGNhcmV0IChhbmQvb3IgYWN0aXZlIHNlbGVjdGlvbiksIGdldHMgdGhlIGVsZW1lbnQncyB0ZXh0IGFmdGVyIHRoZSBjYXJldCxcclxuICAgICAqIGV4Y2x1ZGluZyBhbnkgYWN0aXZlbHkgc2VsZWN0ZWQgdGV4dCB0aGF0IHdvdWxkIGJlIGltbWVkaWF0ZWx5IHJlcGxhY2VkIHVwb24gdGV4dCBlbnRyeS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0VGV4dEFmdGVyQ2FyZXQoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCdzIGZ1bGwgdGV4dCwgaW5jbHVkaW5nIGFueSB0ZXh0IHRoYXQgaXMgYWN0aXZlbHkgc2VsZWN0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRleHQoKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgY29udGV4dCBkZWxldGlvbnMgKGZyb20gdGhlIGxlZnQgb2YgdGhlIGNhcmV0KSBhcyBuZWVkZWQgYnkgdGhlIEtleW1hbldlYiBlbmdpbmUgYW5kXHJcbiAgICAgKiBjb3JyZWN0cyB0aGUgbG9jYXRpb24gb2YgYW55IGFmZmVjdGVkIGRlYWRrZXlzLlxyXG4gICAgICogXHJcbiAgICAgKiBEb2VzIG5vdCBkZWxldGUgZGVhZGtleXMgKGIvYyBLTVcgMSAmIDIgYmVoYXZpb3IgbWFpbnRlbmFuY2UpLlxyXG4gICAgICogQHBhcmFtIGRuIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBkZWxldGUuICBJZiBuZWdhdGl2ZSwgY29udGV4dCB3aWxsIGJlIGxlZnQgdW5jaGFuZ2VkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBkZWxldGVDaGFyc0JlZm9yZUNhcmV0KGRuOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyB0ZXh0IGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY2FyZXQncyBjdXJyZW50IHBvc2l0aW9uLCBtb3ZpbmcgdGhlIGNhcmV0IGFmdGVyIHRoZVxyXG4gICAgICogbmV3bHkgaW5zZXJ0ZWQgdGV4dCBpbiB0aGUgcHJvY2VzcyBhbG9uZyB3aXRoIGFueSBhZmZlY3RlZCBkZWFka2V5cy5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHMgVGV4dCB0byBpbnNlcnQgYmVmb3JlIHRoZSBjYXJldCdzIGN1cnJlbnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGluc2VydFRleHRCZWZvcmVDYXJldChzOiBzdHJpbmcpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIGVsZW1lbnQtc3BlY2lmaWMgaGFuZGxpbmcgZm9yIEVOVEVSIGtleSBpbnB1dHMuICBDb25jZXB0dWFsbHksIHRoaXMgc2hvdWxkIHVzdWFsbHlcclxuICAgICAqIGNvcnJlc3BvbmQgdG8gYGluc2VydFRleHRCZWZvcmVDYXJldCgnXFxuJyksIGJ1dCBhY3R1YWwgaW1wbGVtZW50YXRpb24gd2lsbCB2YXJ5IGdyZWF0bHkgYW1vbmdcclxuICAgICAqIGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBoYW5kbGVOZXdsaW5lQXRDYXJldCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZXMgZWxlbWVudC1zcGVjaWZpYyBzdGF0ZSBwcm9wZXJ0aWVzIHByb25lIHRvIG11dGF0aW9uLCBlbmFibGluZyByZXN0b3JhdGlvbiBhZnRlclxyXG4gICAgICogdGV4dC1vdXRwdXQgb3BlcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc2F2ZVByb3BlcnRpZXMoKSB7XHJcbiAgICAgIC8vIE1vc3QgZWxlbWVudCBpbnRlcmZhY2VzIHdvbid0IG5lZWQgYW55dGhpbmcgaGVyZS5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmVzIHByZXZpb3VzbHktc2F2ZWQgZWxlbWVudC1zcGVjaWZpYyBzdGF0ZSBwcm9wZXJ0aWVzLiAgRGVzaWduZWQgZm9yIHVzZSBhZnRlciB0ZXh0LW91dHB1dFxyXG4gICAgICogb3BzIHRvIGZhY2lsaXRhdGUgbW9yZS1zZWFtbGVzcyB3ZWItZGV2IGFuZCB1c2VyIGludGVyYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgcmVzdG9yZVByb3BlcnRpZXMoKXtcclxuICAgICAgLy8gTW9zdCBlbGVtZW50IGludGVyZmFjZXMgd29uJ3QgbmVlZCBhbnl0aGluZyBoZXJlLiBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIHN5bnRoZXRpYyBldmVudCBvbiB0aGUgdW5kZXJseWluZyBlbGVtZW50LCBzaWduYWxsaW5nIHRoYXQgaXRzIHZhbHVlIGhhcyBjaGFuZ2VkLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBkb0lucHV0RXZlbnQoKTogdm9pZDtcclxuICB9XHJcblxyXG4gIC8vIER1ZSB0byBzb21lIGludGVyZXN0aW5nIHJlcXVpcmVtZW50cyBvbiBjb21waWxlIG9yZGVyaW5nIGluIFRTLFxyXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgaW4gdGhlIHNhbWUgZmlsZSBhcyBPdXRwdXRUYXJnZXQgbm93LlxyXG4gIGV4cG9ydCBjbGFzcyBNb2NrIGV4dGVuZHMgT3V0cHV0VGFyZ2V0IHtcclxuICAgIHRleHQ6IHN0cmluZztcclxuICAgIGNhcmV0SW5kZXg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0Pzogc3RyaW5nLCBjYXJldFBvcz86IG51bWJlcikge1xyXG4gICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgdGhpcy50ZXh0ID0gdGV4dCA/IHRleHQgOiBcIlwiO1xyXG4gICAgICB2YXIgZGVmYXVsdExlbmd0aCA9IHRoaXMudGV4dC5fa213TGVuZ3RoKCk7XHJcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBgY2FyZXRQb3MgPT0gMGAgaXMgaGFuZGxlZCBjb3JyZWN0bHkuXHJcbiAgICAgIHRoaXMuY2FyZXRJbmRleCA9IHR5cGVvZiBjYXJldFBvcyA9PSBcIm51bWJlclwiID8gY2FyZXRQb3MgOiBkZWZhdWx0TGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsb25lcyB0aGUgc3RhdGUgb2YgYW4gZXhpc3RpbmcgRWRpdGFibGVFbGVtZW50LCBjcmVhdGluZyBhIE1vY2sgdmVyc2lvbiBvZiBpdHMgc3RhdGUuXHJcbiAgICBzdGF0aWMgZnJvbShvdXRwdXRUYXJnZXQ6IE91dHB1dFRhcmdldCkge1xyXG4gICAgICBsZXQgY2xvbmU6IE1vY2s7XHJcblxyXG4gICAgICBpZihvdXRwdXRUYXJnZXQgaW5zdGFuY2VvZiBNb2NrKSB7XHJcbiAgICAgICAgLy8gQXZvaWRzIHRoZSBuZWVkIHRvIHJ1biBleHBlbnNpdmUga213c3RyaW5nLnRzIC8gYF9rbXdMZW5ndGgoKWBcclxuICAgICAgICAvLyBjYWxjdWxhdGlvbnMgd2hlbiBkZWVwLWNvcHlpbmcgTW9jayBpbnN0YW5jZXMuXHJcbiAgICAgICAgbGV0IHByaW9yTW9jayA9IG91dHB1dFRhcmdldCBhcyBNb2NrO1xyXG4gICAgICAgIGNsb25lID0gbmV3IE1vY2socHJpb3JNb2NrLnRleHQsIHByaW9yTW9jay5jYXJldEluZGV4KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiB3ZSdyZSAnY2xvbmluZycgYSBkaWZmZXJlbnQgT3V0cHV0VGFyZ2V0IHR5cGUsIHdlIGRvbid0IGhhdmUgYVxyXG4gICAgICAgIC8vIGd1YXJhbnRlZWQgd2F5IHRvIG1vcmUgZWZmaWNpZW50bHkgZ2V0IHRoZXNlIHZhbHVlczsgdGhlc2UgYXJlIHRoZVxyXG4gICAgICAgIC8vIGJlc3QgbWV0aG9kcyBzcGVjaWZpZWQgYnkgdGhlIGFic3RyYWN0aW9uLlxyXG4gICAgICAgIGxldCBwcmVUZXh0ID0gb3V0cHV0VGFyZ2V0LmdldFRleHRCZWZvcmVDYXJldCgpO1xyXG4gICAgICAgIGxldCBjYXJldEluZGV4ID0gcHJlVGV4dC5fa213TGVuZ3RoKCk7XHJcblxyXG4gICAgICAgIC8vIFdlIGNob29zZSB0byBpZ25vcmUgKHJhdGhlciwgcHJlLWVtcHRpdmVseSByZW1vdmUpIGFueSBhY3RpdmVseS1zZWxlY3RlZCB0ZXh0LFxyXG4gICAgICAgIC8vIGFzIHNpbmNlIGl0J3MgYWx3YXlzIHJlbW92ZWQgaW5zdGFudGx5IGR1cmluZyBhbnkgdGV4dCBtdXRhdGlvbiBvcGVyYXRpb25zLlxyXG4gICAgICAgIGNsb25lID0gbmV3IE1vY2socHJlVGV4dCArIG91dHB1dFRhcmdldC5nZXRUZXh0QWZ0ZXJDYXJldCgpLCBjYXJldEluZGV4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxzbyBkdXBsaWNhdGUgZGVhZGtleSBzdGF0ZSEgIChOZWVkZWQgZm9yIGZhdC1maW5nZXIgb3BzLilcclxuICAgICAgY2xvbmUuc2V0RGVhZGtleXMob3V0cHV0VGFyZ2V0LmRlYWRrZXlzKCkpO1xyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjbGVhclNlbGVjdGlvbigpOiB2b2lkIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGludmFsaWRhdGVTZWxlY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBoYXNTZWxlY3Rpb24oKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERlYWRrZXlDYXJldCgpOiBudW1iZXIge1xyXG4gICAgICByZXR1cm4gdGhpcy5jYXJldEluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIHNldERlYWRrZXlDYXJldChpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgIGlmKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMudGV4dC5fa213TGVuZ3RoKCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlZCBjYXJldCBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY2FyZXRJbmRleCA9IGluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHRCZWZvcmVDYXJldCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZXh0Lmttd1N1YnN0cigwLCB0aGlzLmNhcmV0SW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRleHRBZnRlckNhcmV0KCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRleHQua213U3Vic3RyKHRoaXMuY2FyZXRJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGV4dCgpOiBzdHJpbmcge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZUNoYXJzQmVmb3JlQ2FyZXQoZG46IG51bWJlcik6IHZvaWQge1xyXG4gICAgICBpZihkbiA+PSAwKSB7XHJcbiAgICAgICAgaWYoZG4gPiB0aGlzLmNhcmV0SW5kZXgpIHtcclxuICAgICAgICAgIGRuID0gdGhpcy5jYXJldEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQua213U3Vic3RyKDAsIHRoaXMuY2FyZXRJbmRleCAtIGRuKSArIHRoaXMuZ2V0VGV4dEFmdGVyQ2FyZXQoKTtcclxuICAgICAgICB0aGlzLmNhcmV0SW5kZXggLT0gZG47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRUZXh0QmVmb3JlQ2FyZXQoczogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMuZ2V0VGV4dEJlZm9yZUNhcmV0KCkgKyBzICsgdGhpcy5nZXRUZXh0QWZ0ZXJDYXJldCgpO1xyXG4gICAgICB0aGlzLmNhcmV0SW5kZXggKz0gcy5rbXdMZW5ndGgoKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVOZXdsaW5lQXRDYXJldCgpOiB2b2lkIHtcclxuICAgICAgdGhpcy5pbnNlcnRUZXh0QmVmb3JlQ2FyZXQoJ1xcbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzZXRUZXh0QWZ0ZXJDYXJldChzOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5nZXRUZXh0QmVmb3JlQ2FyZXQoKSArIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZG9JbnB1dEV2ZW50KCkge1xyXG4gICAgICAvLyBNb2NrIGlzbid0IGJhY2tlZCBieSBhbiBlbGVtZW50LCBzbyBpdCB3b24ndCBoYXZlIGFueSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICB9XHJcbiAgfVxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIm91dHB1dFRhcmdldC50c1wiIC8+XHJcblxyXG5uYW1lc3BhY2UgY29tLmtleW1hbi50ZXh0IHtcclxuICAvLyBSZXByZXNlbnRzIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIG92ZXIgYSBrZXlib2FyZCdzIGtleXMuXHJcbiAgLy8gRGVmaW5lZCBoZXJlIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3Vlcy5cclxuICBleHBvcnQgdHlwZSBLZXlEaXN0cmlidXRpb24gPSB7a2V5SWQ6IHN0cmluZywgcDogbnVtYmVyfVtdO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGNsYXNzIGlzIGRlZmluZWQgd2l0aGluIGl0cyBvd24gZmlsZSBzbyB0aGF0IGl0IGNhbiBiZSBsb2FkZWQgYnkgY29kZSBvdXRzaWRlIG9mIEtNVyB3aXRob3V0XHJcbiAgICogaGF2aW5nIHRvIGFjdHVhbGx5IGxvYWQgdGhlIGVudGlyZXR5IG9mIEtNVy5cclxuICAgKi9cclxuICBleHBvcnQgY2xhc3MgS2V5RXZlbnQge1xyXG4gICAgTGNvZGU6IG51bWJlcjtcclxuICAgIExzdGF0ZXM6IG51bWJlcjtcclxuICAgIExtb2RpZmllckNoYW5nZT86IGJvb2xlYW47XHJcbiAgICBMbW9kaWZpZXJzOiBudW1iZXI7XHJcbiAgICBMaXNWaXJ0dWFsS2V5OiBib29sZWFuO1xyXG4gICAgdmtDb2RlOiBudW1iZXI7XHJcbiAgICBrTmFtZTogc3RyaW5nO1xyXG4gICAga0xheWVyPzogc3RyaW5nOyAgIC8vIFRoZSBrZXkncyBsYXllciBwcm9wZXJ0eVxyXG4gICAga2JkTGF5ZXI/OiBzdHJpbmc7IC8vIFRoZSB2aXJ0dWFsIGtleWJvYXJkJ3MgYWN0aXZlIGxheWVyXHJcbiAgICBrTmV4dExheWVyPzogc3RyaW5nO1xyXG4gICAgXHJcbiAgICAvLyBIb2xkcyByZWxldmFudCBldmVudCBwcm9wZXJ0aWVzIGxlYWRpbmcgdG8gY29uc3RydWN0aW9uIG9mIHRoaXMgS2V5RXZlbnQuXHJcbiAgICBzb3VyY2U/OiBhbnk7IC8vIFRlY2huaWNhbGx5LCBLZXlFdmVudHxNb3VzZUV2ZW50fFRvdWNoIC0gYnV0IHRob3NlIGFyZSBET00gdHlwZXMgdGhhdCBtdXN0IGJlIGtlcHQgb3V0IG9mIGhlYWRsZXNzIG1vZGUuXHJcbiAgICAvLyBIb2xkcyBhIGdlbmVyYXRlZCBmYXQtZmluZ2VyIGRpc3RyaWJ1dGlvbiAod2hlbiBhcHByb3ByaWF0ZSlcclxuICAgIGtleURpc3RyaWJ1dGlvbj86IEtleURpc3RyaWJ1dGlvbjtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGV2aWNlIG1vZGVsIGZvciB3ZWItY29yZSB0byBmb2xsb3cgd2hlbiBwcm9jZXNzaW5nIHRoZSBrZXlzdHJva2UuXHJcbiAgICAgKi9cclxuICAgIGRldmljZTogdXRpbHMuRGV2aWNlU3BlYztcclxuXHJcbiAgICAvKipcclxuICAgICAqIGB0cnVlYCBpZiB0aGlzIGV2ZW50IHdhcyBwcm9kdWNlZCBieSBzb3VyY2VzIG90aGVyIHRoYW4gYSBET00tYmFzZWQgS2V5Ym9hcmRFdmVudC5cclxuICAgICAqL1xyXG4gICAgaXNTeW50aGV0aWM6IGJvb2xlYW4gPSB0cnVlO1xyXG4gIH07XHJcbn0iLCJuYW1lc3BhY2UgS01XUmVjb3JkZXIge1xyXG4gIGV4cG9ydCB0eXBlIEFzc2VydENhbGxiYWNrID0gKHMxOiBhbnksIHMyOiBhbnksIG1zZz86IHN0cmluZykgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogRmFjaWxpdGF0ZXMgcnVubmluZyBSZWNvcmRlci1nZW5lcmF0ZWQgdGVzdHMgb24gdmFyaW91cyBwbGF0Zm9ybXMuXHJcbiAgICogXHJcbiAgICogTm90ZSB0aGF0IERPTS1hd2FyZSBLZXltYW5XZWIgd2lsbCBpbXBsZW1lbnQgYSBCcm93c2VyLWJhc2VkIHZlcnNpb24sIHdoaWxlXHJcbiAgICoga2V5Ym9hcmQtcHJvY2Vzc29yIGFuZCBpbnB1dC1wcm9jZXNzb3Igd2lsbCB1c2UgYSBOb2RlLWJhc2VkIHZlcnNpb24gaW5zdGVhZC5cclxuICAgKi9cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgUHJvY3RvciB7XHJcbiAgICBkZXZpY2U6IGNvbS5rZXltYW4udXRpbHMuRGV2aWNlU3BlYztcclxuXHJcbiAgICBfYXNzZXJ0OiBBc3NlcnRDYWxsYmFjaztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihkZXZpY2U6IGNvbS5rZXltYW4udXRpbHMuRGV2aWNlU3BlYywgYXNzZXJ0OiBBc3NlcnRDYWxsYmFjaykge1xyXG4gICAgICB0aGlzLmRldmljZSA9IGRldmljZTtcclxuXHJcbiAgICAgIHRoaXMuX2Fzc2VydCA9IGFzc2VydDtcclxuICAgIH1cclxuXHJcbiAgICBhc3NlcnRFcXVhbHMoczE6IHVua25vd24sIHMyOiB1bmtub3duLCBtc2c/OiBzdHJpbmcpIHtcclxuICAgICAgaWYodGhpcy5fYXNzZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5fYXNzZXJ0KHMxLCBzMiwgbXNnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBlcmZvcm1zIGdsb2JhbCB0ZXN0IHByZXAuXHJcbiAgICBhYnN0cmFjdCBiZWZvcmVBbGwoKTtcclxuXHJcbiAgICAvLyBQZXJmb3JtcyBwZXItdGVzdCBzZXR1cFxyXG4gICAgYWJzdHJhY3QgYmVmb3JlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvd3MgdGhlIHByb2N0b3IgdG8gaW5kaWNhdGUgaWYgaXMgY2FwYWJsZSBvZiBleGVjdXRpbmcgYSBzdWl0ZSBvZiB0ZXN0cyBvciBub3QuXHJcbiAgICAgKiBAcGFyYW0gdGVzdFN1aXRlIFxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjb21wYXRpYmxlV2l0aFN1aXRlKHRlc3RTdWl0ZTogS2V5Ym9hcmRUZXN0KTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIFByb2N0b3IgaXMgY2FwYWJsZSBvZiBydW5uaW5nIHRoZSBzcGVjaWZpZWQgc2V0IG9mIHRlc3RzLiBcclxuICAgICAqLyBcclxuICAgIGFic3RyYWN0IG1hdGNoZXNUZXN0U2V0KHRlc3RTZXQ6IFRlc3RTZXQ8YW55Pik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW11bGF0ZXMgdGhlIHNwZWNpZmllZCB0ZXN0IHNlcXVlbmNlIGZvciB1c2UgaW4gdGVzdGluZy5cclxuICAgICAqIEBwYXJhbSBzZXF1ZW5jZSBUaGUgcmVjb3JkZWQgc2VxdWVuY2UsIGdlbmVyYWxseSBwcm92aWRlZCBieSBhIHRlc3Qgc2V0LlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBzaW11bGF0ZVNlcXVlbmNlKHNlcXVlbmNlOiBUZXN0U2VxdWVuY2U8YW55PiwgdGFyZ2V0PzogY29tLmtleW1hbi50ZXh0Lk91dHB1dFRhcmdldCk7XHJcbiAgfVxyXG59IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL25vZGVfbW9kdWxlcy9Aa2V5bWFuYXBwL2tleWJvYXJkLXByb2Nlc3Nvci9zcmMvdGV4dC9rZXlFdmVudC50c1wiIC8+XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJwcm9jdG9yLnRzXCIgLz5cclxuXHJcbm5hbWVzcGFjZSBLTVdSZWNvcmRlciB7XHJcbiAgLy8jcmVnaW9uIERlZmluZXMgdGhlIElucHV0RXZlbnRTcGVjIHNldCwgdXNlZCB0byByZWNvbnN0cnVjdCBET00tYmFzZWQgZXZlbnRzIGZvciBicm93c2VyLWJhc2VkIHNpbXVsYXRpb25cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5wdXRFdmVudFNwZWMge1xyXG4gICAgdHlwZTogXCJrZXlcIiB8IFwib3NrXCI7XHJcbiAgICBzdGF0aWMgZnJvbUpTT05PYmplY3Qob2JqOiBhbnkpOiBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICAgIGlmKG9iaiAmJiBvYmoudHlwZSkge1xyXG4gICAgICAgIGlmKG9iai50eXBlID09IFwia2V5XCIpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgUGh5c2ljYWxJbnB1dEV2ZW50U3BlYyhvYmopO1xyXG4gICAgICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PSBcIm9za1wiKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IE9TS0lucHV0RXZlbnRTcGVjKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkVycm9yIGluIEpTT04gZm9ybWF0IGNvcnJlc3BvbmRpbmcgdG8gYW4gSW5wdXRFdmVudFNwZWMhXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9QcmV0dHlKU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFdlIHdhbnQgdGhlIGRlZmF1bHQsIG5vbi1zcGFjZWQgSlNPTiBmb3IgdGhpcyBjbGFzcywgZXZlbiB3aGVuIG90aGVyd2lzZSBhZGRpbmcgd2hpdGVzcGFjZS5cclxuICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KHRoaXMpO1xyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFBoeXNpY2FsSW5wdXRFdmVudFNwZWMgZXh0ZW5kcyBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgbW9kaWZpZXJDb2RlczogeyBbbW9kOnN0cmluZ106IG51bWJlciB9ID0ge1xyXG4gICAgICBcIlNoaWZ0XCI6MHgwMDAxLFxyXG4gICAgICBcIkNvbnRyb2xcIjoweDAwMDIsXHJcbiAgICAgIFwiQWx0XCI6MHgwMDA0LFxyXG4gICAgICBcIk1ldGFcIjoweDAwMDgsXHJcbiAgICAgIFwiQ2Fwc0xvY2tcIjoweDAwMTAsXHJcbiAgICAgIFwiTnVtTG9ja1wiOjB4MDAyMCxcclxuICAgICAgXCJTY3JvbGxMb2NrXCI6MHgwMDQwXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEtleWJvYXJkRXZlbnQgcHJvcGVydGllc1xyXG4gICAgdHlwZTogXCJrZXlcIiA9IFwia2V5XCI7XHJcbiAgICBrZXk6IHN0cmluZztcclxuICAgIGNvZGU6IHN0cmluZztcclxuICAgIGtleUNvZGU6IG51bWJlcjtcclxuICAgIG1vZGlmaWVyU2V0OiBudW1iZXI7XHJcbiAgICBsb2NhdGlvbjogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGU/OiBQaHlzaWNhbElucHV0RXZlbnRTcGVjKSB7IC8vIHBhcmFtZXRlciBpcyB1c2VkIHRvIHJlY29uc3RydWN0IGZyb20gSlNPTi5cclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGlmKGUpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGUua2V5O1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGUuY29kZTtcclxuICAgICAgICB0aGlzLmtleUNvZGUgPSBlLmtleUNvZGU7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllclNldCA9IGUubW9kaWZpZXJTZXQ7XHJcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGUubG9jYXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRNb2RpZmllclN0YXRlKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAoUGh5c2ljYWxJbnB1dEV2ZW50U3BlYy5tb2RpZmllckNvZGVzW2tleV0gJiB0aGlzLm1vZGlmaWVyU2V0KSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlTW9kaWZpZXJTdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgdmFyIGxpc3Q6IHN0cmluZyA9IFwiXCI7XHJcblxyXG4gICAgICBmb3IodmFyIGtleSBpbiBQaHlzaWNhbElucHV0RXZlbnRTcGVjLm1vZGlmaWVyQ29kZXMpIHtcclxuICAgICAgICBpZih0aGlzLmdldE1vZGlmaWVyU3RhdGUoa2V5KSkge1xyXG4gICAgICAgICAgbGlzdCArPSAoKGxpc3QgIT0gXCJcIiA/IFwiIFwiIDogXCJcIikgKyBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgT1NLSW5wdXRFdmVudFNwZWMgZXh0ZW5kcyBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICB0eXBlOiBcIm9za1wiID0gXCJvc2tcIjtcclxuICAgIGtleUlEOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gVGhlIHBhcmFtZXRlciBtYXkgYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgaXRlbSBmcm9tIHJhdyBKU09OLlxyXG4gICAgY29uc3RydWN0b3IoZT86IE9TS0lucHV0RXZlbnRTcGVjKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIGlmKGUpIHtcclxuICAgICAgICB0aGlzLmtleUlEID0gZS5rZXlJRDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyNlbmRyZWdpb25cclxuXHJcbiAgZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlY29yZGVkS2V5c3Ryb2tlIHtcclxuICAgIHR5cGU6IFwia2V5XCIgfCBcIm9za1wiO1xyXG5cclxuICAgIHN0YXRpYyBmcm9tSlNPTk9iamVjdChvYmo6IGFueSk6IFJlY29yZGVkS2V5c3Ryb2tlIHtcclxuICAgICAgaWYob2JqICYmIG9iai50eXBlKSB7XHJcbiAgICAgICAgaWYob2JqLnR5cGUgPT0gXCJrZXlcIikge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWNvcmRlZFBoeXNpY2FsS2V5c3Ryb2tlKG9iaiBhcyBSZWNvcmRlZFBoeXNpY2FsS2V5c3Ryb2tlKTsgXHJcbiAgICAgICAgfSBlbHNlIGlmKG9iaiAmJiBvYmoudHlwZSkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWNvcmRlZFN5bnRoZXRpY0tleXN0cm9rZShvYmogYXMgUmVjb3JkZWRTeW50aGV0aWNLZXlzdHJva2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJFcnJvciBpbiBKU09OIGZvcm1hdCBjb3JyZXNwb25kaW5nIHRvIGEgUmVjb3JkZWRLZXlzdHJva2UhXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9QcmV0dHlKU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIC8vIFdlIHdhbnQgdGhlIGRlZmF1bHQsIG5vbi1zcGFjZWQgSlNPTiBmb3IgdGhpcyBjbGFzcywgZXZlbiB3aGVuIG90aGVyd2lzZSBhZGRpbmcgd2hpdGVzcGFjZS5cclxuICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KHRoaXMpO1xyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBJbnB1dEV2ZW50U3BlYyB0aGF0IG1heSBiZSB1c2VkIHRvIHNpbXVsYXRlIHRoZSBrZXlzdHJva2Ugd2l0aGluIGEgYnJvd3Nlci1iYXNlZCBlbnZpcm9ubWVudC5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0IGlucHV0RXZlbnRTcGVjKCk6IElucHV0RXZlbnRTcGVjO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFJlY29yZGVkUGh5c2ljYWxLZXlzdHJva2UgZXh0ZW5kcyBSZWNvcmRlZEtleXN0cm9rZSB7XHJcbiAgICAvLyBLZXlib2FyZEV2ZW50IHByb3BlcnRpZXNcclxuICAgIHR5cGU6IFwia2V5XCIgPSBcImtleVwiO1xyXG5cclxuICAgIGtleUNvZGU6IG51bWJlcjsgIC8vIG1heSBiZSBkaWZmZXJlbnQgZnJvbSBldmVudFNwZWMncyB2YWx1ZSBiL2Mga2V5bWFwcGluZ1xyXG4gICAgc3RhdGVzOiBudW1iZXI7XHJcbiAgICBtb2RpZmllcnM6IG51bWJlcjtcclxuICAgIG1vZGlmaWVyQ2hhbmdlZDogYm9vbGVhbjtcclxuICAgIGlzVmlydHVhbEtleTogYm9vbGVhbjtcclxuICAgIHZrQ29kZTogbnVtYmVyOyAgLy8gbWF5IGJlIHBvc3NpYmxlIHRvIGVsaW1pbmF0ZTsgZGlmZmVyZW5jZXMgYXJpc2UgZnJvbSBtbmVtb25pY3MuXHJcblxyXG4gICAgZXZlbnRTcGVjOiBQaHlzaWNhbElucHV0RXZlbnRTcGVjO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGtleXN0cm9rZTogUmVjb3JkZWRQaHlzaWNhbEtleXN0cm9rZSlcclxuICAgIGNvbnN0cnVjdG9yKGtleXN0cm9rZTogY29tLmtleW1hbi50ZXh0LktleUV2ZW50LCBldmVudFNwZWM6IFBoeXNpY2FsSW5wdXRFdmVudFNwZWMpXHJcbiAgICBjb25zdHJ1Y3RvcihrZXlzdHJva2U6IFJlY29yZGVkUGh5c2ljYWxLZXlzdHJva2V8Y29tLmtleW1hbi50ZXh0LktleUV2ZW50LCBldmVudFNwZWM/OiBQaHlzaWNhbElucHV0RXZlbnRTcGVjKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICBpZihrZXlzdHJva2UgaW5zdGFuY2VvZiBjb20ua2V5bWFuLnRleHQuS2V5RXZlbnQgfHwgdHlwZW9mIGtleXN0cm9rZS50eXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIFN0b3JlIHdoYXQgaXMgbmVjZXNzYXJ5IGZvciBoZWFkbGVzcyBldmVudCByZWNvbnN0cnVjdGlvbi5cclxuICAgICAgICBrZXlzdHJva2UgPSBrZXlzdHJva2UgYXMgY29tLmtleW1hbi50ZXh0LktleUV2ZW50O1xyXG4gICAgICAgIHRoaXMua2V5Q29kZSA9IGtleXN0cm9rZS5MY29kZTtcclxuICAgICAgICB0aGlzLnN0YXRlcyA9IGtleXN0cm9rZS5Mc3RhdGVzO1xyXG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0ga2V5c3Ryb2tlLkxtb2RpZmllcnM7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllckNoYW5nZWQgPSAhIWtleXN0cm9rZS5MbW9kaWZpZXJDaGFuZ2U7XHJcbiAgICAgICAgdGhpcy5pc1ZpcnR1YWxLZXkgPSBrZXlzdHJva2UuTGlzVmlydHVhbEtleTtcclxuICAgICAgICB0aGlzLnZrQ29kZSA9IGtleXN0cm9rZS52a0NvZGU7XHJcblxyXG4gICAgICAgIC8vIEFsc28gc3RvcmUgdGhlIERPTS1iYXNlZCBldmVudCBzcGVjIGZvciB1c2UgaW4gaW50ZWdyYXRlZCB0ZXN0aW5nLlxyXG4gICAgICAgIHRoaXMuZXZlbnRTcGVjID0gZXZlbnRTcGVjO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEl0IG1pZ2h0IGJlIGEgcmF3IG9iamVjdCwgZnJvbSBKU09OLlxyXG4gICAgICAgIHRoaXMua2V5Q29kZSA9IGtleXN0cm9rZS5rZXlDb2RlO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzID0ga2V5c3Ryb2tlLnN0YXRlcztcclxuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IGtleXN0cm9rZS5tb2RpZmllcnM7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllckNoYW5nZWQgPSBrZXlzdHJva2UubW9kaWZpZXJDaGFuZ2VkO1xyXG4gICAgICAgIHRoaXMuaXNWaXJ0dWFsS2V5ID0ga2V5c3Ryb2tlLmlzVmlydHVhbEtleTtcclxuICAgICAgICB0aGlzLnZrQ29kZSA9IGtleXN0cm9rZS52a0NvZGU7XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRTcGVjID0gbmV3IFBoeXNpY2FsSW5wdXRFdmVudFNwZWMoa2V5c3Ryb2tlLmV2ZW50U3BlYyk7IC8vIG11c3QgYWxzbyBiZSByZWNvbnN0cnVjdGVkLlxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGlucHV0RXZlbnRTcGVjKCk6IElucHV0RXZlbnRTcGVjIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRTcGVjO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIFJlY29yZGVkU3ludGhldGljS2V5c3Ryb2tlIGV4dGVuZHMgUmVjb3JkZWRLZXlzdHJva2Uge1xyXG4gICAgLy8gS2V5Ym9hcmRFdmVudCBwcm9wZXJ0aWVzXHJcbiAgICB0eXBlOiBcIm9za1wiID0gXCJvc2tcIjtcclxuXHJcbiAgICBrZXlOYW1lOiBzdHJpbmc7XHJcbiAgICBsYXllcjogc3RyaW5nO1xyXG5cclxuICAgIGtleURpc3RyaWJ1dGlvbj86IGNvbS5rZXltYW4udGV4dC5LZXlEaXN0cmlidXRpb247XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa2V5c3Ryb2tlOiBSZWNvcmRlZFN5bnRoZXRpY0tleXN0cm9rZSlcclxuICAgIGNvbnN0cnVjdG9yKGtleXN0cm9rZTogY29tLmtleW1hbi50ZXh0LktleUV2ZW50KVxyXG4gICAgY29uc3RydWN0b3Ioa2V5c3Ryb2tlOiBSZWNvcmRlZFN5bnRoZXRpY0tleXN0cm9rZXxjb20ua2V5bWFuLnRleHQuS2V5RXZlbnQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGlmKGtleXN0cm9rZSBpbnN0YW5jZW9mIGNvbS5rZXltYW4udGV4dC5LZXlFdmVudCB8fCB0eXBlb2Yga2V5c3Ryb2tlLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAga2V5c3Ryb2tlID0ga2V5c3Ryb2tlIGFzIGNvbS5rZXltYW4udGV4dC5LZXlFdmVudDtcclxuICAgICAgICAvLyBTdG9yZSB3aGF0IGlzIG5lY2Vzc2FyeSBmb3IgaGVhZGxlc3MgZXZlbnQgcmVjb25zdHJ1Y3Rpb24uXHJcblxyXG4gICAgICAgIC8vIEFsc28gc3RvcmUgdGhlIERPTS1iYXNlZCBldmVudCBzcGVjIGZvciB1c2UgaW4gaW50ZWdyYXRlZCB0ZXN0aW5nLlxyXG4gICAgICAgIHRoaXMubGF5ZXIgPSBrZXlzdHJva2Uua2JkTGF5ZXI7XHJcbiAgICAgICAgdGhpcy5rZXlOYW1lID0ga2V5c3Ryb2tlLmtOYW1lO1xyXG4gICAgICAgIHRoaXMua2V5RGlzdHJpYnV0aW9uID0ga2V5c3Ryb2tlLmtleURpc3RyaWJ1dGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJdCBtaWdodCBiZSBhIHJhdyBvYmplY3QsIGZyb20gSlNPTi5cclxuICAgICAgICB0aGlzLmxheWVyID0ga2V5c3Ryb2tlLmxheWVyO1xyXG4gICAgICAgIHRoaXMua2V5TmFtZSA9IGtleXN0cm9rZS5rZXlOYW1lO1xyXG4gICAgICAgIHRoaXMua2V5RGlzdHJpYnV0aW9uID0ga2V5c3Ryb2tlLmtleURpc3RyaWJ1dGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldCBpbnB1dEV2ZW50U3BlYygpOiBJbnB1dEV2ZW50U3BlYyB7XHJcbiAgICAgIGxldCBldmVudFNwZWMgPSBuZXcgT1NLSW5wdXRFdmVudFNwZWMoKTtcclxuICAgICAgZXZlbnRTcGVjLmtleUlEID0gdGhpcy5sYXllciArICctJyArIHRoaXMua2V5TmFtZTtcclxuXHJcbiAgICAgIHJldHVybiBldmVudFNwZWM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgYWJzdHJhY3QgY2xhc3MgVGVzdFNlcXVlbmNlPEtleVJlY29yZCBleHRlbmRzIFJlY29yZGVkS2V5c3Ryb2tlIHwgSW5wdXRFdmVudFNwZWM+IHtcclxuICAgIGlucHV0czogS2V5UmVjb3JkW107XHJcbiAgICBvdXRwdXQ6IHN0cmluZztcclxuICAgIG1zZz86IHN0cmluZztcclxuXHJcbiAgICBhYnN0cmFjdCBoYXNPU0tJbnRlcmFjdGlvbigpOiBib29sZWFuO1xyXG5cclxuICAgIHRlc3QocHJvY3RvcjogUHJvY3RvciwgdGFyZ2V0PzogY29tLmtleW1hbi50ZXh0Lk91dHB1dFRhcmdldCk6IHtzdWNjZXNzOiBib29sZWFuLCByZXN1bHQ6IHN0cmluZ30ge1xyXG4gICAgICAvLyBTdGFydCB3aXRoIGFuIGVtcHR5IE91dHB1dFRhcmdldCBhbmQgYSBmcmVzaCBLZXlib2FyZFByb2Nlc3Nvci5cclxuICAgICAgaWYoIXRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IG5ldyBjb20ua2V5bWFuLnRleHQuTW9jaygpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm9jdG9yLmJlZm9yZSgpO1xyXG5cclxuICAgICAgbGV0IHJlc3VsdCA9IHByb2N0b3Iuc2ltdWxhdGVTZXF1ZW5jZSh0aGlzLCB0YXJnZXQpO1xyXG4gICAgICBwcm9jdG9yLmFzc2VydEVxdWFscyhyZXN1bHQsIHRoaXMub3V0cHV0LCB0aGlzLm1zZyk7XHJcblxyXG4gICAgICByZXR1cm4ge3N1Y2Nlc3M6IChyZXN1bHQgPT0gdGhpcy5vdXRwdXQpLCByZXN1bHQ6IHJlc3VsdH07XHJcbiAgICB9XHJcblxyXG4gICAgdG9QcmV0dHlKU09OKCk6IHN0cmluZyB7XHJcbiAgICAgIHZhciBzdHIgPSBcInsgXCI7XHJcbiAgICAgIGlmKHRoaXMub3V0cHV0KSB7XHJcbiAgICAgICAgc3RyICs9IFwiXFxcIm91dHB1dFxcXCI6IFxcXCJcIiArIHRoaXMub3V0cHV0ICsgXCJcXFwiLCBcIjtcclxuICAgICAgfVxyXG4gICAgICBzdHIgKz0gXCJcXFwiaW5wdXRzXFxcIjogW1xcblwiO1xyXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzdHIgKz0gXCIgIFwiICsgdGhpcy5pbnB1dHNbaV0udG9QcmV0dHlKU09OKCkgKyAoKGkgPT0gdGhpcy5pbnB1dHMubGVuZ3RoLTEpID8gXCJcXG5cIiA6IFwiLFxcblwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZih0aGlzLm1zZykge1xyXG4gICAgICAgIHN0ciArPSBcIl0sIFxcXCJtZXNzYWdlXFxcIjogXFxcIlwiICsgdGhpcy5tc2cgKyBcIlxcXCIgfVwiO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0ciArPSBcIl19XCI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBJbnB1dEV2ZW50U3BlY1NlcXVlbmNlIGV4dGVuZHMgVGVzdFNlcXVlbmNlPElucHV0RXZlbnRTcGVjPiB7XHJcbiAgICBpbnB1dHM6IElucHV0RXZlbnRTcGVjW107XHJcbiAgICBvdXRwdXQ6IHN0cmluZztcclxuICAgIG1zZz86IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbnM/OiBJbnB1dEV2ZW50U3BlY1tdIHwgSW5wdXRFdmVudFNwZWNTZXF1ZW5jZSwgb3V0cz86IHN0cmluZywgbXNnPzogc3RyaW5nKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICBpZihpbnMpIHtcclxuICAgICAgICBpZihpbnMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBbXS5jb25jYXQoaW5zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gV2UncmUgY29uc3RydWN0aW5nIGZyb20gZXhpc3RpbmcgSlNPTi5cclxuICAgICAgICAgIHRoaXMuaW5wdXRzID0gW107XHJcblxyXG4gICAgICAgICAgZm9yKHZhciBpZT0wOyBpZSA8IGlucy5pbnB1dHMubGVuZ3RoOyBpZSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzLnB1c2goSW5wdXRFdmVudFNwZWMuZnJvbUpTT05PYmplY3QoaW5zLmlucHV0c1tpZV0pKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IGlucy5vdXRwdXQ7XHJcbiAgICAgICAgICB0aGlzLm1zZyA9IGlucy5tc2c7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaW5wdXRzID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKG91dHMpIHtcclxuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKG1zZykge1xyXG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYWRkSW5wdXQoZXZlbnQ6IElucHV0RXZlbnRTcGVjLCBvdXRwdXQ6IHN0cmluZykge1xyXG4gICAgICB0aGlzLmlucHV0cy5wdXNoKGV2ZW50KTtcclxuICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaGFzT1NLSW50ZXJhY3Rpb24oKTogYm9vbGVhbiB7XHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZih0aGlzLmlucHV0c1tpXSBpbnN0YW5jZW9mIE9TS0lucHV0RXZlbnRTcGVjKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4cG9ydCBjbGFzcyBSZWNvcmRlZEtleXN0cm9rZVNlcXVlbmNlIGV4dGVuZHMgVGVzdFNlcXVlbmNlPFJlY29yZGVkS2V5c3Ryb2tlPiB7XHJcbiAgICBpbnB1dHM6IFJlY29yZGVkS2V5c3Ryb2tlW107XHJcbiAgICBvdXRwdXQ6IHN0cmluZztcclxuICAgIG1zZz86IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbnM/OiBSZWNvcmRlZEtleXN0cm9rZVtdLCBvdXRzPzogc3RyaW5nLCBtc2c/OiBzdHJpbmcpXHJcbiAgICBjb25zdHJ1Y3RvcihzZXF1ZW5jZTogUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZSlcclxuICAgIGNvbnN0cnVjdG9yKGlucz86IFJlY29yZGVkS2V5c3Ryb2tlW10gfCBSZWNvcmRlZEtleXN0cm9rZVNlcXVlbmNlLCBvdXRzPzogc3RyaW5nLCBtc2c/OiBzdHJpbmcpIHtcclxuICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgIGlmKGlucykge1xyXG4gICAgICAgIGlmKGlucyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICB0aGlzLmlucHV0cyA9IFtdLmNvbmNhdChpbnMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBXZSdyZSBjb25zdHJ1Y3RpbmcgZnJvbSBleGlzdGluZyBKU09OLlxyXG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcclxuXHJcbiAgICAgICAgICBmb3IodmFyIGllPTA7IGllIDwgaW5zLmlucHV0cy5sZW5ndGg7IGllKyspIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dHMucHVzaChSZWNvcmRlZEtleXN0cm9rZS5mcm9tSlNPTk9iamVjdChpbnMuaW5wdXRzW2llXSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMub3V0cHV0ID0gaW5zLm91dHB1dDtcclxuICAgICAgICAgIHRoaXMubXNnID0gaW5zLm1zZztcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYob3V0cykge1xyXG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYobXNnKSB7XHJcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRJbnB1dChldmVudDogUmVjb3JkZWRLZXlzdHJva2UsIG91dHB1dDogc3RyaW5nKSB7XHJcbiAgICAgIHRoaXMuaW5wdXRzLnB1c2goZXZlbnQpO1xyXG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICBoYXNPU0tJbnRlcmFjdGlvbigpOiBib29sZWFuIHtcclxuICAgICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKHRoaXMuaW5wdXRzW2ldIGluc3RhbmNlb2YgUmVjb3JkZWRTeW50aGV0aWNLZXlzdHJva2UpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2xhc3MgRm9udFN0dWJGb3JMYW5ndWFnZSB7XHJcbiAgICBmYW1pbHk6IHN0cmluZztcclxuICAgIHNvdXJjZTogc3RyaW5nW107XHJcblxyXG4gICAgY29uc3RydWN0b3IoYWN0aXZlU3R1YkVudHJ5OiBhbnkpIHtcclxuICAgICAgdGhpcy5mYW1pbHkgPSBhY3RpdmVTdHViRW50cnkuZmFtaWx5O1xyXG5cclxuICAgICAgdmFyIHNyYyA9IGFjdGl2ZVN0dWJFbnRyeS5maWxlcztcclxuICAgICAgaWYoIShzcmMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICBzcmMgPSBbIHNyYyBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNvdXJjZSA9IFtdO1xyXG4gICAgICBmb3IodmFyIGk9MDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuc291cmNlLnB1c2goYWN0aXZlU3R1YkVudHJ5LnBhdGggKyBzcmNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHJlZ2lvbjogc3RyaW5nO1xyXG4gICAgZm9udD86IEZvbnRTdHViRm9yTGFuZ3VhZ2U7XHJcbiAgICBvc2tGb250PzogRm9udFN0dWJGb3JMYW5ndWFnZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmVTdHViOiBhbnkpIHtcclxuICAgICAgaWYoYWN0aXZlU3R1Yi5LTEMpIHtcclxuICAgICAgICB0aGlzLmlkID0gYWN0aXZlU3R1Yi5LTEM7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gYWN0aXZlU3R1Yi5LTDtcclxuICAgICAgICB0aGlzLnJlZ2lvbiA9IGFjdGl2ZVN0dWIuS1I7XHJcbiAgXHJcbiAgICAgICAgLy8gRm9udHMuXHJcbiAgICAgICAgaWYoYWN0aXZlU3R1Yi5LRm9udCkge1xyXG4gICAgICAgICAgdGhpcy5mb250ID0gbmV3IEZvbnRTdHViRm9yTGFuZ3VhZ2UoYWN0aXZlU3R1Yi5LRm9udCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFjdGl2ZVN0dWIuS09za0ZvbnQpIHtcclxuICAgICAgICAgIHRoaXMub3NrRm9udCA9IG5ldyBGb250U3R1YkZvckxhbmd1YWdlKGFjdGl2ZVN0dWIuS09za0ZvbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmlkID0gYWN0aXZlU3R1Yi5pZDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBhY3RpdmVTdHViLm5hbWU7XHJcbiAgICAgICAgdGhpcy5yZWdpb24gPSBhY3RpdmVTdHViLnJlZ2lvbjtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UgZW5kIHVwIGFkZGluZyBmdW5jdGlvbmFsaXR5IHRvIEZvbnRTdHViRm9yTGFuZ3VhZ2UsIHdlJ2xsIG5lZWQgdG8gcHJvcGVybHkgcmVjb25zdHJ1Y3QgdGhlc2UuXHJcbiAgICAgICAgdGhpcy5mb250ID0gYWN0aXZlU3R1Yi5mb250O1xyXG4gICAgICAgIHRoaXMub3NrRm9udCA9IGFjdGl2ZVN0dWIub3NrRm9udDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGNsYXNzIEtleWJvYXJkU3R1YiB7XHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgZmlsZW5hbWU6IHN0cmluZztcclxuICAgIGxhbmd1YWdlczogTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQgfCBMYW5ndWFnZVN0dWJGb3JLZXlib2FyZFtdO1xyXG5cclxuICAgIC8vIENvbnN0cnVjdHMgYSBzdHViIHVzYWJsZSB3aXRoIEtleW1hbldlYidzIGFkZEtleWJvYXJkcygpIEFQSSBmdW5jdGlvbiBmcm9tXHJcbiAgICAvLyB0aGUgaW50ZXJuYWxseS10cmFja2VkIEFjdGl2ZVN0dWIgdmFsdWUgZm9yIHRoYXQga2V5Ym9hcmQuXHJcbiAgICBjb25zdHJ1Y3Rvcihqc29uPzogS2V5Ym9hcmRTdHViKSB7XHJcbiAgICAgIGlmKGpzb24pIHtcclxuICAgICAgICB0aGlzLmlkID0ganNvbi5pZDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBqc29uLm5hbWU7XHJcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGpzb24uZmlsZW5hbWU7XHJcblxyXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KGpzb24ubGFuZ3VhZ2VzKSkge1xyXG4gICAgICAgICAgdGhpcy5sYW5ndWFnZXMgPSBuZXcgTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQoanNvbi5sYW5ndWFnZXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmxhbmd1YWdlcyA9IFtdO1xyXG4gICAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBqc29uLmxhbmd1YWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmxhbmd1YWdlcy5wdXNoKG5ldyBMYW5ndWFnZVN0dWJGb3JLZXlib2FyZChqc29uLmxhbmd1YWdlc1tpXSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEZpcnN0TGFuZ3VhZ2UoKSB7XHJcbiAgICAgIGlmKHRoaXMubGFuZ3VhZ2VzIGluc3RhbmNlb2YgTGFuZ3VhZ2VTdHViRm9yS2V5Ym9hcmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZXMuaWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VzWzBdLmlkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0eXBlIFRBUkdFVCA9ICdoYXJkd2FyZSd8J2Rlc2t0b3AnfCdwaG9uZSd8J3RhYmxldCc7XHJcbiAgdHlwZSBPUyA9ICd3aW5kb3dzJ3wnYW5kcm9pZCd8J2lvcyd8J21hY29zeCd8J2xpbnV4JztcclxuICB0eXBlIEJST1dTRVIgPSAnaWUnfCdjaHJvbWUnfCdmaXJlZm94J3wnc2FmYXJpJ3wnb3BlcmEnOyAgLy8gISBubyAnZWRnZScgZGV0ZWN0aW9uIGluIEtNVyFcclxuXHJcbiAgZXhwb3J0IGNsYXNzIENvbnN0cmFpbnQge1xyXG4gICAgdGFyZ2V0OiBUQVJHRVQ7XHJcbiAgICB2YWxpZE9TTGlzdD86IE9TW107XHJcbiAgICB2YWxpZEJyb3dzZXJzPzogQlJPV1NFUltdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldDogVEFSR0VUfENvbnN0cmFpbnQsIHZhbGlkT1NMaXN0PzogT1NbXSwgdmFsaWRCcm93c2Vycz86IEJST1dTRVJbXSkge1xyXG4gICAgICBpZih0eXBlb2YodGFyZ2V0KSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudmFsaWRPU0xpc3QgPSB2YWxpZE9TTGlzdDtcclxuICAgICAgICB0aGlzLnZhbGlkQnJvd3NlcnMgPSB2YWxpZEJyb3dzZXJzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBqc29uID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0ganNvbi50YXJnZXQ7XHJcbiAgICAgICAgdGhpcy52YWxpZE9TTGlzdCA9IGpzb24udmFsaWRPU0xpc3Q7XHJcbiAgICAgICAgdGhpcy52YWxpZEJyb3dzZXJzID0ganNvbi52YWxpZEJyb3dzZXJzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbWF0Y2hlc0NsaWVudChkZXZpY2U6IGNvbS5rZXltYW4udXRpbHMuRGV2aWNlU3BlYywgdXNpbmdPU0s/OiBib29sZWFuKSB7XHJcbiAgICAgIC8vICMxOiAgUGxhdGZvcm0gY2hlY2suXHJcbiAgICAgIGlmKHVzaW5nT1NLID09PSB0cnVlKSB7XHJcbiAgICAgICAgaWYodGhpcy50YXJnZXQgIT0gZGV2aWNlLmZvcm1GYWN0b3IpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZih1c2luZ09TSyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBpZih0aGlzLnRhcmdldCAhPSAnaGFyZHdhcmUnKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYodGhpcy50YXJnZXQgIT0gZGV2aWNlLmZvcm1GYWN0b3IgJiYgdGhpcy50YXJnZXQgIT0gJ2hhcmR3YXJlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodGhpcy52YWxpZE9TTGlzdCkge1xyXG4gICAgICAgIGlmKHRoaXMudmFsaWRPU0xpc3QuaW5kZXhPZihkZXZpY2UuT1MgYXMgT1MpID09IC0xKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0aGlzLnZhbGlkQnJvd3NlcnMpIHtcclxuICAgICAgICBpZih0aGlzLnZhbGlkQnJvd3NlcnMuaW5kZXhPZihkZXZpY2UuYnJvd3NlciBhcyBCUk9XU0VSKSA9PSAtMSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2tzIGlmIGFub3RoZXIgQ29uc3RyYWludCBpbnN0YW5jZSBpcyBmdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIHRoaXMgb25lLlxyXG4gICAgZXF1YWxzKG90aGVyOiBDb25zdHJhaW50KSB7XHJcbiAgICAgIGlmKHRoaXMudGFyZ2V0ICE9IG90aGVyLnRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxpc3QxID0gdGhpcy52YWxpZE9TTGlzdCA/IHRoaXMudmFsaWRPU0xpc3QgOiBbJ2FueSddO1xyXG4gICAgICB2YXIgbGlzdDIgPSBvdGhlci52YWxpZE9TTGlzdCA/IG90aGVyLnZhbGlkT1NMaXN0IDogWydhbnknXTtcclxuXHJcbiAgICAgIGlmKGxpc3QxLnNvcnQoKS5qb2luKCcsJykgIT0gbGlzdDIuc29ydCgpLmpvaW4oJywnKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGlzdDEgPSB0aGlzLnZhbGlkQnJvd3NlcnMgPyB0aGlzLnZhbGlkQnJvd3NlcnMgOiBbJ3dlYiddO1xyXG4gICAgICBsaXN0MiA9IG90aGVyLnZhbGlkQnJvd3NlcnMgPyBvdGhlci52YWxpZEJyb3dzZXJzIDogWyd3ZWInXTtcclxuXHJcbiAgICAgIGlmKGxpc3QxLnNvcnQoKS5qb2luKCcsJykgIT0gbGlzdDIuc29ydCgpLmpvaW4oJywnKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgVGVzdEZhaWx1cmUge1xyXG4gICAgY29uc3RyYWludDogQ29uc3RyYWludDtcclxuICAgIHRlc3Q6IElucHV0RXZlbnRTcGVjU2VxdWVuY2U7XHJcbiAgICByZXN1bHQ6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50OiBDb25zdHJhaW50LCB0ZXN0OiBJbnB1dEV2ZW50U3BlY1NlcXVlbmNlLCBvdXRwdXQ6IHN0cmluZykge1xyXG4gICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50O1xyXG4gICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG4gICAgICB0aGlzLnJlc3VsdCA9IG91dHB1dDtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgZXhwb3J0IGludGVyZmFjZSBUZXN0U2V0PFNlcXVlbmNlIGV4dGVuZHMgVGVzdFNlcXVlbmNlPGFueT4+IHtcclxuICAgIGNvbnN0cmFpbnQ6IENvbnN0cmFpbnQ7XHJcblxyXG4gICAgYWRkVGVzdChzZXE6IFNlcXVlbmNlKTogdm9pZDtcclxuICAgIGlzVmFsaWRGb3JEZXZpY2UoZGV2aWNlOiBjb20ua2V5bWFuLnV0aWxzLkRldmljZVNwZWMsIHVzaW5nT1NLPzogYm9vbGVhbik6IGJvb2xlYW47XHJcbiAgICB0ZXN0KHByb2N0b3I6IFByb2N0b3IpOiBUZXN0RmFpbHVyZVtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNvcmUgY29uc3RyYWludC1zcGVjaWZpYyB0ZXN0IHNldCBkZWZpbml0aW9uIHVzZWQgZm9yIHRlc3RpbmcgdmVyc2lvbnMgMTAuMCB0byAxMy4wLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBFdmVudFNwZWNUZXN0U2V0IGltcGxlbWVudHMgVGVzdFNldDxJbnB1dEV2ZW50U3BlY1NlcXVlbmNlPiB7XHJcbiAgICBjb25zdHJhaW50OiBDb25zdHJhaW50O1xyXG4gICAgdGVzdFNldDogSW5wdXRFdmVudFNwZWNTZXF1ZW5jZVtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbnN0cmFpbnQ6IENvbnN0cmFpbnR8RXZlbnRTcGVjVGVzdFNldCkge1xyXG4gICAgICBpZihcInRhcmdldFwiIGluIGNvbnN0cmFpbnQpIHtcclxuICAgICAgICB0aGlzLmNvbnN0cmFpbnQgPSBjb25zdHJhaW50IGFzIENvbnN0cmFpbnQ7XHJcbiAgICAgICAgdGhpcy50ZXN0U2V0ID0gW107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGpzb24gPSBjb25zdHJhaW50IGFzIEV2ZW50U3BlY1Rlc3RTZXQ7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50ID0gbmV3IENvbnN0cmFpbnQoanNvbi5jb25zdHJhaW50KTtcclxuICAgICAgICB0aGlzLnRlc3RTZXQgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQ2xvbmUgZWFjaCB0ZXN0IHNlcXVlbmNlIC8gcmVjb25zdHJ1Y3QgZnJvbSBtZXRob2RsZXNzIEpTT04gb2JqZWN0LlxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwganNvbi50ZXN0U2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnRlc3RTZXQucHVzaChuZXcgSW5wdXRFdmVudFNwZWNTZXF1ZW5jZShqc29uLnRlc3RTZXRbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXN0KHNlcTogSW5wdXRFdmVudFNwZWNTZXF1ZW5jZSkge1xyXG4gICAgICB0aGlzLnRlc3RTZXQucHVzaChzZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IEV2ZW50U3BlY1Rlc3RTZXQgaXMgYXBwbGljYWJsZSB0byBiZSBydW4gb24gYSBkZXZpY2UuXHJcbiAgICBpc1ZhbGlkRm9yRGV2aWNlKGRldmljZTogY29tLmtleW1hbi51dGlscy5EZXZpY2VTcGVjLCB1c2luZ09TSz86IGJvb2xlYW4pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5tYXRjaGVzQ2xpZW50KGRldmljZSwgdXNpbmdPU0spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkaXR5IHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG4gICAgdGVzdChwcm9jdG9yOiBQcm9jdG9yKTogVGVzdEZhaWx1cmVbXSB7XHJcbiAgICAgIHZhciBmYWlsdXJlczogVGVzdEZhaWx1cmVbXSA9IFtdO1xyXG4gICAgICBsZXQgdGVzdFNldCA9IHRoaXMudGVzdFNldDtcclxuXHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGVzdFNldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0ZXN0U2VxID0gdGhpc1tpXTtcclxuICAgICAgICB2YXIgc2ltUmVzdWx0ID0gdGVzdFNldFtpXS50ZXN0KHByb2N0b3IpO1xyXG4gICAgICAgIGlmKCFzaW1SZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgLy8gRmFpbGVkIHRlc3QhXHJcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKG5ldyBUZXN0RmFpbHVyZSh0aGlzLmNvbnN0cmFpbnQsIHRlc3RTZXEsIHNpbVJlc3VsdC5yZXN1bHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWlsdXJlcy5sZW5ndGggPiAwID8gZmFpbHVyZXMgOiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNvcmUgY29uc3RyYWludC1zcGVjaWZpYyB0ZXN0IHNldCBkZWZpbml0aW9uIHVzZWQgZm9yIHRlc3RpbmcgdmVyc2lvbnMgMTAuMCB0byAxMy4wLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBjbGFzcyBSZWNvcmRlZFNlcXVlbmNlVGVzdFNldCBpbXBsZW1lbnRzIFRlc3RTZXQ8UmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZT4ge1xyXG4gICAgY29uc3RyYWludDogQ29uc3RyYWludDtcclxuICAgIHRlc3RTZXQ6IFJlY29yZGVkS2V5c3Ryb2tlU2VxdWVuY2VbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50OiBDb25zdHJhaW50fFJlY29yZGVkU2VxdWVuY2VUZXN0U2V0KSB7XHJcbiAgICAgIGlmKFwidGFyZ2V0XCIgaW4gY29uc3RyYWludCkge1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludCA9IGNvbnN0cmFpbnQgYXMgQ29uc3RyYWludDtcclxuICAgICAgICB0aGlzLnRlc3RTZXQgPSBbXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIganNvbiA9IGNvbnN0cmFpbnQgYXMgUmVjb3JkZWRTZXF1ZW5jZVRlc3RTZXQ7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50ID0gbmV3IENvbnN0cmFpbnQoanNvbi5jb25zdHJhaW50KTtcclxuICAgICAgICB0aGlzLnRlc3RTZXQgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQ2xvbmUgZWFjaCB0ZXN0IHNlcXVlbmNlIC8gcmVjb25zdHJ1Y3QgZnJvbSBtZXRob2RsZXNzIEpTT04gb2JqZWN0LlxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwganNvbi50ZXN0U2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnRlc3RTZXQucHVzaChuZXcgUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZShqc29uLnRlc3RTZXRbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXN0KHNlcTogUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZSkge1xyXG4gICAgICB0aGlzLnRlc3RTZXQucHVzaChzZXEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IEV2ZW50U3BlY1Rlc3RTZXQgaXMgYXBwbGljYWJsZSB0byBiZSBydW4gb24gYSBkZXZpY2UuXHJcbiAgICBpc1ZhbGlkRm9yRGV2aWNlKGRldmljZTogY29tLmtleW1hbi51dGlscy5EZXZpY2VTcGVjLCB1c2luZ09TSz86IGJvb2xlYW4pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5tYXRjaGVzQ2xpZW50KGRldmljZSwgdXNpbmdPU0spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkaXR5IHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxyXG4gICAgdGVzdChwcm9jdG9yOiBQcm9jdG9yKTogVGVzdEZhaWx1cmVbXSB7XHJcbiAgICAgIHZhciBmYWlsdXJlczogVGVzdEZhaWx1cmVbXSA9IFtdO1xyXG4gICAgICBsZXQgdGVzdFNldCA9IHRoaXMudGVzdFNldDtcclxuXHJcbiAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGVzdFNldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0ZXN0U2VxID0gdGhpc1tpXTtcclxuICAgICAgICB2YXIgc2ltUmVzdWx0ID0gdGVzdFNldFtpXS50ZXN0KHByb2N0b3IpO1xyXG4gICAgICAgIGlmKCFzaW1SZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgLy8gRmFpbGVkIHRlc3QhXHJcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoKG5ldyBUZXN0RmFpbHVyZSh0aGlzLmNvbnN0cmFpbnQsIHRlc3RTZXEsIHNpbVJlc3VsdC5yZXN1bHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWlsdXJlcy5sZW5ndGggPiAwID8gZmFpbHVyZXMgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRvVGVzdE5hbWUoKTogc3RyaW5nIHtcclxuICAgICAgbGV0IG5hbWUgPSBcImNvbnN0cmFpbnQ6IGZvciBcIiArIHRoaXMuY29uc3RyYWludC50YXJnZXQ7XHJcblxyXG4gICAgICBpZih0aGlzLmNvbnN0cmFpbnQudGFyZ2V0ID09ICdoYXJkd2FyZScpIHtcclxuICAgICAgICBuYW1lICs9IFwiIGtleWJvYXJkXCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmFtZSArPSBcIiBPU0tcIjtcclxuICAgICAgfVxyXG4gICAgICBpZih0aGlzLmNvbnN0cmFpbnQudmFsaWRPU0xpc3QpIHtcclxuICAgICAgICBuYW1lICs9IFwiIG9uIE9TIG9mIFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5jb25zdHJhaW50LnZhbGlkT1NMaXN0KTtcclxuICAgICAgfVxyXG4gICAgICBpZih0aGlzLmNvbnN0cmFpbnQudmFsaWRCcm93c2Vycykge1xyXG4gICAgICAgIG5hbWUgKz0gXCIgaW4gYnJvd3NlciBvZiBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuY29uc3RyYWludC52YWxpZEJyb3dzZXJzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleHBvcnQgY2xhc3MgS2V5Ym9hcmRUZXN0IHtcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoYXQgdmVyc2lvbiBvZiBLTVcncyByZWNvcmRlciB0aGUgc3BlYyBjb25mb3JtcyB0by5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNwZWNWZXJzaW9uOiBjb20ua2V5bWFuLnV0aWxzLlZlcnNpb24gPSBLZXlib2FyZFRlc3QuQ1VSUkVOVF9WRVJTSU9OO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZlcnNpb24gb2YgS01XIGluIHdoaWNoIHRoZSBSZWNvcmRlciB3YXMgZmlyc3Qgd3JpdHRlbi4gIFdvcmtlZCBmcm9tIDEwLjAgdG8gMTMuMCB3aXRoIFxyXG4gICAgICogb25seSBiYWNrd2FyZC1jb21wYXRpYmxlIGNoYW5nZXMgYW5kIG1pbm9yIHR3ZWFrcyB0byBjb25mb3JtIHRvIGludGVybmFsIEFQSSBzaGlmdHMuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRkFMTEJBQ0tfVkVSU0lPTiA9IG5ldyBjb20ua2V5bWFuLnV0aWxzLlZlcnNpb24oXCIxMC4wXCIpO1xyXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBDVVJSRU5UX1ZFUlNJT04gID0gbmV3IGNvbS5rZXltYW4udXRpbHMuVmVyc2lvbihcIjE0LjBcIik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3R1YiBpbmZvcm1hdGlvbiB0byBiZSBwYXNzZWQgaW50byBrZXltYW4uYWRkS2V5Ym9hcmRzKCkgaW4gb3JkZXIgdG8gcnVuIHRoZSB0ZXN0LlxyXG4gICAgICovXHJcbiAgICBrZXlib2FyZDogS2V5Ym9hcmRTdHViO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hc3RlciBhcnJheSBvZiB0ZXN0IHNldHMsIGVhY2ggb2Ygd2hpY2ggc3BlY2lmaWVzIGNvbnN0cmFpbnRzIGEgY2xpZW50IG11c3QgZnVsZmlsbCBmb3JcclxuICAgICAqIHRoZSB0ZXN0cyBjb250YWluZWQgdGhlcmVpbiB0byBiZSB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgaW5wdXRUZXN0U2V0czogVGVzdFNldDxhbnk+W107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvbnN0cnVjdHMgYSBLZXlib2FyZFRlc3Qgb2JqZWN0IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24sIHJlc3RvcmluZyBpdHMgbWV0aG9kcy4gXHJcbiAgICAgKiBAcGFyYW0gZnJvbUpTT04gXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZyb21KU09OPzogc3RyaW5nfEtleWJvYXJkU3R1YnxLZXlib2FyZFRlc3QpIHtcclxuICAgICAgaWYoIWZyb21KU09OKSB7XHJcbiAgICAgICAgdGhpcy5rZXlib2FyZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnB1dFRlc3RTZXRzID0gW107XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2UgaWYodHlwZW9mKGZyb21KU09OKSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGZyb21KU09OID0gSlNPTi5wYXJzZShmcm9tSlNPTikgYXMgS2V5Ym9hcmRUZXN0O1xyXG4gICAgICB9IGVsc2UgaWYoZnJvbUpTT04gaW5zdGFuY2VvZiBLZXlib2FyZFN0dWIpIHtcclxuICAgICAgICB0aGlzLmtleWJvYXJkID0gZnJvbUpTT047XHJcbiAgICAgICAgdGhpcy5pbnB1dFRlc3RTZXRzID0gW107XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZighZnJvbUpTT04uc3BlY1ZlcnNpb24pIHtcclxuICAgICAgICBmcm9tSlNPTi5zcGVjVmVyc2lvbiA9IEtleWJvYXJkVGVzdC5GQUxMQkFDS19WRVJTSU9OO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIElzIHNlcmlhbGl6ZWQgdG8gYSBTdHJpbmcgd2hlbiBzYXZlZC5cclxuICAgICAgICBmcm9tSlNPTi5zcGVjVmVyc2lvbiA9IG5ldyBjb20ua2V5bWFuLnV0aWxzLlZlcnNpb24oZnJvbUpTT04uc3BlY1ZlcnNpb24gYXMgdW5rbm93biBhcyBzdHJpbmcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkU3R1Yihmcm9tSlNPTi5rZXlib2FyZCk7XHJcbiAgICAgIHRoaXMuaW5wdXRUZXN0U2V0cyA9IFtdO1xyXG4gICAgICB0aGlzLnNwZWNWZXJzaW9uID0gZnJvbUpTT04uc3BlY1ZlcnNpb247XHJcblxyXG4gICAgICBpZih0aGlzLnNwZWNWZXJzaW9uLmVxdWFscyhLZXlib2FyZFRlc3QuRkFMTEJBQ0tfVkVSU0lPTikpIHtcclxuICAgICAgICAvLyBUb3AtbGV2ZWwgdGVzdCBzcGVjOiAgRXZlbnRTcGVjVGVzdFNldCwgYmFzZWQgZW50aXJlbHkgb24gYnJvd3NlciBldmVudHMuXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBmcm9tSlNPTi5pbnB1dFRlc3RTZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLmlucHV0VGVzdFNldHNbaV0gPSBuZXcgRXZlbnRTcGVjVGVzdFNldChmcm9tSlNPTi5pbnB1dFRlc3RTZXRzW2ldIGFzIEV2ZW50U3BlY1Rlc3RTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGZyb21KU09OLmlucHV0VGVzdFNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMuaW5wdXRUZXN0U2V0c1tpXSA9IG5ldyBSZWNvcmRlZFNlcXVlbmNlVGVzdFNldChmcm9tSlNPTi5pbnB1dFRlc3RTZXRzW2ldIGFzIFJlY29yZGVkU2VxdWVuY2VUZXN0U2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRUZXN0KGNvbnN0cmFpbnQ6IENvbnN0cmFpbnQsIHNlcTogUmVjb3JkZWRLZXlzdHJva2VTZXF1ZW5jZSkge1xyXG4gICAgICBpZighdGhpcy5zcGVjVmVyc2lvbi5lcXVhbHMoS2V5Ym9hcmRUZXN0LkNVUlJFTlRfVkVSU0lPTikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudGx5LWxvYWRlZCB0ZXN0IHdhcyBidWlsdCB0byBhbiBvdXRkYXRlZCBzcGVjaWZpY2F0aW9uIGFuZCBtYXkgbm90IGJlIGFsdGVyZWQuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMuaW5wdXRUZXN0U2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmKHRoaXMuaW5wdXRUZXN0U2V0c1tpXS5jb25zdHJhaW50LmVxdWFscyhjb25zdHJhaW50KSkge1xyXG4gICAgICAgICAgdGhpcy5pbnB1dFRlc3RTZXRzW2ldLmFkZFRlc3Qoc2VxKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBuZXdTZXQgPSBuZXcgUmVjb3JkZWRTZXF1ZW5jZVRlc3RTZXQobmV3IENvbnN0cmFpbnQoY29uc3RyYWludCkpO1xyXG4gICAgICB0aGlzLmlucHV0VGVzdFNldHMucHVzaChuZXdTZXQpO1xyXG4gICAgICBuZXdTZXQuYWRkVGVzdChzZXEpOyAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHRlc3QocHJvY3RvcjogUHJvY3Rvcikge1xyXG4gICAgICB2YXIgc2V0SGFzUnVuID0gZmFsc2U7XHJcbiAgICAgIHZhciBmYWlsdXJlczogVGVzdEZhaWx1cmVbXSA9IFtdO1xyXG5cclxuICAgICAgcHJvY3Rvci5iZWZvcmVBbGwoKTtcclxuXHJcbiAgICAgIC8vIFRoZSBvcmlnaW5hbCB0ZXN0IHNwZWMgcmVxdWlyZXMgYSBicm93c2VyIGVudmlyb25tZW50IGFuZCB0aHVzIHJlcXVpcmVzIGl0cyBvd24gYC5ydW5gIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICBpZighKHByb2N0b3IuY29tcGF0aWJsZVdpdGhTdWl0ZSh0aGlzKSkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBwZXJmb3JtIHZlcnNpb24gXCIgKyBLZXlib2FyZFRlc3QuRkFMTEJBQ0tfVkVSU0lPTiArIFwiLWJhc2VkIHRlc3Rpbmcgb3V0c2lkZSBvZiBicm93c2VyLWJhc2VkIGVudmlyb25tZW50cy5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHRlc3Qgc3BlYyBpbnN0YW5jZXMgd2lsbCBrbm93IGhvdyB0byBydW4gaW4gYW55IGN1cnJlbnRseS1zdXBwb3J0ZWQgZW52aXJvbm1lbnQuXHJcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0VGVzdFNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgdGVzdFNldCA9IHRoaXMuaW5wdXRUZXN0U2V0c1tpXTtcclxuXHJcbiAgICAgICAgaWYocHJvY3Rvci5tYXRjaGVzVGVzdFNldCh0ZXN0U2V0KSkge1xyXG4gICAgICAgICAgdmFyIHRlc3RGYWlsdXJlcyA9IHRlc3RTZXQudGVzdChwcm9jdG9yKTtcclxuICAgICAgICAgIGlmKHRlc3RGYWlsdXJlcykge1xyXG4gICAgICAgICAgICBmYWlsdXJlcyA9IGZhaWx1cmVzLmNvbmNhdCh0ZXN0RmFpbHVyZXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2V0SGFzUnVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKCFzZXRIYXNSdW4pIHtcclxuICAgICAgICAvLyBUaGUgc2V0cyBDQU4gYmUgZW1wdHksIGFsbG93aW5nIHNpbGVudCBmYWlsdXJlIGlmL3doZW4gd2UgYWN0dWFsbHkgd2FudCB0aGF0LlxyXG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vIHRlc3Qgc2V0cyBmb3IgdGhpcyBrZXlib2FyZCB3ZXJlIGFwcGxpY2FibGUgZm9yIHRoaXMgZGV2aWNlIVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxsb3cgdGhlIG1ldGhvZCdzIGNhbGxlciB0byB0cmlnZ2VyIGEgJ2ZhaWwnLlxyXG4gICAgICBpZihmYWlsdXJlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWx1cmVzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRUZXN0U2V0cy5sZW5ndGggPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0b1ByZXR0eUpTT04oKSB7XHJcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAnICAnKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaXNMZWdhY3koKTogYm9vbGVhbiB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zcGVjVmVyc2lvbi5lcXVhbHMoS2V5Ym9hcmRUZXN0LkNVUlJFTlRfVkVSU0lPTik7XHJcbiAgICB9XHJcbiAgfVxyXG59Il19