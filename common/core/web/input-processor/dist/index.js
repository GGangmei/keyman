'use strict';
// Autogenerated code. Do not modify!
function LMLayerWorkerCode() {
    /*! https://mths.be/codepointat v0.2.0 by @mathias */
    if (!String.prototype.codePointAt) {
        (function () {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function () {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                }
                catch (error) { }
                return result;
            }());
            var codePointAt = function (position) {
                if (this == null) {
                    throw TypeError();
                }
                var string = String(this);
                var size = string.length;
                // `ToInteger`
                var index = position ? Number(position) : 0;
                if (index != index) { // better `isNaN`
                    index = 0;
                }
                // Account for out-of-bounds indices:
                if (index < 0 || index >= size) {
                    return undefined;
                }
                // Get the first code unit
                var first = string.charCodeAt(index);
                var second;
                if ( // check if it’s the start of a surrogate pair
                first >= 0xD800 && first <= 0xDBFF && // high surrogate
                    size > index + 1 // there is a next code unit
                ) {
                    second = string.charCodeAt(index + 1);
                    if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                    }
                }
                return first;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'codePointAt', {
                    'value': codePointAt,
                    'configurable': true,
                    'writable': true
                });
            }
            else {
                String.prototype.codePointAt = codePointAt;
            }
        }());
    }
    /*! http://mths.be/startswith v0.2.0 by @mathias */
    if (!String.prototype.startsWith) {
        (function () {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function () {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                }
                catch (error) { }
                return result;
            }());
            var toString = {}.toString;
            var startsWith = function (search) {
                if (this == null) {
                    throw TypeError();
                }
                var string = String(this);
                if (search && toString.call(search) == '[object RegExp]') {
                    throw TypeError();
                }
                var stringLength = string.length;
                var searchString = String(search);
                var searchLength = searchString.length;
                var position = arguments.length > 1 ? arguments[1] : undefined;
                // `ToInteger`
                var pos = position ? Number(position) : 0;
                if (pos != pos) { // better `isNaN`
                    pos = 0;
                }
                var start = Math.min(Math.max(pos, 0), stringLength);
                // Avoid the `indexOf` call if no match is possible
                if (searchLength + start > stringLength) {
                    return false;
                }
                var index = -1;
                while (++index < searchLength) {
                    if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                        return false;
                    }
                }
                return true;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'startsWith', {
                    'value': startsWith,
                    'configurable': true,
                    'writable': true
                });
            }
            else {
                String.prototype.startsWith = startsWith;
            }
        }());
    }
    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from
    // Any npm-based ones require use of `require`, which won't work for us.
    // Production steps of ECMA-262, Edition 6, 22.1.2.1
    if (!Array.from) {
        Array.from = (function () {
            var toStr = Object.prototype.toString;
            var isCallable = function (fn) {
                return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
            };
            var toInteger = function (value) {
                var number = Number(value);
                if (isNaN(number)) {
                    return 0;
                }
                if (number === 0 || !isFinite(number)) {
                    return number;
                }
                return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var toLength = function (value) {
                var len = toInteger(value);
                return Math.min(Math.max(len, 0), maxSafeInteger);
            };
            // The length property of the from method is 1.
            return function from(arrayLike /*, mapFn, thisArg */) {
                // 1. Let C be the this value.
                var C = this;
                // 2. Let items be ToObject(arrayLike).
                var items = Object(arrayLike);
                // 3. ReturnIfAbrupt(items).
                if (arrayLike == null) {
                    throw new TypeError('Array.from requires an array-like object - not null or undefined');
                }
                // 4. If mapfn is undefined, then let mapping be false.
                var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
                var T;
                if (typeof mapFn !== 'undefined') {
                    // 5. else
                    // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
                    if (!isCallable(mapFn)) {
                        throw new TypeError('Array.from: when provided, the second argument must be a function');
                    }
                    // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
                    if (arguments.length > 2) {
                        T = arguments[2];
                    }
                }
                // 10. Let lenValue be Get(items, "length").
                // 11. Let len be ToLength(lenValue).
                var len = toLength(items.length);
                // 13. If IsConstructor(C) is true, then
                // 13. a. Let A be the result of calling the [[Construct]] internal method 
                // of C with an argument list containing the single item len.
                // 14. a. Else, Let A be ArrayCreate(len).
                var A = isCallable(C) ? Object(new C(len)) : new Array(len);
                // 16. Let k be 0.
                var k = 0;
                // 17. Repeat, while k < len… (also steps a - h)
                var kValue;
                while (k < len) {
                    kValue = items[k];
                    if (mapFn) {
                        A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                    }
                    else {
                        A[k] = kValue;
                    }
                    k += 1;
                }
                // 18. Let putStatus be Put(A, "length", len, true).
                A.length = len;
                // 20. Return A.
                return A;
            };
        }());
    }
    /***
       KeymanWeb 11.0
       Copyright 2019 SIL International
    ***/
    /**
     * Constructs a string from one or more Unicode character codepoint values
     * passed as integer parameters.
     *
     * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
     * @return {string|null}      The new String object.
     */
    String.kmwFromCharCode = function (cp0) {
        var chars = [], i;
        for (i = 0; i < arguments.length; i++) {
            var c = Number(arguments[i]);
            if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
                throw new RangeError("Invalid code point " + c);
            }
            if (c < 0x10000) {
                chars.push(c);
            }
            else {
                c -= 0x10000;
                chars.push((c >> 10) + 0xD800);
                chars.push((c % 0x400) + 0xDC00);
            }
        }
        return String.fromCharCode.apply(undefined, chars);
    };
    /**
     * Returns a number indicating the Unicode value of the character at the given
     * code point index, with support for supplementary plane characters.
     *
     * @param  {number}  codePointIndex  The code point index into the string (not
                                         the code unit index) to return
     * @return {number}                  The Unicode character value
     */
    String.prototype.kmwCharCodeAt = function (codePointIndex) {
        var str = String(this);
        var codeUnitIndex = 0;
        if (codePointIndex < 0 || codePointIndex >= str.length) {
            return NaN;
        }
        for (var i = 0; i < codePointIndex; i++) {
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
            if (codeUnitIndex === null)
                return NaN;
        }
        var first = str.charCodeAt(codeUnitIndex);
        if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
            var second = str.charCodeAt(codeUnitIndex + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
            }
        }
        return first;
    };
    /**
     * Returns the code point index within the calling String object of the first occurrence
     * of the specified value, or -1 if not found.
     *
     * @param  {string}  searchValue    The value to search for
     * @param  {number}  [fromIndex]    Optional code point index to start searching from
     * @return {number}                 The code point index of the specified search value
     */
    String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
        var str = String(this);
        var codeUnitIndex = str.indexOf(searchValue, fromIndex);
        if (codeUnitIndex < 0) {
            return codeUnitIndex;
        }
        var codePointIndex = 0;
        for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
            codePointIndex++;
        return codePointIndex;
    };
    /**
     * Returns the code point index within the calling String object of the last occurrence
     * of the specified value, or -1 if not found.
     *
     * @param  {string}  searchValue    The value to search for
     * @param  {number}  fromIndex      Optional code point index to start searching from
     * @return {number}                 The code point index of the specified search value
     */
    String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
        var str = String(this);
        var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
        if (codeUnitIndex < 0) {
            return codeUnitIndex;
        }
        var codePointIndex = 0;
        for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
            codePointIndex++;
        return codePointIndex;
    };
    /**
     * Returns the length of the string in code points, as opposed to code units.
     *
     * @return {number}                 The length of the string in code points
     */
    String.prototype.kmwLength = function () {
        var str = String(this);
        if (str.length == 0)
            return 0;
        for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        return i;
    };
    /**
     * Extracts a section of a string and returns a new string.
     *
     * @param  {number}  beginSlice    The start code point index in the string to
     *                                 extract from
     * @param  {number}  endSlice      Optional end code point index in the string
     *                                 to extract to
     * @return {string}                The substring as selected by beginSlice and
     *                                 endSlice
     */
    String.prototype.kmwSlice = function (beginSlice, endSlice) {
        var str = String(this);
        var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
        var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
        if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
            return '';
        else
            return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
    };
    /**
     * Returns the characters in a string beginning at the specified location through
     * the specified number of characters.
     *
     * @param  {number}  start         The start code point index in the string to
     *                                 extract from
     * @param  {number=}  length        Optional length to extract
     * @return {string}                The substring as selected by start and length
     */
    String.prototype.kmwSubstr = function (start, length) {
        var str = String(this);
        if (start < 0) {
            start = str.kmwLength() + start;
        }
        if (start < 0)
            start = 0;
        var startCodeUnit = str.kmwCodePointToCodeUnit(start);
        var endCodeUnit = startCodeUnit;
        if (startCodeUnit === null)
            return '';
        if (arguments.length < 2) {
            endCodeUnit = str.length;
        }
        else {
            for (var i = 0; i < length; i++)
                endCodeUnit = str.kmwNextChar(endCodeUnit);
        }
        if (endCodeUnit === null)
            return str.substring(startCodeUnit);
        else
            return str.substring(startCodeUnit, endCodeUnit);
    };
    /**
     * Returns the characters in a string between two indexes into the string.
     *
     * @param  {number}  indexA        The start code point index in the string to
     *                                 extract from
     * @param  {number}  indexB        The end code point index in the string to
     *                                 extract to
     * @return {string}                The substring as selected by indexA and indexB
     */
    String.prototype.kmwSubstring = function (indexA, indexB) {
        var str = String(this), indexACodeUnit, indexBCodeUnit;
        if (typeof (indexB) == 'undefined') {
            indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
            indexBCodeUnit = str.length;
        }
        else {
            if (indexA > indexB) {
                var c = indexA;
                indexA = indexB;
                indexB = c;
            }
            indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
            indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
        }
        if (isNaN(indexACodeUnit) || indexACodeUnit === null)
            indexACodeUnit = 0;
        if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
            indexBCodeUnit = str.length;
        return str.substring(indexACodeUnit, indexBCodeUnit);
    };
    /*
      Helper functions
    */
    /**
     * Returns the code unit index for the next code point in the string, accounting for
     * supplementary pairs
     *
     * @param  {number|null}  codeUnitIndex  The code unit position to increment
     * @return {number|null}                 The index of the next code point in the string,
     *                                       in code units
     */
    String.prototype.kmwNextChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
            return null;
        }
        var first = str.charCodeAt(codeUnitIndex);
        if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
            var second = str.charCodeAt(codeUnitIndex + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                if (codeUnitIndex == str.length - 2) {
                    return null;
                }
                return codeUnitIndex + 2;
            }
        }
        return codeUnitIndex + 1;
    };
    /**
     * Returns the code unit index for the previous code point in the string, accounting
     * for supplementary pairs
     *
     * @param  {number|null}  codeUnitIndex  The code unit position to decrement
     * @return {number|null}                 The index of the previous code point in the
     *                                       string, in code units
    */
    String.prototype.kmwPrevChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
            return null;
        }
        var second = str.charCodeAt(codeUnitIndex - 1);
        if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
            var first = str.charCodeAt(codeUnitIndex - 2);
            if (first >= 0xD800 && first <= 0xDBFF) {
                return codeUnitIndex - 2;
            }
        }
        return codeUnitIndex - 1;
    };
    /**
     * Returns the corresponding code unit index to the code point index passed
     *
     * @param  {number|null} codePointIndex  A code point index in the string
     * @return {number|null}                 The corresponding code unit index
     */
    String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
        if (codePointIndex === null)
            return null;
        var str = String(this);
        var codeUnitIndex = 0;
        if (codePointIndex < 0) {
            codeUnitIndex = str.length;
            for (var i = 0; i > codePointIndex; i--)
                codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
            return codeUnitIndex;
        }
        if (codePointIndex == str.kmwLength())
            return str.length;
        for (var i = 0; i < codePointIndex; i++)
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        return codeUnitIndex;
    };
    /**
     * Returns the corresponding code point index to the code unit index passed
     *
     * @param  {number|null}  codeUnitIndex  A code unit index in the string
     * @return {number|null}                 The corresponding code point index
     */
    String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex === null)
            return null;
        else if (codeUnitIndex == 0)
            return 0;
        else if (codeUnitIndex < 0)
            return str.substr(codeUnitIndex).kmwLength();
        else
            return str.substr(0, codeUnitIndex).kmwLength();
    };
    /**
     * Returns the character at a the code point index passed
     *
     * @param  {number}  codePointIndex  A code point index in the string
     * @return {string}                  The corresponding character
     */
    String.prototype.kmwCharAt = function (codePointIndex) {
        var str = String(this);
        if (codePointIndex >= 0)
            return str.kmwSubstr(codePointIndex, 1);
        else
            return '';
    };
    /**
     * String prototype library extensions for basic plane characters,
     * to simplify enabling or disabling supplementary plane functionality (I3319)
     */
    /**
     * Returns the code unit index for the next code point in the string
     *
     * @param  {number}  codeUnitIndex    A code point index in the string
     * @return {number|null}                   The corresponding character
     */
    String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
            return null;
        }
        return codeUnitIndex + 1;
    };
    /**
     * Returns the code unit index for the previous code point in the string
     *
     * @param  {number}  codeUnitIndex    A code unit index in the string
     * @return {number|null}                   The corresponding character
     */
    String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
            return null;
        }
        return codeUnitIndex - 1;
    };
    /**
     * Returns the code unit index for a code point index
     *
     * @param  {number}  codePointIndex   A code point index in the string
     * @return {number}                   The corresponding character
     */
    String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
        return codePointIndex;
    };
    /**
     * Returns the code point index for a code unit index
     *
     * @param  {number}  codeUnitIndex    A code point index in the string
     * @return {number}                   The corresponding character
     */
    String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
        return codeUnitIndex;
    };
    /**
     * Returns the length of a BMP string
     *
     * @return {number}                   The length in code points
     */
    String.prototype.kmwBMPLength = function () {
        var str = String(this);
        return str.length;
    };
    /**
     * Returns a substring
     *
     * @param  {number}  n
     * @param  {number=}  ln
     * @return {string}
     */
    String.prototype.kmwBMPSubstr = function (n, ln) {
        var str = String(this);
        if (n > -1)
            return str.substr(n, ln);
        else
            return str.substr(str.length + n, -n);
    };
    /**
     * Enable or disable supplementary plane string handling
     *
     * @param  {boolean}  bEnable
     */
    String.kmwEnableSupplementaryPlane = function (bEnable) {
        var p = String.prototype;
        String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
        p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
        p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
        p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
        p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
        p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
        p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
        p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
        p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
        p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
        p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
        p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
        p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
    };
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var models;
    (function (models) {
        /**
         * @file dummy-model.ts
         *
         * Defines the Dummy model, which is used for testing the
         * prediction API exclusively.
         */
        /**
         * The Dummy Model that returns nonsensical, but predictable results.
         */
        var DummyModel = /** @class */ (function () {
            function DummyModel(options) {
                options = options || {};
                // Create a shallow copy of the suggestions;
                // this class mutates the array.
                this._futureSuggestions = options.futureSuggestions
                    ? options.futureSuggestions.slice() : [];
                if (options.punctuation) {
                    this.punctuation = options.punctuation;
                }
            }
            DummyModel.prototype.configure = function (capabilities) {
                this.configuration = {
                    leftContextCodePoints: capabilities.maxLeftContextCodePoints,
                    rightContextCodePoints: capabilities.maxRightContextCodePoints
                };
                return this.configuration;
            };
            DummyModel.prototype.predict = function (transform, context, injectedSuggestions) {
                var makeUniformDistribution = function (suggestions) {
                    var distribution = [];
                    var n = suggestions.length;
                    for (var _i = 0, suggestions_1 = suggestions; _i < suggestions_1.length; _i++) {
                        var s = suggestions_1[_i];
                        distribution.push({ sample: s, p: 1 }); // For a dummy model, this is sufficient.  The uniformness is all that matters.
                    }
                    return distribution;
                };
                if (injectedSuggestions) {
                    return makeUniformDistribution(injectedSuggestions);
                }
                var currentSet = this._futureSuggestions.shift();
                if (!currentSet) {
                    return [];
                }
                else {
                    return makeUniformDistribution(currentSet);
                }
            };
            DummyModel.prototype.wordbreak = function (context) {
                var words = wordBreakers.default_(context.left);
                if (words.length > 0) {
                    return words.pop().text;
                }
                return '';
            };
            return DummyModel;
        }());
        models.DummyModel = DummyModel;
        ;
    })(models || (models = {}));
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * A concrete span class that derives its properties from the result of
         * RegExp.exec() array.
         */
        var RegExpDerivedSpan = /** @class */ (function () {
            function RegExpDerivedSpan(text, start) {
                this.text = text;
                this.start = start;
            }
            Object.defineProperty(RegExpDerivedSpan.prototype, "length", {
                get: function () {
                    return this.text.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RegExpDerivedSpan.prototype, "end", {
                get: function () {
                    return this.start + this.text.length;
                },
                enumerable: true,
                configurable: true
            });
            return RegExpDerivedSpan;
        }());
        /**
         * Splits ASCII words.
         *
         * @param phrase
         */
        function ascii(phrase) {
            var matchWord = /[A-Za-z0-9']+/g;
            var words = [];
            var match;
            while ((match = matchWord.exec(phrase)) !== null) {
                words.push(new RegExpDerivedSpan(match[0], match.index));
            }
            return words;
        }
        wordBreakers.ascii = ascii;
    })(wordBreakers || (wordBreakers = {}));
    var ModelCompositor = /** @class */ (function () {
        function ModelCompositor(lexicalModel) {
            this.lexicalModel = lexicalModel;
            this.punctuation = ModelCompositor.determinePunctuationFromModel(lexicalModel);
        }
        ModelCompositor.prototype.isWhitespace = function (transform) {
            // Matches prefixed text + any instance of a character with Unicode general property Z* or the following: CR, LF, and Tab.
            var whitespaceRemover = /.*[\u0009\u000A\u000D\u0020\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000]/i;
            // Filter out null-inserts; their high probability can cause issues.
            if (transform.insert == '') { // Can actually register as 'whitespace'.
                return false;
            }
            var insert = transform.insert;
            insert = insert.replace(whitespaceRemover, '');
            return insert == '';
        };
        ModelCompositor.prototype.isBackspace = function (transform) {
            return transform.insert == "" && transform.deleteLeft > 0;
        };
        ModelCompositor.prototype.predict = function (transformDistribution, context) {
            var suggestionDistribution = [];
            var punctuation = this.punctuation;
            // Assumption:  Duplicated 'displayAs' properties indicate duplicated Suggestions.
            // When true, we can use an 'associative array' to de-duplicate everything.
            var suggestionDistribMap = {};
            if (!(transformDistribution instanceof Array)) {
                transformDistribution = [{ sample: transformDistribution, p: 1.0 }];
            }
            // Find the transform for the actual keypress.
            var inputTransform = transformDistribution.sort(function (a, b) {
                return b.p - a.p;
            })[0].sample;
            // Only allow new-word suggestions if space was the most likely keypress.
            var allowSpace = this.isWhitespace(inputTransform);
            var allowBksp = this.isBackspace(inputTransform);
            var postContext = models.applyTransform(inputTransform, context);
            var keepOptionText = this.lexicalModel.wordbreak(postContext);
            var keepOption = null;
            var _loop_1 = function (alt) {
                var transform = alt.sample;
                // Filter out special keys unless they're expected.
                if (this_1.isWhitespace(transform) && !allowSpace) {
                    return "continue";
                }
                else if (this_1.isBackspace(transform) && !allowBksp) {
                    return "continue";
                }
                var preserveWhitespace = false;
                if (this_1.isWhitespace(transform)) {
                    // Detect start of new word; prevent whitespace loss here.
                    var postContext_1 = models.applyTransform(transform, context);
                    preserveWhitespace = (this_1.lexicalModel.wordbreak(postContext_1) == '');
                }
                var distribution = this_1.lexicalModel.predict(transform, context);
                distribution.forEach(function (pair) {
                    // Let's not rely on the model to copy transform IDs.
                    // Only bother is there IS an ID to copy.
                    if (transform.id !== undefined) {
                        pair.sample.transformId = transform.id;
                    }
                    // Prepends the original whitespace, ensuring it is preserved if
                    // the suggestion is accepted.
                    if (preserveWhitespace) {
                        models.prependTransform(pair.sample.transform, transform);
                    }
                    // The model is trying to add a word; thus, add some custom formatting
                    // to that word.
                    if (pair.sample.transform.insert.length > 0) {
                        pair.sample.transform.insert += punctuation.insertAfterWord;
                    }
                    // Combine duplicate samples.
                    var displayText = pair.sample.displayAs;
                    if (displayText == keepOptionText) {
                        keepOption = pair.sample;
                        // Specifying 'keep' helps uses of the LMLayer find it quickly
                        // if/when desired.
                        keepOption.tag = 'keep';
                    }
                    else {
                        var existingSuggestion = suggestionDistribMap[displayText];
                        if (existingSuggestion) {
                            existingSuggestion.p += pair.p * alt.p;
                        }
                        else {
                            var compositedPair = { sample: pair.sample, p: pair.p * alt.p };
                            suggestionDistribMap[displayText] = compositedPair;
                        }
                    }
                });
            };
            var this_1 = this;
            for (var _i = 0, transformDistribution_1 = transformDistribution; _i < transformDistribution_1.length; _i++) {
                var alt = transformDistribution_1[_i];
                _loop_1(alt);
            }
            // Generate a default 'keep' option if one was not otherwise produced.
            if (!keepOption && keepOptionText != '') {
                keepOption = {
                    displayAs: keepOptionText,
                    transformId: inputTransform.id,
                    // Replicate the original transform, modified for appropriate language insertion syntax.
                    transform: {
                        insert: inputTransform.insert + punctuation.insertAfterWord,
                        deleteLeft: inputTransform.deleteLeft,
                        deleteRight: inputTransform.deleteRight,
                        id: inputTransform.id
                    },
                    tag: 'keep'
                };
            }
            // Add the surrounding quotes to the "keep" option's display string:
            if (keepOption) {
                var _a = punctuation.quotesForKeepSuggestion, open = _a.open, close_1 = _a.close;
                // Should we also ensure that we're using the default quote marks first?
                // Or is it reasonable to say that the "left" mark is always the one
                // called "open"?
                if (!punctuation.isRTL) {
                    keepOption.displayAs = open + keepOption.displayAs + close_1;
                }
                else {
                    keepOption.displayAs = close_1 + keepOption.displayAs + open;
                }
            }
            // Now that we've calculated a unique set of probability masses, time to make them into a proper
            // distribution and prep for return.
            for (var key in suggestionDistribMap) {
                var pair = suggestionDistribMap[key];
                suggestionDistribution.push(pair);
            }
            suggestionDistribution = suggestionDistribution.sort(function (a, b) {
                return b.p - a.p; // Use descending order - we want the largest probabilty suggestions first!
            });
            var suggestions = suggestionDistribution.splice(0, ModelCompositor.MAX_SUGGESTIONS).map(function (value) {
                return value.sample;
            });
            if (keepOption) {
                suggestions = [keepOption].concat(suggestions);
            }
            return suggestions;
        };
        /**
         * Returns the punctuation used for this model, filling out unspecified fields
         */
        ModelCompositor.determinePunctuationFromModel = function (model) {
            var defaults = DEFAULT_PUNCTUATION;
            // Use the defaults of the model does not provide any punctuation at all.
            if (!model.punctuation)
                return defaults;
            var specifiedPunctuation = model.punctuation;
            var insertAfterWord = specifiedPunctuation.insertAfterWord;
            if (insertAfterWord !== '' && !insertAfterWord) {
                insertAfterWord = defaults.insertAfterWord;
            }
            var quotesForKeepSuggestion = specifiedPunctuation.quotesForKeepSuggestion;
            if (!quotesForKeepSuggestion) {
                quotesForKeepSuggestion = defaults.quotesForKeepSuggestion;
            }
            var isRTL = specifiedPunctuation.isRTL;
            // Default:  false / undefined, so no need to directly specify it.
            return {
                insertAfterWord: insertAfterWord, quotesForKeepSuggestion: quotesForKeepSuggestion, isRTL: isRTL
            };
        };
        ModelCompositor.MAX_SUGGESTIONS = 12;
        return ModelCompositor;
    }());
    /**
     * The default punctuation and spacing produced by the model.
     */
    var DEFAULT_PUNCTUATION = {
        quotesForKeepSuggestion: { open: "\u201C", close: "\u201D" },
        insertAfterWord: " ",
    };
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var __assign = (this && this.__assign) || function () {
        __assign = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    /**
     * @file index.ts
     *
     * The main LMLayerWorker class, the top-level class within the Web Worker.
     * The LMLayerWorker handles the keyboard/worker communication
     * protocol, delegating prediction requests to the language
     * model implementations.
     */
    /// <reference path="../message.d.ts" />
    /// <reference path="../node_modules/@keymanapp/keyboard-processor/src/text/kmwstring.ts" />
    /// <reference path="models/dummy-model.ts" />
    /// <reference path="word_breaking/ascii-word-breaker.ts" />
    /// <reference path="./model-compositor.ts" />
    /**
     * Encapsulates all the state required for the LMLayer's worker thread.
     *
     * Implements the state pattern. There are three states:
     *
     *  - `unconfigured`  (initial state before configuration)
     *  - `modelless`     (state without model loaded)
     *  - `ready`         (state with model loaded, accepts prediction requests)
     *
     * Transitions are initiated by valid messages. Invalid
     * messages are errors, and do not lead to transitions.
     *
     *          +-------------+    load    +---------+
     *   config |             |----------->|         |
     *  +------->  modelless  +            +  ready  +---+
     *          |             |<-----------|         |   |
     *          +-------------+   unload   +----^----+   | predict
     *                                          |        |
     *                                          +--------+
     *
     * The model and the configuration are ONLY relevant in the `ready` state;
     * as such, they are NOT direct properties of the LMLayerWorker.
     */
    var LMLayerWorker = /** @class */ (function () {
        function LMLayerWorker(options) {
            if (options === void 0) {
                options = {
                    importScripts: null,
                    postMessage: null
                };
            }
            this._postMessage = options.postMessage || postMessage;
            this._importScripts = options.importScripts || importScripts;
            this.setupConfigState();
        }
        LMLayerWorker.prototype.error = function (message, error) {
            // error isn't a fan of being cloned across the worker boundary.
            this.cast('error', {
                log: message,
                error: (error && error.stack) ? error.stack : undefined
            });
        };
        /**
         * A function that can be set as self.onmessage (the Worker
         * message handler).
         * NOTE! You must bind it to a specific instance, e.g.:
         *
         *   // Do this!
         *   self.onmessage = worker.onMessage.bind(worker);
         *
         * Incorrect:
         *
         *   // Don't do this!
         *   self.onmessage = worker.onMessage;
         *
         * See: .install();
         */
        LMLayerWorker.prototype.onMessage = function (event) {
            var message = event.data.message;
            // Ensure the message is tagged with a valid message tag.
            if (!message) {
                throw new Error("Missing required 'message' property: " + event.data);
            }
            // If last load was for this exact model file, squash the message.
            // (Though not if we've had an unload since.)
            var im = event.data;
            if (im.message == 'load') {
                var data = im;
                if (data.model == this._currentModelSource) {
                    // Some JS implementations don't allow web workers access to the console.
                    if (typeof console !== 'undefined') {
                        console.warn("Duplicate model load message detected - squashing!");
                    }
                    return;
                }
                else {
                    this._currentModelSource = data.model;
                }
            }
            else if (im.message == 'unload') {
                this._currentModelSource = null;
            }
            // We got a message! Delegate to the current state.
            this.state.handleMessage(im);
        };
        /**
         * Sends back a message structured according to the protocol.
         * @param message A message type.
         * @param payload The message's payload. Can have any properties, except 'message'.
         */
        LMLayerWorker.prototype.cast = function (message, payload) {
            // Chrome raises "TypeError: invalid invocation" if postMessage is called
            // with any non-default value for `this`, i.e., this won't work:
            //
            //  this._postMessage({ foo: 'bar' });
            //
            // Yank it postMessage() off of `this` so that it's called on the
            // "global" context, and everything works again.
            var postMessage = this._postMessage;
            postMessage(__assign({ message: message }, payload));
        };
        /**
         * Loads a model by executing the given source code, and
         * passing in the appropriate configuration.
         *
         * @param desc         Type of the model to instantiate and its parameters.
         * @param capabilities Capabilities on offer from the keyboard.
         */
        LMLayerWorker.prototype.loadModel = function (model) {
            // TODO:  pass _platformConfig to model so that it can self-configure to the platform,
            // returning a Configuration.
            /* Note that this function is typically called from within an `importScripts` call.
             * For meaningful error messages to be successfully logged, we must catch what we can here
             * and pass a message to outside the worker - otherwise a generic "Script error" occurs.
             */
            try {
                var configuration = model.configure(this._platformCapabilities);
                // Handle deprecations.
                if (!configuration.leftContextCodePoints) {
                    configuration.leftContextCodePoints = configuration.leftContextCodeUnits;
                }
                if (!configuration.rightContextCodePoints) {
                    configuration.rightContextCodePoints = configuration.rightContextCodeUnits;
                }
                // Set reasonable defaults for the configuration.
                if (!configuration.leftContextCodePoints) {
                    configuration.leftContextCodePoints = this._platformCapabilities.maxLeftContextCodePoints;
                }
                if (!configuration.rightContextCodePoints) {
                    configuration.rightContextCodePoints = this._platformCapabilities.maxRightContextCodePoints || 0;
                }
                this.transitionToReadyState(model);
                this.cast('ready', { configuration: configuration });
            }
            catch (err) {
                this.error("loadModel failed!", err);
            }
        };
        LMLayerWorker.prototype.loadModelFile = function (url) {
            // The self/global WebWorker method, allowing us to directly import another script file into WebWorker scope.
            // If built correctly, the model's script file will auto-register the model with loadModel() above.
            try {
                this._importScripts(url);
            }
            catch (err) {
                this.error("Error occurred when attempting to load dictionary", err);
            }
        };
        LMLayerWorker.prototype.unloadModel = function () {
            // Right now, this seems sufficient to clear out the old model.
            // The only existing reference to a loaded model is held by 
            // transitionToReadyState's `handleMessage` closure. (The `model` var)
            this.transitionToLoadingState();
        };
        /**
         * Sets the initial state, i.e., `unconfigured`.
         * This state only handles `config` messages, and will
         * transition to the `modelless` state once it receives
         * the config data from the host platform.
         */
        LMLayerWorker.prototype.setupConfigState = function () {
            var _this = this;
            this.state = {
                name: 'unconfigured',
                handleMessage: function (payload) {
                    // ... that message must have been 'config'!
                    if (payload.message !== 'config') {
                        throw new Error("invalid message; expected 'config' but got " + payload.message);
                    }
                    _this._platformCapabilities = payload.capabilities;
                    _this.transitionToLoadingState();
                }
            };
        };
        /**
         * Sets the model-loading state, i.e., `modelless`.
         * This state only handles `load` messages, and will
         * transition to the `ready` state once it receives a model
         * description and capabilities.
         */
        LMLayerWorker.prototype.transitionToLoadingState = function () {
            var _this = this;
            this.state = {
                name: 'modelless',
                handleMessage: function (payload) {
                    // ...that message must have been 'load'!
                    if (payload.message !== 'load') {
                        throw new Error("invalid message; expected 'load' but got " + payload.message);
                    }
                    // TODO: validate configuration?
                    _this.loadModelFile(payload.model);
                }
            };
        };
        /**
         * Sets the state to `ready`. This requires a
         * fully-instantiated model. The `ready` state only responds
         * to `predict` message, and is an accepting state.
         *
         * @param model The loaded language model.
         */
        LMLayerWorker.prototype.transitionToReadyState = function (model) {
            var _this = this;
            this.state = {
                name: 'ready',
                handleMessage: function (payload) {
                    switch (payload.message) {
                        case 'predict':
                            var transform = payload.transform, context = payload.context;
                            var compositor = new ModelCompositor(model); // Yeah, should probably use a persistent one eventually.
                            var suggestions = compositor.predict(transform, context);
                            // Now that the suggestions are ready, send them out!
                            _this.cast('suggestions', {
                                token: payload.token,
                                suggestions: suggestions
                            });
                            break;
                        case 'wordbreak':
                            var brokenWord = model.wordbreak(payload.context);
                            _this.cast('currentword', {
                                token: payload.token,
                                word: brokenWord
                            });
                            break;
                        case 'unload':
                            _this.unloadModel();
                            break;
                        default:
                            throw new Error("invalid message; expected one of {'predict', 'unload'} but got " + payload.message);
                    }
                }
            };
        };
        /**
         * Creates a new instance of the LMLayerWorker, and installs all its
         * functions within the provided Worker global scope.
         *
         * In production, this is called within the Worker's scope as:
         *
         *    LMLayerWorker.install(self);
         *
         * ...and this will setup onmessage and postMessage() appropriately.
         *
         * During testing, this method is useful to mock an entire global scope,
         *
         *    var fakeScope = { postMessage: ... };
         *    LMLayerWorker.install(fakeScope);
         *    // now we can spy on methods in fakeScope!
         *
         * @param scope A global scope to install upon.
         */
        LMLayerWorker.install = function (scope) {
            var worker = new LMLayerWorker({ postMessage: scope.postMessage, importScripts: scope.importScripts.bind(scope) });
            scope.onmessage = worker.onMessage.bind(worker);
            // Ensures that the worker instance is accessible for loaded model scripts.
            // Assists unit-testing.
            scope['LMLayerWorker'] = worker;
            scope['models'] = models;
            scope['wordBreakers'] = wordBreakers;
            return worker;
        };
        return LMLayerWorker;
    }());
    // Let LMLayerWorker be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = LMLayerWorker;
        module.exports['models'] = models;
        module.exports['wordBreakers'] = wordBreakers;
        /// XXX: export the ModelCompositor for testing.
        module.exports['ModelCompositor'] = ModelCompositor;
    }
    else if (typeof self !== 'undefined' && 'postMessage' in self) {
        // Automatically install if we're in a Web Worker.
        LMLayerWorker.install(self); // really, 'as typeof globalThis', but we're currently getting TS errors from use of that.
    }
    else {
        //@ts-ignore
        window.LMLayerWorker = LMLayerWorker;
    }
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var models;
    (function (models) {
        function applyTransform(transform, context) {
            // First, get the current context
            var fullLeftContext = context.left || '';
            var lLen = fullLeftContext.length;
            var lDel = lLen < transform.deleteLeft ? lLen : transform.deleteLeft;
            var leftContext = fullLeftContext.substring(0, lLen - lDel) + (transform.insert || '');
            var fullRightContext = context.right || '';
            var rLen = fullRightContext.length;
            var rDel = rLen < transform.deleteRight ? rLen : transform.deleteRight;
            var rightContext = fullRightContext.substring(rDel);
            return {
                left: leftContext,
                right: rightContext,
                startOfBuffer: context.startOfBuffer,
                endOfBuffer: context.endOfBuffer
            };
        }
        models.applyTransform = applyTransform;
        /**
         *
         * @param transform Merges one transform into another, mutating the first parameter to
         *                  include the effects of the second.
         * @param prefix
         */
        function prependTransform(transform, prefix) {
            transform.insert = prefix.insert + transform.insert;
            transform.deleteLeft += prefix.deleteLeft;
            if (prefix.deleteRight) {
                transform.deleteRight = (transform.deleteRight || 0) + prefix.deleteRight;
            }
        }
        models.prependTransform = prependTransform;
    })(models || (models = {}));
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * A **VERY** dumb word breaker that simply splits at words. Do not use this
         * word breaker!
         *
         * @param phrase The phrase in which to break words.
         * @deprecated Use a word breaker tailored to your language instead!
         */
        function placeholder(phrase) {
            var nextStart = 0;
            return phrase.split(/\s+/).map(function (utterance) {
                // XXX: The indices are NOT accurate to the original phrase!
                var span = {
                    start: nextStart,
                    end: nextStart + utterance.length,
                    text: utterance,
                    length: utterance.length
                };
                nextStart = span.end;
                return span;
            });
        }
        wordBreakers.placeholder = placeholder;
    })(wordBreakers || (wordBreakers = {}));
    /*
     * Copyright (c) 2019 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2019 SIL International
     * Copyright (c) 2015–2017 Conrad Irwin
     * Copyright (c) 2011–2015 Marc Campbell
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    /// <reference path="../word_breaking/placeholder-word-breaker.ts" />
    /// <reference path="common.ts" />
    /**
     * @file trie-model.ts
     *
     * Defines a simple word list (unigram) model.
     */
    var models;
    (function (models) {
        /** Upper bound on the amount of suggestions to generate. */
        var MAX_SUGGESTIONS = 12;
        /**
         * @class TrieModel
         *
         * Defines a trie-backed word list model, or the unigram model.
         * Unigram models throw away all preceding words, and search
         * for the next word exclusively. As such, they can perform simple
         * prefix searches within words, however they are not very good
         * at predicting the next word.
         */
        var TrieModel = /** @class */ (function () {
            function TrieModel(trieData, options) {
                if (options === void 0) {
                    options = {};
                }
                this._trie = new Trie(trieData['root'], trieData['totalWeight'], options.searchTermToKey || defaultWordform2Key);
                this.breakWords = options.wordBreaker || wordBreakers['default'];
                this.punctuation = options.punctuation;
            }
            TrieModel.prototype.configure = function (capabilities) {
                return this.configuration = {
                    leftContextCodePoints: capabilities.maxLeftContextCodePoints,
                    rightContextCodePoints: capabilities.maxRightContextCodePoints
                };
            };
            TrieModel.prototype.predict = function (transform, context) {
                // Special-case the empty buffer/transform: return the top suggestions.
                if (!transform.insert && context.startOfBuffer && context.endOfBuffer) {
                    return makeDistribution(this._trie.firstN(MAX_SUGGESTIONS).map(function (_a) {
                        var text = _a.text, p = _a.p;
                        return ({
                            transform: {
                                insert: text,
                                deleteLeft: 0
                            },
                            displayAs: text,
                            p: p
                        });
                    }));
                }
                // Compute the results of the keystroke:
                var newContext = models.applyTransform(transform, context);
                // Computes the different in word length after applying the transform above.
                var leftDelOffset = transform.deleteLeft - transform.insert.kmwLength();
                // All text to the left of the cursor INCLUDING anything that has
                // just been typed.
                var prefix = this.getLastWord(newContext.left);
                // Return suggestions from the trie.
                return makeDistribution(this._trie.lookup(prefix).map(function (_a) {
                    var text = _a.text, p = _a.p;
                    return ({
                        transform: {
                            // Insert the suggestion from the Trie, verbatim
                            insert: text,
                            // Delete whatever the prefix that the user wrote.
                            // Note: a separate capitalization/orthography engine can take this
                            // result and transform it as needed.
                            deleteLeft: leftDelOffset + prefix.kmwLength(),
                        },
                        displayAs: text,
                        p: p
                    });
                }));
                /* Helper */
                function makeDistribution(suggestions) {
                    var distribution = [];
                    for (var _i = 0, suggestions_2 = suggestions; _i < suggestions_2.length; _i++) {
                        var s = suggestions_2[_i];
                        distribution.push({ sample: s, p: s.p });
                    }
                    return distribution;
                }
            };
            /**
             * Get the last word of the phrase, or nothing.
             * @param fullLeftContext the entire left context of the string.
             */
            TrieModel.prototype.getLastWord = function (fullLeftContext) {
                var words = this.breakWords(fullLeftContext);
                if (words.length > 0) {
                    return words.pop().text;
                }
                return '';
            };
            TrieModel.prototype.wordbreak = function (context) {
                return this.getLastWord(context.left);
            };
            return TrieModel;
        }());
        models.TrieModel = TrieModel;
        ;
        /**
         * Wrapper class for the trie and its nodes.
         */
        var Trie = /** @class */ (function () {
            function Trie(root, totalWeight, wordform2key) {
                this.root = root;
                this.toKey = wordform2key;
                this.totalWeight = totalWeight;
            }
            /**
             * Lookups an arbitrary prefix (a query) in the trie. Returns the top 3
             * results in sorted order.
             *
             * @param prefix
             */
            Trie.prototype.lookup = function (prefix) {
                var searchKey = this.toKey(prefix);
                var lowestCommonNode = findPrefix(this.root, searchKey);
                if (lowestCommonNode === null) {
                    return [];
                }
                return getSortedResults(lowestCommonNode, searchKey, this.totalWeight);
            };
            /**
             * Returns the top N suggestions from the trie.
             * @param n How many suggestions, maximum, to return.
             */
            Trie.prototype.firstN = function (n) {
                return getSortedResults(this.root, '', this.totalWeight, n);
            };
            return Trie;
        }());
        /**
         * Finds the deepest descendent in the trie with the given prefix key.
         *
         * This means that a search in the trie for a given prefix has a best-case
         * complexity of O(m) where m is the length of the prefix.
         *
         * @param key The prefix to search for.
         * @param index The index in the prefix. Initially 0.
         */
        function findPrefix(node, key, index) {
            if (index === void 0) {
                index = 0;
            }
            // An important note - the Trie itself is built on a per-JS-character basis,
            // not on a UTF-8 character-code basis.
            if (node.type === 'leaf' || index === key.length) {
                return node;
            }
            // So, for SMP models, we need to match each char of the supplementary pair
            // in sequence.  Each has its own node in the Trie.
            var char = key[index];
            if (node.children[char]) {
                return findPrefix(node.children[char], key, index + 1);
            }
            return null;
        }
        /**
         * Returns all entries matching the given prefix, in descending order of
         * weight.
         *
         * @param prefix  the prefix to match.
         * @param results the current results
         * @param queue
         */
        function getSortedResults(node, prefix, N, limit) {
            if (limit === void 0) {
                limit = MAX_SUGGESTIONS;
            }
            var queue = new PriorityQueue();
            var results = [];
            if (node.type === 'leaf') {
                // Assuming the values are sorted, we can just add all of the values in the
                // leaf, until we reach the limit.
                for (var _i = 0, _a = node.entries; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.key.startsWith(prefix)) {
                        var content = item.content, weight = item.weight;
                        results.push({
                            text: content,
                            p: weight / N
                        });
                        if (results.length >= limit) {
                            return results;
                        }
                    }
                }
            }
            else {
                queue.enqueue(node);
                var next = void 0;
                var _loop_2 = function () {
                    if (isNode(next)) {
                        // When a node is next up in the queue, that means that next least
                        // likely suggestion is among its decsendants.
                        // So we search all of its descendants!
                        if (next.type === 'leaf') {
                            queue.enqueueAll(next.entries);
                        }
                        else {
                            // XXX: alias `next` so that TypeScript can be SURE that internal is
                            // in fact an internal node. Because of the callback binding to the
                            // original definition of node (i.e., a Node | Entry), this will not
                            // type-check otherwise.
                            var internal_1 = next;
                            queue.enqueueAll(next.values.map(function (char) {
                                return internal_1.children[char];
                            }));
                        }
                    }
                    else {
                        // When an entry is up next in the queue, we just add its contents to
                        // the results!
                        results.push({
                            text: next.content,
                            p: next.weight / N
                        });
                        if (results.length >= limit) {
                            return { value: results };
                        }
                    }
                };
                while (next = queue.pop()) {
                    var state_1 = _loop_2();
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            return results;
        }
        /** TypeScript type guard that returns whether the thing is a Node. */
        function isNode(x) {
            return 'type' in x;
        }
        /**
         * A priority queue that always pops the highest weighted item.
         */
        var PriorityQueue = /** @class */ (function () {
            function PriorityQueue() {
                // TODO: This probable should use a max-heap implementation, but I'm just doing
                // a O(n log n) sort of the array when an item is popped.
                this._storage = [];
            }
            // TODO: this should have a limit, and ensure small values are not added.
            /**
             * Enqueues a single element to the priority queue.
             */
            PriorityQueue.prototype.enqueue = function (element) {
                this._storage.push(element);
            };
            /**
             * Adds an array of weighted elements to the priority queue.
             */
            PriorityQueue.prototype.enqueueAll = function (elements) {
                this._storage = this._storage.concat(elements);
            };
            /**
             * Pops the highest weighted item in the queue.
             */
            PriorityQueue.prototype.pop = function () {
                // Lazily sort only when NEEDED.
                // Sort in descending order of weight, so heaviest weight will be popped
                // first.
                this._storage.sort(function (a, b) { return b.weight - a.weight; });
                return this._storage.shift();
            };
            return PriorityQueue;
        }());
        /**
         * Converts word forms in into an indexable form. It does this by converting
         * the string to uppercase and trying to remove diacritical marks.
         *
         * This is a very naïve implementation, that I've only though to work on
         * languages that use the Latin script. Even then, some Latin-based
         * orthographies use code points that, under NFD normalization, do NOT
         * decompose into an ASCII letter and a combining diacritical mark (e.g.,
         * SENĆOŦEN).
         *
         * Use this only in early iterations of the model. For a production lexical
         * model, you SHOULD write/generate your own key function, tailored to your
         * language.
         */
        function defaultWordform2Key(wordform) {
            return wordform
                // remove all combining diacritics (if input is in NFD)
                .replace(/[\u0300-\u036f]/g, '')
                // remove all composed diacritics (if input is in NFC) LATIN-ONLY!
                .replace(/[\u00C0-\u212A]/g, function (c) {
                if (c in PARTIAL_NFD_LOOKUP) {
                    return PARTIAL_NFD_LOOKUP[c];
                }
                return c;
            })
                .toLowerCase();
        }
        /**
         * String.prototype.normalize() is not available on all platforms (*cough* IE
         * 11 *cough cough*). We want to use NFD to take off diacritical marks from
         * characters so that they are not used in key searches.
         *
         * This table is of all characters in the range of U+0100 to U+2200 that
         * have a canonical decomposition in NFD form. For some characters, this
         * translates them into their canonical characters (e.g., K -> K). For
         * characters with combining diacritical marks, this leaves behind the base
         * character, removing its diacritics (e.g., É -> E).
         */
        var PARTIAL_NFD_LOOKUP = { "À": "A", "Á": "A", "Â": "A", "Ã": "A", "Ä": "A", "Å": "A", "Ç": "C", "È": "E", "É": "E", "Ê": "E", "Ë": "E", "Ì": "I", "Í": "I", "Î": "I", "Ï": "I", "Ñ": "N", "Ò": "O", "Ó": "O", "Ô": "O", "Õ": "O", "Ö": "O", "Ù": "U", "Ú": "U", "Û": "U", "Ü": "U", "Ý": "Y", "à": "a", "á": "a", "â": "a", "ã": "a", "ä": "a", "å": "a", "ç": "c", "è": "e", "é": "e", "ê": "e", "ë": "e", "ì": "i", "í": "i", "î": "i", "ï": "i", "ñ": "n", "ò": "o", "ó": "o", "ô": "o", "õ": "o", "ö": "o", "ù": "u", "ú": "u", "û": "u", "ü": "u", "ý": "y", "ÿ": "y", "Ā": "A", "ā": "a", "Ă": "A", "ă": "a", "Ą": "A", "ą": "a", "Ć": "C", "ć": "c", "Ĉ": "C", "ĉ": "c", "Ċ": "C", "ċ": "c", "Č": "C", "č": "c", "Ď": "D", "ď": "d", "Ē": "E", "ē": "e", "Ĕ": "E", "ĕ": "e", "Ė": "E", "ė": "e", "Ę": "E", "ę": "e", "Ě": "E", "ě": "e", "Ĝ": "G", "ĝ": "g", "Ğ": "G", "ğ": "g", "Ġ": "G", "ġ": "g", "Ģ": "G", "ģ": "g", "Ĥ": "H", "ĥ": "h", "Ĩ": "I", "ĩ": "i", "Ī": "I", "ī": "i", "Ĭ": "I", "ĭ": "i", "Į": "I", "į": "i", "İ": "I", "Ĵ": "J", "ĵ": "j", "Ķ": "K", "ķ": "k", "Ĺ": "L", "ĺ": "l", "Ļ": "L", "ļ": "l", "Ľ": "L", "ľ": "l", "Ń": "N", "ń": "n", "Ņ": "N", "ņ": "n", "Ň": "N", "ň": "n", "Ō": "O", "ō": "o", "Ŏ": "O", "ŏ": "o", "Ő": "O", "ő": "o", "Ŕ": "R", "ŕ": "r", "Ŗ": "R", "ŗ": "r", "Ř": "R", "ř": "r", "Ś": "S", "ś": "s", "Ŝ": "S", "ŝ": "s", "Ş": "S", "ş": "s", "Š": "S", "š": "s", "Ţ": "T", "ţ": "t", "Ť": "T", "ť": "t", "Ũ": "U", "ũ": "u", "Ū": "U", "ū": "u", "Ŭ": "U", "ŭ": "u", "Ů": "U", "ů": "u", "Ű": "U", "ű": "u", "Ų": "U", "ų": "u", "Ŵ": "W", "ŵ": "w", "Ŷ": "Y", "ŷ": "y", "Ÿ": "Y", "Ź": "Z", "ź": "z", "Ż": "Z", "ż": "z", "Ž": "Z", "ž": "z", "Ơ": "O", "ơ": "o", "Ư": "U", "ư": "u", "Ǎ": "A", "ǎ": "a", "Ǐ": "I", "ǐ": "i", "Ǒ": "O", "ǒ": "o", "Ǔ": "U", "ǔ": "u", "Ǖ": "U", "ǖ": "u", "Ǘ": "U", "ǘ": "u", "Ǚ": "U", "ǚ": "u", "Ǜ": "U", "ǜ": "u", "Ǟ": "A", "ǟ": "a", "Ǡ": "A", "ǡ": "a", "Ǣ": "Æ", "ǣ": "æ", "Ǧ": "G", "ǧ": "g", "Ǩ": "K", "ǩ": "k", "Ǫ": "O", "ǫ": "o", "Ǭ": "O", "ǭ": "o", "Ǯ": "Ʒ", "ǯ": "ʒ", "ǰ": "j", "Ǵ": "G", "ǵ": "g", "Ǹ": "N", "ǹ": "n", "Ǻ": "A", "ǻ": "a", "Ǽ": "Æ", "ǽ": "æ", "Ǿ": "Ø", "ǿ": "ø", "Ȁ": "A", "ȁ": "a", "Ȃ": "A", "ȃ": "a", "Ȅ": "E", "ȅ": "e", "Ȇ": "E", "ȇ": "e", "Ȉ": "I", "ȉ": "i", "Ȋ": "I", "ȋ": "i", "Ȍ": "O", "ȍ": "o", "Ȏ": "O", "ȏ": "o", "Ȑ": "R", "ȑ": "r", "Ȓ": "R", "ȓ": "r", "Ȕ": "U", "ȕ": "u", "Ȗ": "U", "ȗ": "u", "Ș": "S", "ș": "s", "Ț": "T", "ț": "t", "Ȟ": "H", "ȟ": "h", "Ȧ": "A", "ȧ": "a", "Ȩ": "E", "ȩ": "e", "Ȫ": "O", "ȫ": "o", "Ȭ": "O", "ȭ": "o", "Ȯ": "O", "ȯ": "o", "Ȱ": "O", "ȱ": "o", "Ȳ": "Y", "ȳ": "y", "̀": "̀", "́": "́", "̓": "̓", "̈́": "̈", "ʹ": "ʹ", ";": ";", "΅": "¨", "Ά": "Α", "·": "·", "Έ": "Ε", "Ή": "Η", "Ί": "Ι", "Ό": "Ο", "Ύ": "Υ", "Ώ": "Ω", "ΐ": "ι", "Ϊ": "Ι", "Ϋ": "Υ", "ά": "α", "έ": "ε", "ή": "η", "ί": "ι", "ΰ": "υ", "ϊ": "ι", "ϋ": "υ", "ό": "ο", "ύ": "υ", "ώ": "ω", "ϓ": "ϒ", "ϔ": "ϒ", "Ѐ": "Е", "Ё": "Е", "Ѓ": "Г", "Ї": "І", "Ќ": "К", "Ѝ": "И", "Ў": "У", "Й": "И", "й": "и", "ѐ": "е", "ё": "е", "ѓ": "г", "ї": "і", "ќ": "к", "ѝ": "и", "ў": "у", "Ѷ": "Ѵ", "ѷ": "ѵ", "Ӂ": "Ж", "ӂ": "ж", "Ӑ": "А", "ӑ": "а", "Ӓ": "А", "ӓ": "а", "Ӗ": "Е", "ӗ": "е", "Ӛ": "Ә", "ӛ": "ә", "Ӝ": "Ж", "ӝ": "ж", "Ӟ": "З", "ӟ": "з", "Ӣ": "И", "ӣ": "и", "Ӥ": "И", "ӥ": "и", "Ӧ": "О", "ӧ": "о", "Ӫ": "Ө", "ӫ": "ө", "Ӭ": "Э", "ӭ": "э", "Ӯ": "У", "ӯ": "у", "Ӱ": "У", "ӱ": "у", "Ӳ": "У", "ӳ": "у", "Ӵ": "Ч", "ӵ": "ч", "Ӹ": "Ы", "ӹ": "ы", "Ḁ": "A", "ḁ": "a", "Ḃ": "B", "ḃ": "b", "Ḅ": "B", "ḅ": "b", "Ḇ": "B", "ḇ": "b", "Ḉ": "C", "ḉ": "c", "Ḋ": "D", "ḋ": "d", "Ḍ": "D", "ḍ": "d", "Ḏ": "D", "ḏ": "d", "Ḑ": "D", "ḑ": "d", "Ḓ": "D", "ḓ": "d", "Ḕ": "E", "ḕ": "e", "Ḗ": "E", "ḗ": "e", "Ḙ": "E", "ḙ": "e", "Ḛ": "E", "ḛ": "e", "Ḝ": "E", "ḝ": "e", "Ḟ": "F", "ḟ": "f", "Ḡ": "G", "ḡ": "g", "Ḣ": "H", "ḣ": "h", "Ḥ": "H", "ḥ": "h", "Ḧ": "H", "ḧ": "h", "Ḩ": "H", "ḩ": "h", "Ḫ": "H", "ḫ": "h", "Ḭ": "I", "ḭ": "i", "Ḯ": "I", "ḯ": "i", "Ḱ": "K", "ḱ": "k", "Ḳ": "K", "ḳ": "k", "Ḵ": "K", "ḵ": "k", "Ḷ": "L", "ḷ": "l", "Ḹ": "L", "ḹ": "l", "Ḻ": "L", "ḻ": "l", "Ḽ": "L", "ḽ": "l", "Ḿ": "M", "ḿ": "m", "Ṁ": "M", "ṁ": "m", "Ṃ": "M", "ṃ": "m", "Ṅ": "N", "ṅ": "n", "Ṇ": "N", "ṇ": "n", "Ṉ": "N", "ṉ": "n", "Ṋ": "N", "ṋ": "n", "Ṍ": "O", "ṍ": "o", "Ṏ": "O", "ṏ": "o", "Ṑ": "O", "ṑ": "o", "Ṓ": "O", "ṓ": "o", "Ṕ": "P", "ṕ": "p", "Ṗ": "P", "ṗ": "p", "Ṙ": "R", "ṙ": "r", "Ṛ": "R", "ṛ": "r", "Ṝ": "R", "ṝ": "r", "Ṟ": "R", "ṟ": "r", "Ṡ": "S", "ṡ": "s", "Ṣ": "S", "ṣ": "s", "Ṥ": "S", "ṥ": "s", "Ṧ": "S", "ṧ": "s", "Ṩ": "S", "ṩ": "s", "Ṫ": "T", "ṫ": "t", "Ṭ": "T", "ṭ": "t", "Ṯ": "T", "ṯ": "t", "Ṱ": "T", "ṱ": "t", "Ṳ": "U", "ṳ": "u", "Ṵ": "U", "ṵ": "u", "Ṷ": "U", "ṷ": "u", "Ṹ": "U", "ṹ": "u", "Ṻ": "U", "ṻ": "u", "Ṽ": "V", "ṽ": "v", "Ṿ": "V", "ṿ": "v", "Ẁ": "W", "ẁ": "w", "Ẃ": "W", "ẃ": "w", "Ẅ": "W", "ẅ": "w", "Ẇ": "W", "ẇ": "w", "Ẉ": "W", "ẉ": "w", "Ẋ": "X", "ẋ": "x", "Ẍ": "X", "ẍ": "x", "Ẏ": "Y", "ẏ": "y", "Ẑ": "Z", "ẑ": "z", "Ẓ": "Z", "ẓ": "z", "Ẕ": "Z", "ẕ": "z", "ẖ": "h", "ẗ": "t", "ẘ": "w", "ẙ": "y", "ẛ": "ſ", "Ạ": "A", "ạ": "a", "Ả": "A", "ả": "a", "Ấ": "A", "ấ": "a", "Ầ": "A", "ầ": "a", "Ẩ": "A", "ẩ": "a", "Ẫ": "A", "ẫ": "a", "Ậ": "A", "ậ": "a", "Ắ": "A", "ắ": "a", "Ằ": "A", "ằ": "a", "Ẳ": "A", "ẳ": "a", "Ẵ": "A", "ẵ": "a", "Ặ": "A", "ặ": "a", "Ẹ": "E", "ẹ": "e", "Ẻ": "E", "ẻ": "e", "Ẽ": "E", "ẽ": "e", "Ế": "E", "ế": "e", "Ề": "E", "ề": "e", "Ể": "E", "ể": "e", "Ễ": "E", "ễ": "e", "Ệ": "E", "ệ": "e", "Ỉ": "I", "ỉ": "i", "Ị": "I", "ị": "i", "Ọ": "O", "ọ": "o", "Ỏ": "O", "ỏ": "o", "Ố": "O", "ố": "o", "Ồ": "O", "ồ": "o", "Ổ": "O", "ổ": "o", "Ỗ": "O", "ỗ": "o", "Ộ": "O", "ộ": "o", "Ớ": "O", "ớ": "o", "Ờ": "O", "ờ": "o", "Ở": "O", "ở": "o", "Ỡ": "O", "ỡ": "o", "Ợ": "O", "ợ": "o", "Ụ": "U", "ụ": "u", "Ủ": "U", "ủ": "u", "Ứ": "U", "ứ": "u", "Ừ": "U", "ừ": "u", "Ử": "U", "ử": "u", "Ữ": "U", "ữ": "u", "Ự": "U", "ự": "u", "Ỳ": "Y", "ỳ": "y", "Ỵ": "Y", "ỵ": "y", "Ỷ": "Y", "ỷ": "y", "Ỹ": "Y", "ỹ": "y", "ἀ": "α", "ἁ": "α", "ἂ": "α", "ἃ": "α", "ἄ": "α", "ἅ": "α", "ἆ": "α", "ἇ": "α", "Ἀ": "Α", "Ἁ": "Α", "Ἂ": "Α", "Ἃ": "Α", "Ἄ": "Α", "Ἅ": "Α", "Ἆ": "Α", "Ἇ": "Α", "ἐ": "ε", "ἑ": "ε", "ἒ": "ε", "ἓ": "ε", "ἔ": "ε", "ἕ": "ε", "Ἐ": "Ε", "Ἑ": "Ε", "Ἒ": "Ε", "Ἓ": "Ε", "Ἔ": "Ε", "Ἕ": "Ε", "ἠ": "η", "ἡ": "η", "ἢ": "η", "ἣ": "η", "ἤ": "η", "ἥ": "η", "ἦ": "η", "ἧ": "η", "Ἠ": "Η", "Ἡ": "Η", "Ἢ": "Η", "Ἣ": "Η", "Ἤ": "Η", "Ἥ": "Η", "Ἦ": "Η", "Ἧ": "Η", "ἰ": "ι", "ἱ": "ι", "ἲ": "ι", "ἳ": "ι", "ἴ": "ι", "ἵ": "ι", "ἶ": "ι", "ἷ": "ι", "Ἰ": "Ι", "Ἱ": "Ι", "Ἲ": "Ι", "Ἳ": "Ι", "Ἴ": "Ι", "Ἵ": "Ι", "Ἶ": "Ι", "Ἷ": "Ι", "ὀ": "ο", "ὁ": "ο", "ὂ": "ο", "ὃ": "ο", "ὄ": "ο", "ὅ": "ο", "Ὀ": "Ο", "Ὁ": "Ο", "Ὂ": "Ο", "Ὃ": "Ο", "Ὄ": "Ο", "Ὅ": "Ο", "ὐ": "υ", "ὑ": "υ", "ὒ": "υ", "ὓ": "υ", "ὔ": "υ", "ὕ": "υ", "ὖ": "υ", "ὗ": "υ", "Ὑ": "Υ", "Ὓ": "Υ", "Ὕ": "Υ", "Ὗ": "Υ", "ὠ": "ω", "ὡ": "ω", "ὢ": "ω", "ὣ": "ω", "ὤ": "ω", "ὥ": "ω", "ὦ": "ω", "ὧ": "ω", "Ὠ": "Ω", "Ὡ": "Ω", "Ὢ": "Ω", "Ὣ": "Ω", "Ὤ": "Ω", "Ὥ": "Ω", "Ὦ": "Ω", "Ὧ": "Ω", "ὰ": "α", "ά": "α", "ὲ": "ε", "έ": "ε", "ὴ": "η", "ή": "η", "ὶ": "ι", "ί": "ι", "ὸ": "ο", "ό": "ο", "ὺ": "υ", "ύ": "υ", "ὼ": "ω", "ώ": "ω", "ᾀ": "α", "ᾁ": "α", "ᾂ": "α", "ᾃ": "α", "ᾄ": "α", "ᾅ": "α", "ᾆ": "α", "ᾇ": "α", "ᾈ": "Α", "ᾉ": "Α", "ᾊ": "Α", "ᾋ": "Α", "ᾌ": "Α", "ᾍ": "Α", "ᾎ": "Α", "ᾏ": "Α", "ᾐ": "η", "ᾑ": "η", "ᾒ": "η", "ᾓ": "η", "ᾔ": "η", "ᾕ": "η", "ᾖ": "η", "ᾗ": "η", "ᾘ": "Η", "ᾙ": "Η", "ᾚ": "Η", "ᾛ": "Η", "ᾜ": "Η", "ᾝ": "Η", "ᾞ": "Η", "ᾟ": "Η", "ᾠ": "ω", "ᾡ": "ω", "ᾢ": "ω", "ᾣ": "ω", "ᾤ": "ω", "ᾥ": "ω", "ᾦ": "ω", "ᾧ": "ω", "ᾨ": "Ω", "ᾩ": "Ω", "ᾪ": "Ω", "ᾫ": "Ω", "ᾬ": "Ω", "ᾭ": "Ω", "ᾮ": "Ω", "ᾯ": "Ω", "ᾰ": "α", "ᾱ": "α", "ᾲ": "α", "ᾳ": "α", "ᾴ": "α", "ᾶ": "α", "ᾷ": "α", "Ᾰ": "Α", "Ᾱ": "Α", "Ὰ": "Α", "Ά": "Α", "ᾼ": "Α", "ι": "ι", "῁": "¨", "ῂ": "η", "ῃ": "η", "ῄ": "η", "ῆ": "η", "ῇ": "η", "Ὲ": "Ε", "Έ": "Ε", "Ὴ": "Η", "Ή": "Η", "ῌ": "Η", "῍": "᾿", "῎": "᾿", "῏": "᾿", "ῐ": "ι", "ῑ": "ι", "ῒ": "ι", "ΐ": "ι", "ῖ": "ι", "ῗ": "ι", "Ῐ": "Ι", "Ῑ": "Ι", "Ὶ": "Ι", "Ί": "Ι", "῝": "῾", "῞": "῾", "῟": "῾", "ῠ": "υ", "ῡ": "υ", "ῢ": "υ", "ΰ": "υ", "ῤ": "ρ", "ῥ": "ρ", "ῦ": "υ", "ῧ": "υ", "Ῠ": "Υ", "Ῡ": "Υ", "Ὺ": "Υ", "Ύ": "Υ", "Ῥ": "Ρ", "῭": "¨", "΅": "¨", "`": "`", "ῲ": "ω", "ῳ": "ω", "ῴ": "ω", "ῶ": "ω", "ῷ": "ω", "Ὸ": "Ο", "Ό": "Ο", "Ὼ": "Ω", "Ώ": "Ω", "ῼ": "Ω", "´": "´", " ": " ", " ": " ", "Ω": "Ω", "K": "K", "Å": "A" };
    })(models || (models = {}));
    var wordBreakers;
    (function (wordBreakers) {
        var data;
        (function (data) {
            ;
            data.WORD_BREAK_PROPERTY = [
                [/*start*/ 0xA, /*end*/ 0xA, 1 /* LF */],
                [/*start*/ 0xB, /*end*/ 0xC, 2 /* Newline */],
                [/*start*/ 0xD, /*end*/ 0xD, 3 /* CR */],
                [/*start*/ 0x20, /*end*/ 0x20, 4 /* WSegSpace */],
                [/*start*/ 0x22, /*end*/ 0x22, 5 /* Double_Quote */],
                [/*start*/ 0x27, /*end*/ 0x27, 6 /* Single_Quote */],
                [/*start*/ 0x2C, /*end*/ 0x2C, 7 /* MidNum */],
                [/*start*/ 0x2E, /*end*/ 0x2E, 8 /* MidNumLet */],
                [/*start*/ 0x30, /*end*/ 0x39, 9 /* Numeric */],
                [/*start*/ 0x3A, /*end*/ 0x3A, 10 /* MidLetter */],
                [/*start*/ 0x3B, /*end*/ 0x3B, 7 /* MidNum */],
                [/*start*/ 0x41, /*end*/ 0x5A, 11 /* ALetter */],
                [/*start*/ 0x5F, /*end*/ 0x5F, 12 /* ExtendNumLet */],
                [/*start*/ 0x61, /*end*/ 0x7A, 11 /* ALetter */],
                [/*start*/ 0x85, /*end*/ 0x85, 2 /* Newline */],
                [/*start*/ 0xAA, /*end*/ 0xAA, 11 /* ALetter */],
                [/*start*/ 0xAD, /*end*/ 0xAD, 13 /* Format */],
                [/*start*/ 0xB5, /*end*/ 0xB5, 11 /* ALetter */],
                [/*start*/ 0xB7, /*end*/ 0xB7, 10 /* MidLetter */],
                [/*start*/ 0xBA, /*end*/ 0xBA, 11 /* ALetter */],
                [/*start*/ 0xC0, /*end*/ 0xD6, 11 /* ALetter */],
                [/*start*/ 0xD8, /*end*/ 0xF6, 11 /* ALetter */],
                [/*start*/ 0xF8, /*end*/ 0x1BA, 11 /* ALetter */],
                [/*start*/ 0x1BB, /*end*/ 0x1BB, 11 /* ALetter */],
                [/*start*/ 0x1BC, /*end*/ 0x1BF, 11 /* ALetter */],
                [/*start*/ 0x1C0, /*end*/ 0x1C3, 11 /* ALetter */],
                [/*start*/ 0x1C4, /*end*/ 0x293, 11 /* ALetter */],
                [/*start*/ 0x294, /*end*/ 0x294, 11 /* ALetter */],
                [/*start*/ 0x295, /*end*/ 0x2AF, 11 /* ALetter */],
                [/*start*/ 0x2B0, /*end*/ 0x2C1, 11 /* ALetter */],
                [/*start*/ 0x2C2, /*end*/ 0x2C5, 11 /* ALetter */],
                [/*start*/ 0x2C6, /*end*/ 0x2D1, 11 /* ALetter */],
                [/*start*/ 0x2D2, /*end*/ 0x2D7, 11 /* ALetter */],
                [/*start*/ 0x2DE, /*end*/ 0x2DF, 11 /* ALetter */],
                [/*start*/ 0x2E0, /*end*/ 0x2E4, 11 /* ALetter */],
                [/*start*/ 0x2EC, /*end*/ 0x2EC, 11 /* ALetter */],
                [/*start*/ 0x2ED, /*end*/ 0x2ED, 11 /* ALetter */],
                [/*start*/ 0x2EE, /*end*/ 0x2EE, 11 /* ALetter */],
                [/*start*/ 0x2EF, /*end*/ 0x2FF, 11 /* ALetter */],
                [/*start*/ 0x300, /*end*/ 0x36F, 14 /* Extend */],
                [/*start*/ 0x370, /*end*/ 0x373, 11 /* ALetter */],
                [/*start*/ 0x374, /*end*/ 0x374, 11 /* ALetter */],
                [/*start*/ 0x376, /*end*/ 0x377, 11 /* ALetter */],
                [/*start*/ 0x37A, /*end*/ 0x37A, 11 /* ALetter */],
                [/*start*/ 0x37B, /*end*/ 0x37D, 11 /* ALetter */],
                [/*start*/ 0x37E, /*end*/ 0x37E, 7 /* MidNum */],
                [/*start*/ 0x37F, /*end*/ 0x37F, 11 /* ALetter */],
                [/*start*/ 0x386, /*end*/ 0x386, 11 /* ALetter */],
                [/*start*/ 0x387, /*end*/ 0x387, 10 /* MidLetter */],
                [/*start*/ 0x388, /*end*/ 0x38A, 11 /* ALetter */],
                [/*start*/ 0x38C, /*end*/ 0x38C, 11 /* ALetter */],
                [/*start*/ 0x38E, /*end*/ 0x3A1, 11 /* ALetter */],
                [/*start*/ 0x3A3, /*end*/ 0x3F5, 11 /* ALetter */],
                [/*start*/ 0x3F7, /*end*/ 0x481, 11 /* ALetter */],
                [/*start*/ 0x483, /*end*/ 0x487, 14 /* Extend */],
                [/*start*/ 0x488, /*end*/ 0x489, 14 /* Extend */],
                [/*start*/ 0x48A, /*end*/ 0x52F, 11 /* ALetter */],
                [/*start*/ 0x531, /*end*/ 0x556, 11 /* ALetter */],
                [/*start*/ 0x559, /*end*/ 0x559, 11 /* ALetter */],
                [/*start*/ 0x55B, /*end*/ 0x55C, 11 /* ALetter */],
                [/*start*/ 0x55E, /*end*/ 0x55E, 11 /* ALetter */],
                [/*start*/ 0x560, /*end*/ 0x588, 11 /* ALetter */],
                [/*start*/ 0x589, /*end*/ 0x589, 7 /* MidNum */],
                [/*start*/ 0x591, /*end*/ 0x5BD, 14 /* Extend */],
                [/*start*/ 0x5BF, /*end*/ 0x5BF, 14 /* Extend */],
                [/*start*/ 0x5C1, /*end*/ 0x5C2, 14 /* Extend */],
                [/*start*/ 0x5C4, /*end*/ 0x5C5, 14 /* Extend */],
                [/*start*/ 0x5C7, /*end*/ 0x5C7, 14 /* Extend */],
                [/*start*/ 0x5D0, /*end*/ 0x5EA, 15 /* Hebrew_Letter */],
                [/*start*/ 0x5EF, /*end*/ 0x5F2, 15 /* Hebrew_Letter */],
                [/*start*/ 0x5F3, /*end*/ 0x5F3, 11 /* ALetter */],
                [/*start*/ 0x5F4, /*end*/ 0x5F4, 10 /* MidLetter */],
                [/*start*/ 0x600, /*end*/ 0x605, 13 /* Format */],
                [/*start*/ 0x60C, /*end*/ 0x60D, 7 /* MidNum */],
                [/*start*/ 0x610, /*end*/ 0x61A, 14 /* Extend */],
                [/*start*/ 0x61C, /*end*/ 0x61C, 13 /* Format */],
                [/*start*/ 0x620, /*end*/ 0x63F, 11 /* ALetter */],
                [/*start*/ 0x640, /*end*/ 0x640, 11 /* ALetter */],
                [/*start*/ 0x641, /*end*/ 0x64A, 11 /* ALetter */],
                [/*start*/ 0x64B, /*end*/ 0x65F, 14 /* Extend */],
                [/*start*/ 0x660, /*end*/ 0x669, 9 /* Numeric */],
                [/*start*/ 0x66B, /*end*/ 0x66B, 9 /* Numeric */],
                [/*start*/ 0x66C, /*end*/ 0x66C, 7 /* MidNum */],
                [/*start*/ 0x66E, /*end*/ 0x66F, 11 /* ALetter */],
                [/*start*/ 0x670, /*end*/ 0x670, 14 /* Extend */],
                [/*start*/ 0x671, /*end*/ 0x6D3, 11 /* ALetter */],
                [/*start*/ 0x6D5, /*end*/ 0x6D5, 11 /* ALetter */],
                [/*start*/ 0x6D6, /*end*/ 0x6DC, 14 /* Extend */],
                [/*start*/ 0x6DD, /*end*/ 0x6DD, 13 /* Format */],
                [/*start*/ 0x6DF, /*end*/ 0x6E4, 14 /* Extend */],
                [/*start*/ 0x6E5, /*end*/ 0x6E6, 11 /* ALetter */],
                [/*start*/ 0x6E7, /*end*/ 0x6E8, 14 /* Extend */],
                [/*start*/ 0x6EA, /*end*/ 0x6ED, 14 /* Extend */],
                [/*start*/ 0x6EE, /*end*/ 0x6EF, 11 /* ALetter */],
                [/*start*/ 0x6F0, /*end*/ 0x6F9, 9 /* Numeric */],
                [/*start*/ 0x6FA, /*end*/ 0x6FC, 11 /* ALetter */],
                [/*start*/ 0x6FF, /*end*/ 0x6FF, 11 /* ALetter */],
                [/*start*/ 0x70F, /*end*/ 0x70F, 13 /* Format */],
                [/*start*/ 0x710, /*end*/ 0x710, 11 /* ALetter */],
                [/*start*/ 0x711, /*end*/ 0x711, 14 /* Extend */],
                [/*start*/ 0x712, /*end*/ 0x72F, 11 /* ALetter */],
                [/*start*/ 0x730, /*end*/ 0x74A, 14 /* Extend */],
                [/*start*/ 0x74D, /*end*/ 0x7A5, 11 /* ALetter */],
                [/*start*/ 0x7A6, /*end*/ 0x7B0, 14 /* Extend */],
                [/*start*/ 0x7B1, /*end*/ 0x7B1, 11 /* ALetter */],
                [/*start*/ 0x7C0, /*end*/ 0x7C9, 9 /* Numeric */],
                [/*start*/ 0x7CA, /*end*/ 0x7EA, 11 /* ALetter */],
                [/*start*/ 0x7EB, /*end*/ 0x7F3, 14 /* Extend */],
                [/*start*/ 0x7F4, /*end*/ 0x7F5, 11 /* ALetter */],
                [/*start*/ 0x7F8, /*end*/ 0x7F8, 7 /* MidNum */],
                [/*start*/ 0x7FA, /*end*/ 0x7FA, 11 /* ALetter */],
                [/*start*/ 0x7FD, /*end*/ 0x7FD, 14 /* Extend */],
                [/*start*/ 0x800, /*end*/ 0x815, 11 /* ALetter */],
                [/*start*/ 0x816, /*end*/ 0x819, 14 /* Extend */],
                [/*start*/ 0x81A, /*end*/ 0x81A, 11 /* ALetter */],
                [/*start*/ 0x81B, /*end*/ 0x823, 14 /* Extend */],
                [/*start*/ 0x824, /*end*/ 0x824, 11 /* ALetter */],
                [/*start*/ 0x825, /*end*/ 0x827, 14 /* Extend */],
                [/*start*/ 0x828, /*end*/ 0x828, 11 /* ALetter */],
                [/*start*/ 0x829, /*end*/ 0x82D, 14 /* Extend */],
                [/*start*/ 0x840, /*end*/ 0x858, 11 /* ALetter */],
                [/*start*/ 0x859, /*end*/ 0x85B, 14 /* Extend */],
                [/*start*/ 0x860, /*end*/ 0x86A, 11 /* ALetter */],
                [/*start*/ 0x8A0, /*end*/ 0x8B4, 11 /* ALetter */],
                [/*start*/ 0x8B6, /*end*/ 0x8BD, 11 /* ALetter */],
                [/*start*/ 0x8D3, /*end*/ 0x8E1, 14 /* Extend */],
                [/*start*/ 0x8E2, /*end*/ 0x8E2, 13 /* Format */],
                [/*start*/ 0x8E3, /*end*/ 0x902, 14 /* Extend */],
                [/*start*/ 0x903, /*end*/ 0x903, 14 /* Extend */],
                [/*start*/ 0x904, /*end*/ 0x939, 11 /* ALetter */],
                [/*start*/ 0x93A, /*end*/ 0x93A, 14 /* Extend */],
                [/*start*/ 0x93B, /*end*/ 0x93B, 14 /* Extend */],
                [/*start*/ 0x93C, /*end*/ 0x93C, 14 /* Extend */],
                [/*start*/ 0x93D, /*end*/ 0x93D, 11 /* ALetter */],
                [/*start*/ 0x93E, /*end*/ 0x940, 14 /* Extend */],
                [/*start*/ 0x941, /*end*/ 0x948, 14 /* Extend */],
                [/*start*/ 0x949, /*end*/ 0x94C, 14 /* Extend */],
                [/*start*/ 0x94D, /*end*/ 0x94D, 14 /* Extend */],
                [/*start*/ 0x94E, /*end*/ 0x94F, 14 /* Extend */],
                [/*start*/ 0x950, /*end*/ 0x950, 11 /* ALetter */],
                [/*start*/ 0x951, /*end*/ 0x957, 14 /* Extend */],
                [/*start*/ 0x958, /*end*/ 0x961, 11 /* ALetter */],
                [/*start*/ 0x962, /*end*/ 0x963, 14 /* Extend */],
                [/*start*/ 0x966, /*end*/ 0x96F, 9 /* Numeric */],
                [/*start*/ 0x971, /*end*/ 0x971, 11 /* ALetter */],
                [/*start*/ 0x972, /*end*/ 0x980, 11 /* ALetter */],
                [/*start*/ 0x981, /*end*/ 0x981, 14 /* Extend */],
                [/*start*/ 0x982, /*end*/ 0x983, 14 /* Extend */],
                [/*start*/ 0x985, /*end*/ 0x98C, 11 /* ALetter */],
                [/*start*/ 0x98F, /*end*/ 0x990, 11 /* ALetter */],
                [/*start*/ 0x993, /*end*/ 0x9A8, 11 /* ALetter */],
                [/*start*/ 0x9AA, /*end*/ 0x9B0, 11 /* ALetter */],
                [/*start*/ 0x9B2, /*end*/ 0x9B2, 11 /* ALetter */],
                [/*start*/ 0x9B6, /*end*/ 0x9B9, 11 /* ALetter */],
                [/*start*/ 0x9BC, /*end*/ 0x9BC, 14 /* Extend */],
                [/*start*/ 0x9BD, /*end*/ 0x9BD, 11 /* ALetter */],
                [/*start*/ 0x9BE, /*end*/ 0x9C0, 14 /* Extend */],
                [/*start*/ 0x9C1, /*end*/ 0x9C4, 14 /* Extend */],
                [/*start*/ 0x9C7, /*end*/ 0x9C8, 14 /* Extend */],
                [/*start*/ 0x9CB, /*end*/ 0x9CC, 14 /* Extend */],
                [/*start*/ 0x9CD, /*end*/ 0x9CD, 14 /* Extend */],
                [/*start*/ 0x9CE, /*end*/ 0x9CE, 11 /* ALetter */],
                [/*start*/ 0x9D7, /*end*/ 0x9D7, 14 /* Extend */],
                [/*start*/ 0x9DC, /*end*/ 0x9DD, 11 /* ALetter */],
                [/*start*/ 0x9DF, /*end*/ 0x9E1, 11 /* ALetter */],
                [/*start*/ 0x9E2, /*end*/ 0x9E3, 14 /* Extend */],
                [/*start*/ 0x9E6, /*end*/ 0x9EF, 9 /* Numeric */],
                [/*start*/ 0x9F0, /*end*/ 0x9F1, 11 /* ALetter */],
                [/*start*/ 0x9FC, /*end*/ 0x9FC, 11 /* ALetter */],
                [/*start*/ 0x9FE, /*end*/ 0x9FE, 14 /* Extend */],
                [/*start*/ 0xA01, /*end*/ 0xA02, 14 /* Extend */],
                [/*start*/ 0xA03, /*end*/ 0xA03, 14 /* Extend */],
                [/*start*/ 0xA05, /*end*/ 0xA0A, 11 /* ALetter */],
                [/*start*/ 0xA0F, /*end*/ 0xA10, 11 /* ALetter */],
                [/*start*/ 0xA13, /*end*/ 0xA28, 11 /* ALetter */],
                [/*start*/ 0xA2A, /*end*/ 0xA30, 11 /* ALetter */],
                [/*start*/ 0xA32, /*end*/ 0xA33, 11 /* ALetter */],
                [/*start*/ 0xA35, /*end*/ 0xA36, 11 /* ALetter */],
                [/*start*/ 0xA38, /*end*/ 0xA39, 11 /* ALetter */],
                [/*start*/ 0xA3C, /*end*/ 0xA3C, 14 /* Extend */],
                [/*start*/ 0xA3E, /*end*/ 0xA40, 14 /* Extend */],
                [/*start*/ 0xA41, /*end*/ 0xA42, 14 /* Extend */],
                [/*start*/ 0xA47, /*end*/ 0xA48, 14 /* Extend */],
                [/*start*/ 0xA4B, /*end*/ 0xA4D, 14 /* Extend */],
                [/*start*/ 0xA51, /*end*/ 0xA51, 14 /* Extend */],
                [/*start*/ 0xA59, /*end*/ 0xA5C, 11 /* ALetter */],
                [/*start*/ 0xA5E, /*end*/ 0xA5E, 11 /* ALetter */],
                [/*start*/ 0xA66, /*end*/ 0xA6F, 9 /* Numeric */],
                [/*start*/ 0xA70, /*end*/ 0xA71, 14 /* Extend */],
                [/*start*/ 0xA72, /*end*/ 0xA74, 11 /* ALetter */],
                [/*start*/ 0xA75, /*end*/ 0xA75, 14 /* Extend */],
                [/*start*/ 0xA81, /*end*/ 0xA82, 14 /* Extend */],
                [/*start*/ 0xA83, /*end*/ 0xA83, 14 /* Extend */],
                [/*start*/ 0xA85, /*end*/ 0xA8D, 11 /* ALetter */],
                [/*start*/ 0xA8F, /*end*/ 0xA91, 11 /* ALetter */],
                [/*start*/ 0xA93, /*end*/ 0xAA8, 11 /* ALetter */],
                [/*start*/ 0xAAA, /*end*/ 0xAB0, 11 /* ALetter */],
                [/*start*/ 0xAB2, /*end*/ 0xAB3, 11 /* ALetter */],
                [/*start*/ 0xAB5, /*end*/ 0xAB9, 11 /* ALetter */],
                [/*start*/ 0xABC, /*end*/ 0xABC, 14 /* Extend */],
                [/*start*/ 0xABD, /*end*/ 0xABD, 11 /* ALetter */],
                [/*start*/ 0xABE, /*end*/ 0xAC0, 14 /* Extend */],
                [/*start*/ 0xAC1, /*end*/ 0xAC5, 14 /* Extend */],
                [/*start*/ 0xAC7, /*end*/ 0xAC8, 14 /* Extend */],
                [/*start*/ 0xAC9, /*end*/ 0xAC9, 14 /* Extend */],
                [/*start*/ 0xACB, /*end*/ 0xACC, 14 /* Extend */],
                [/*start*/ 0xACD, /*end*/ 0xACD, 14 /* Extend */],
                [/*start*/ 0xAD0, /*end*/ 0xAD0, 11 /* ALetter */],
                [/*start*/ 0xAE0, /*end*/ 0xAE1, 11 /* ALetter */],
                [/*start*/ 0xAE2, /*end*/ 0xAE3, 14 /* Extend */],
                [/*start*/ 0xAE6, /*end*/ 0xAEF, 9 /* Numeric */],
                [/*start*/ 0xAF9, /*end*/ 0xAF9, 11 /* ALetter */],
                [/*start*/ 0xAFA, /*end*/ 0xAFF, 14 /* Extend */],
                [/*start*/ 0xB01, /*end*/ 0xB01, 14 /* Extend */],
                [/*start*/ 0xB02, /*end*/ 0xB03, 14 /* Extend */],
                [/*start*/ 0xB05, /*end*/ 0xB0C, 11 /* ALetter */],
                [/*start*/ 0xB0F, /*end*/ 0xB10, 11 /* ALetter */],
                [/*start*/ 0xB13, /*end*/ 0xB28, 11 /* ALetter */],
                [/*start*/ 0xB2A, /*end*/ 0xB30, 11 /* ALetter */],
                [/*start*/ 0xB32, /*end*/ 0xB33, 11 /* ALetter */],
                [/*start*/ 0xB35, /*end*/ 0xB39, 11 /* ALetter */],
                [/*start*/ 0xB3C, /*end*/ 0xB3C, 14 /* Extend */],
                [/*start*/ 0xB3D, /*end*/ 0xB3D, 11 /* ALetter */],
                [/*start*/ 0xB3E, /*end*/ 0xB3E, 14 /* Extend */],
                [/*start*/ 0xB3F, /*end*/ 0xB3F, 14 /* Extend */],
                [/*start*/ 0xB40, /*end*/ 0xB40, 14 /* Extend */],
                [/*start*/ 0xB41, /*end*/ 0xB44, 14 /* Extend */],
                [/*start*/ 0xB47, /*end*/ 0xB48, 14 /* Extend */],
                [/*start*/ 0xB4B, /*end*/ 0xB4C, 14 /* Extend */],
                [/*start*/ 0xB4D, /*end*/ 0xB4D, 14 /* Extend */],
                [/*start*/ 0xB56, /*end*/ 0xB56, 14 /* Extend */],
                [/*start*/ 0xB57, /*end*/ 0xB57, 14 /* Extend */],
                [/*start*/ 0xB5C, /*end*/ 0xB5D, 11 /* ALetter */],
                [/*start*/ 0xB5F, /*end*/ 0xB61, 11 /* ALetter */],
                [/*start*/ 0xB62, /*end*/ 0xB63, 14 /* Extend */],
                [/*start*/ 0xB66, /*end*/ 0xB6F, 9 /* Numeric */],
                [/*start*/ 0xB71, /*end*/ 0xB71, 11 /* ALetter */],
                [/*start*/ 0xB82, /*end*/ 0xB82, 14 /* Extend */],
                [/*start*/ 0xB83, /*end*/ 0xB83, 11 /* ALetter */],
                [/*start*/ 0xB85, /*end*/ 0xB8A, 11 /* ALetter */],
                [/*start*/ 0xB8E, /*end*/ 0xB90, 11 /* ALetter */],
                [/*start*/ 0xB92, /*end*/ 0xB95, 11 /* ALetter */],
                [/*start*/ 0xB99, /*end*/ 0xB9A, 11 /* ALetter */],
                [/*start*/ 0xB9C, /*end*/ 0xB9C, 11 /* ALetter */],
                [/*start*/ 0xB9E, /*end*/ 0xB9F, 11 /* ALetter */],
                [/*start*/ 0xBA3, /*end*/ 0xBA4, 11 /* ALetter */],
                [/*start*/ 0xBA8, /*end*/ 0xBAA, 11 /* ALetter */],
                [/*start*/ 0xBAE, /*end*/ 0xBB9, 11 /* ALetter */],
                [/*start*/ 0xBBE, /*end*/ 0xBBF, 14 /* Extend */],
                [/*start*/ 0xBC0, /*end*/ 0xBC0, 14 /* Extend */],
                [/*start*/ 0xBC1, /*end*/ 0xBC2, 14 /* Extend */],
                [/*start*/ 0xBC6, /*end*/ 0xBC8, 14 /* Extend */],
                [/*start*/ 0xBCA, /*end*/ 0xBCC, 14 /* Extend */],
                [/*start*/ 0xBCD, /*end*/ 0xBCD, 14 /* Extend */],
                [/*start*/ 0xBD0, /*end*/ 0xBD0, 11 /* ALetter */],
                [/*start*/ 0xBD7, /*end*/ 0xBD7, 14 /* Extend */],
                [/*start*/ 0xBE6, /*end*/ 0xBEF, 9 /* Numeric */],
                [/*start*/ 0xC00, /*end*/ 0xC00, 14 /* Extend */],
                [/*start*/ 0xC01, /*end*/ 0xC03, 14 /* Extend */],
                [/*start*/ 0xC04, /*end*/ 0xC04, 14 /* Extend */],
                [/*start*/ 0xC05, /*end*/ 0xC0C, 11 /* ALetter */],
                [/*start*/ 0xC0E, /*end*/ 0xC10, 11 /* ALetter */],
                [/*start*/ 0xC12, /*end*/ 0xC28, 11 /* ALetter */],
                [/*start*/ 0xC2A, /*end*/ 0xC39, 11 /* ALetter */],
                [/*start*/ 0xC3D, /*end*/ 0xC3D, 11 /* ALetter */],
                [/*start*/ 0xC3E, /*end*/ 0xC40, 14 /* Extend */],
                [/*start*/ 0xC41, /*end*/ 0xC44, 14 /* Extend */],
                [/*start*/ 0xC46, /*end*/ 0xC48, 14 /* Extend */],
                [/*start*/ 0xC4A, /*end*/ 0xC4D, 14 /* Extend */],
                [/*start*/ 0xC55, /*end*/ 0xC56, 14 /* Extend */],
                [/*start*/ 0xC58, /*end*/ 0xC5A, 11 /* ALetter */],
                [/*start*/ 0xC60, /*end*/ 0xC61, 11 /* ALetter */],
                [/*start*/ 0xC62, /*end*/ 0xC63, 14 /* Extend */],
                [/*start*/ 0xC66, /*end*/ 0xC6F, 9 /* Numeric */],
                [/*start*/ 0xC80, /*end*/ 0xC80, 11 /* ALetter */],
                [/*start*/ 0xC81, /*end*/ 0xC81, 14 /* Extend */],
                [/*start*/ 0xC82, /*end*/ 0xC83, 14 /* Extend */],
                [/*start*/ 0xC85, /*end*/ 0xC8C, 11 /* ALetter */],
                [/*start*/ 0xC8E, /*end*/ 0xC90, 11 /* ALetter */],
                [/*start*/ 0xC92, /*end*/ 0xCA8, 11 /* ALetter */],
                [/*start*/ 0xCAA, /*end*/ 0xCB3, 11 /* ALetter */],
                [/*start*/ 0xCB5, /*end*/ 0xCB9, 11 /* ALetter */],
                [/*start*/ 0xCBC, /*end*/ 0xCBC, 14 /* Extend */],
                [/*start*/ 0xCBD, /*end*/ 0xCBD, 11 /* ALetter */],
                [/*start*/ 0xCBE, /*end*/ 0xCBE, 14 /* Extend */],
                [/*start*/ 0xCBF, /*end*/ 0xCBF, 14 /* Extend */],
                [/*start*/ 0xCC0, /*end*/ 0xCC4, 14 /* Extend */],
                [/*start*/ 0xCC6, /*end*/ 0xCC6, 14 /* Extend */],
                [/*start*/ 0xCC7, /*end*/ 0xCC8, 14 /* Extend */],
                [/*start*/ 0xCCA, /*end*/ 0xCCB, 14 /* Extend */],
                [/*start*/ 0xCCC, /*end*/ 0xCCD, 14 /* Extend */],
                [/*start*/ 0xCD5, /*end*/ 0xCD6, 14 /* Extend */],
                [/*start*/ 0xCDE, /*end*/ 0xCDE, 11 /* ALetter */],
                [/*start*/ 0xCE0, /*end*/ 0xCE1, 11 /* ALetter */],
                [/*start*/ 0xCE2, /*end*/ 0xCE3, 14 /* Extend */],
                [/*start*/ 0xCE6, /*end*/ 0xCEF, 9 /* Numeric */],
                [/*start*/ 0xCF1, /*end*/ 0xCF2, 11 /* ALetter */],
                [/*start*/ 0xD00, /*end*/ 0xD01, 14 /* Extend */],
                [/*start*/ 0xD02, /*end*/ 0xD03, 14 /* Extend */],
                [/*start*/ 0xD05, /*end*/ 0xD0C, 11 /* ALetter */],
                [/*start*/ 0xD0E, /*end*/ 0xD10, 11 /* ALetter */],
                [/*start*/ 0xD12, /*end*/ 0xD3A, 11 /* ALetter */],
                [/*start*/ 0xD3B, /*end*/ 0xD3C, 14 /* Extend */],
                [/*start*/ 0xD3D, /*end*/ 0xD3D, 11 /* ALetter */],
                [/*start*/ 0xD3E, /*end*/ 0xD40, 14 /* Extend */],
                [/*start*/ 0xD41, /*end*/ 0xD44, 14 /* Extend */],
                [/*start*/ 0xD46, /*end*/ 0xD48, 14 /* Extend */],
                [/*start*/ 0xD4A, /*end*/ 0xD4C, 14 /* Extend */],
                [/*start*/ 0xD4D, /*end*/ 0xD4D, 14 /* Extend */],
                [/*start*/ 0xD4E, /*end*/ 0xD4E, 11 /* ALetter */],
                [/*start*/ 0xD54, /*end*/ 0xD56, 11 /* ALetter */],
                [/*start*/ 0xD57, /*end*/ 0xD57, 14 /* Extend */],
                [/*start*/ 0xD5F, /*end*/ 0xD61, 11 /* ALetter */],
                [/*start*/ 0xD62, /*end*/ 0xD63, 14 /* Extend */],
                [/*start*/ 0xD66, /*end*/ 0xD6F, 9 /* Numeric */],
                [/*start*/ 0xD7A, /*end*/ 0xD7F, 11 /* ALetter */],
                [/*start*/ 0xD82, /*end*/ 0xD83, 14 /* Extend */],
                [/*start*/ 0xD85, /*end*/ 0xD96, 11 /* ALetter */],
                [/*start*/ 0xD9A, /*end*/ 0xDB1, 11 /* ALetter */],
                [/*start*/ 0xDB3, /*end*/ 0xDBB, 11 /* ALetter */],
                [/*start*/ 0xDBD, /*end*/ 0xDBD, 11 /* ALetter */],
                [/*start*/ 0xDC0, /*end*/ 0xDC6, 11 /* ALetter */],
                [/*start*/ 0xDCA, /*end*/ 0xDCA, 14 /* Extend */],
                [/*start*/ 0xDCF, /*end*/ 0xDD1, 14 /* Extend */],
                [/*start*/ 0xDD2, /*end*/ 0xDD4, 14 /* Extend */],
                [/*start*/ 0xDD6, /*end*/ 0xDD6, 14 /* Extend */],
                [/*start*/ 0xDD8, /*end*/ 0xDDF, 14 /* Extend */],
                [/*start*/ 0xDE6, /*end*/ 0xDEF, 9 /* Numeric */],
                [/*start*/ 0xDF2, /*end*/ 0xDF3, 14 /* Extend */],
                [/*start*/ 0xE31, /*end*/ 0xE31, 14 /* Extend */],
                [/*start*/ 0xE34, /*end*/ 0xE3A, 14 /* Extend */],
                [/*start*/ 0xE47, /*end*/ 0xE4E, 14 /* Extend */],
                [/*start*/ 0xE50, /*end*/ 0xE59, 9 /* Numeric */],
                [/*start*/ 0xEB1, /*end*/ 0xEB1, 14 /* Extend */],
                [/*start*/ 0xEB4, /*end*/ 0xEBC, 14 /* Extend */],
                [/*start*/ 0xEC8, /*end*/ 0xECD, 14 /* Extend */],
                [/*start*/ 0xED0, /*end*/ 0xED9, 9 /* Numeric */],
                [/*start*/ 0xF00, /*end*/ 0xF00, 11 /* ALetter */],
                [/*start*/ 0xF18, /*end*/ 0xF19, 14 /* Extend */],
                [/*start*/ 0xF20, /*end*/ 0xF29, 9 /* Numeric */],
                [/*start*/ 0xF35, /*end*/ 0xF35, 14 /* Extend */],
                [/*start*/ 0xF37, /*end*/ 0xF37, 14 /* Extend */],
                [/*start*/ 0xF39, /*end*/ 0xF39, 14 /* Extend */],
                [/*start*/ 0xF3E, /*end*/ 0xF3F, 14 /* Extend */],
                [/*start*/ 0xF40, /*end*/ 0xF47, 11 /* ALetter */],
                [/*start*/ 0xF49, /*end*/ 0xF6C, 11 /* ALetter */],
                [/*start*/ 0xF71, /*end*/ 0xF7E, 14 /* Extend */],
                [/*start*/ 0xF7F, /*end*/ 0xF7F, 14 /* Extend */],
                [/*start*/ 0xF80, /*end*/ 0xF84, 14 /* Extend */],
                [/*start*/ 0xF86, /*end*/ 0xF87, 14 /* Extend */],
                [/*start*/ 0xF88, /*end*/ 0xF8C, 11 /* ALetter */],
                [/*start*/ 0xF8D, /*end*/ 0xF97, 14 /* Extend */],
                [/*start*/ 0xF99, /*end*/ 0xFBC, 14 /* Extend */],
                [/*start*/ 0xFC6, /*end*/ 0xFC6, 14 /* Extend */],
                [/*start*/ 0x102B, /*end*/ 0x102C, 14 /* Extend */],
                [/*start*/ 0x102D, /*end*/ 0x1030, 14 /* Extend */],
                [/*start*/ 0x1031, /*end*/ 0x1031, 14 /* Extend */],
                [/*start*/ 0x1032, /*end*/ 0x1037, 14 /* Extend */],
                [/*start*/ 0x1038, /*end*/ 0x1038, 14 /* Extend */],
                [/*start*/ 0x1039, /*end*/ 0x103A, 14 /* Extend */],
                [/*start*/ 0x103B, /*end*/ 0x103C, 14 /* Extend */],
                [/*start*/ 0x103D, /*end*/ 0x103E, 14 /* Extend */],
                [/*start*/ 0x1040, /*end*/ 0x1049, 9 /* Numeric */],
                [/*start*/ 0x1056, /*end*/ 0x1057, 14 /* Extend */],
                [/*start*/ 0x1058, /*end*/ 0x1059, 14 /* Extend */],
                [/*start*/ 0x105E, /*end*/ 0x1060, 14 /* Extend */],
                [/*start*/ 0x1062, /*end*/ 0x1064, 14 /* Extend */],
                [/*start*/ 0x1067, /*end*/ 0x106D, 14 /* Extend */],
                [/*start*/ 0x1071, /*end*/ 0x1074, 14 /* Extend */],
                [/*start*/ 0x1082, /*end*/ 0x1082, 14 /* Extend */],
                [/*start*/ 0x1083, /*end*/ 0x1084, 14 /* Extend */],
                [/*start*/ 0x1085, /*end*/ 0x1086, 14 /* Extend */],
                [/*start*/ 0x1087, /*end*/ 0x108C, 14 /* Extend */],
                [/*start*/ 0x108D, /*end*/ 0x108D, 14 /* Extend */],
                [/*start*/ 0x108F, /*end*/ 0x108F, 14 /* Extend */],
                [/*start*/ 0x1090, /*end*/ 0x1099, 9 /* Numeric */],
                [/*start*/ 0x109A, /*end*/ 0x109C, 14 /* Extend */],
                [/*start*/ 0x109D, /*end*/ 0x109D, 14 /* Extend */],
                [/*start*/ 0x10A0, /*end*/ 0x10C5, 11 /* ALetter */],
                [/*start*/ 0x10C7, /*end*/ 0x10C7, 11 /* ALetter */],
                [/*start*/ 0x10CD, /*end*/ 0x10CD, 11 /* ALetter */],
                [/*start*/ 0x10D0, /*end*/ 0x10FA, 11 /* ALetter */],
                [/*start*/ 0x10FC, /*end*/ 0x10FC, 11 /* ALetter */],
                [/*start*/ 0x10FD, /*end*/ 0x10FF, 11 /* ALetter */],
                [/*start*/ 0x1100, /*end*/ 0x1248, 11 /* ALetter */],
                [/*start*/ 0x124A, /*end*/ 0x124D, 11 /* ALetter */],
                [/*start*/ 0x1250, /*end*/ 0x1256, 11 /* ALetter */],
                [/*start*/ 0x1258, /*end*/ 0x1258, 11 /* ALetter */],
                [/*start*/ 0x125A, /*end*/ 0x125D, 11 /* ALetter */],
                [/*start*/ 0x1260, /*end*/ 0x1288, 11 /* ALetter */],
                [/*start*/ 0x128A, /*end*/ 0x128D, 11 /* ALetter */],
                [/*start*/ 0x1290, /*end*/ 0x12B0, 11 /* ALetter */],
                [/*start*/ 0x12B2, /*end*/ 0x12B5, 11 /* ALetter */],
                [/*start*/ 0x12B8, /*end*/ 0x12BE, 11 /* ALetter */],
                [/*start*/ 0x12C0, /*end*/ 0x12C0, 11 /* ALetter */],
                [/*start*/ 0x12C2, /*end*/ 0x12C5, 11 /* ALetter */],
                [/*start*/ 0x12C8, /*end*/ 0x12D6, 11 /* ALetter */],
                [/*start*/ 0x12D8, /*end*/ 0x1310, 11 /* ALetter */],
                [/*start*/ 0x1312, /*end*/ 0x1315, 11 /* ALetter */],
                [/*start*/ 0x1318, /*end*/ 0x135A, 11 /* ALetter */],
                [/*start*/ 0x135D, /*end*/ 0x135F, 14 /* Extend */],
                [/*start*/ 0x1380, /*end*/ 0x138F, 11 /* ALetter */],
                [/*start*/ 0x13A0, /*end*/ 0x13F5, 11 /* ALetter */],
                [/*start*/ 0x13F8, /*end*/ 0x13FD, 11 /* ALetter */],
                [/*start*/ 0x1401, /*end*/ 0x166C, 11 /* ALetter */],
                [/*start*/ 0x166F, /*end*/ 0x167F, 11 /* ALetter */],
                [/*start*/ 0x1680, /*end*/ 0x1680, 4 /* WSegSpace */],
                [/*start*/ 0x1681, /*end*/ 0x169A, 11 /* ALetter */],
                [/*start*/ 0x16A0, /*end*/ 0x16EA, 11 /* ALetter */],
                [/*start*/ 0x16EE, /*end*/ 0x16F0, 11 /* ALetter */],
                [/*start*/ 0x16F1, /*end*/ 0x16F8, 11 /* ALetter */],
                [/*start*/ 0x1700, /*end*/ 0x170C, 11 /* ALetter */],
                [/*start*/ 0x170E, /*end*/ 0x1711, 11 /* ALetter */],
                [/*start*/ 0x1712, /*end*/ 0x1714, 14 /* Extend */],
                [/*start*/ 0x1720, /*end*/ 0x1731, 11 /* ALetter */],
                [/*start*/ 0x1732, /*end*/ 0x1734, 14 /* Extend */],
                [/*start*/ 0x1740, /*end*/ 0x1751, 11 /* ALetter */],
                [/*start*/ 0x1752, /*end*/ 0x1753, 14 /* Extend */],
                [/*start*/ 0x1760, /*end*/ 0x176C, 11 /* ALetter */],
                [/*start*/ 0x176E, /*end*/ 0x1770, 11 /* ALetter */],
                [/*start*/ 0x1772, /*end*/ 0x1773, 14 /* Extend */],
                [/*start*/ 0x17B4, /*end*/ 0x17B5, 14 /* Extend */],
                [/*start*/ 0x17B6, /*end*/ 0x17B6, 14 /* Extend */],
                [/*start*/ 0x17B7, /*end*/ 0x17BD, 14 /* Extend */],
                [/*start*/ 0x17BE, /*end*/ 0x17C5, 14 /* Extend */],
                [/*start*/ 0x17C6, /*end*/ 0x17C6, 14 /* Extend */],
                [/*start*/ 0x17C7, /*end*/ 0x17C8, 14 /* Extend */],
                [/*start*/ 0x17C9, /*end*/ 0x17D3, 14 /* Extend */],
                [/*start*/ 0x17DD, /*end*/ 0x17DD, 14 /* Extend */],
                [/*start*/ 0x17E0, /*end*/ 0x17E9, 9 /* Numeric */],
                [/*start*/ 0x180B, /*end*/ 0x180D, 14 /* Extend */],
                [/*start*/ 0x180E, /*end*/ 0x180E, 13 /* Format */],
                [/*start*/ 0x1810, /*end*/ 0x1819, 9 /* Numeric */],
                [/*start*/ 0x1820, /*end*/ 0x1842, 11 /* ALetter */],
                [/*start*/ 0x1843, /*end*/ 0x1843, 11 /* ALetter */],
                [/*start*/ 0x1844, /*end*/ 0x1878, 11 /* ALetter */],
                [/*start*/ 0x1880, /*end*/ 0x1884, 11 /* ALetter */],
                [/*start*/ 0x1885, /*end*/ 0x1886, 14 /* Extend */],
                [/*start*/ 0x1887, /*end*/ 0x18A8, 11 /* ALetter */],
                [/*start*/ 0x18A9, /*end*/ 0x18A9, 14 /* Extend */],
                [/*start*/ 0x18AA, /*end*/ 0x18AA, 11 /* ALetter */],
                [/*start*/ 0x18B0, /*end*/ 0x18F5, 11 /* ALetter */],
                [/*start*/ 0x1900, /*end*/ 0x191E, 11 /* ALetter */],
                [/*start*/ 0x1920, /*end*/ 0x1922, 14 /* Extend */],
                [/*start*/ 0x1923, /*end*/ 0x1926, 14 /* Extend */],
                [/*start*/ 0x1927, /*end*/ 0x1928, 14 /* Extend */],
                [/*start*/ 0x1929, /*end*/ 0x192B, 14 /* Extend */],
                [/*start*/ 0x1930, /*end*/ 0x1931, 14 /* Extend */],
                [/*start*/ 0x1932, /*end*/ 0x1932, 14 /* Extend */],
                [/*start*/ 0x1933, /*end*/ 0x1938, 14 /* Extend */],
                [/*start*/ 0x1939, /*end*/ 0x193B, 14 /* Extend */],
                [/*start*/ 0x1946, /*end*/ 0x194F, 9 /* Numeric */],
                [/*start*/ 0x19D0, /*end*/ 0x19D9, 9 /* Numeric */],
                [/*start*/ 0x1A00, /*end*/ 0x1A16, 11 /* ALetter */],
                [/*start*/ 0x1A17, /*end*/ 0x1A18, 14 /* Extend */],
                [/*start*/ 0x1A19, /*end*/ 0x1A1A, 14 /* Extend */],
                [/*start*/ 0x1A1B, /*end*/ 0x1A1B, 14 /* Extend */],
                [/*start*/ 0x1A55, /*end*/ 0x1A55, 14 /* Extend */],
                [/*start*/ 0x1A56, /*end*/ 0x1A56, 14 /* Extend */],
                [/*start*/ 0x1A57, /*end*/ 0x1A57, 14 /* Extend */],
                [/*start*/ 0x1A58, /*end*/ 0x1A5E, 14 /* Extend */],
                [/*start*/ 0x1A60, /*end*/ 0x1A60, 14 /* Extend */],
                [/*start*/ 0x1A61, /*end*/ 0x1A61, 14 /* Extend */],
                [/*start*/ 0x1A62, /*end*/ 0x1A62, 14 /* Extend */],
                [/*start*/ 0x1A63, /*end*/ 0x1A64, 14 /* Extend */],
                [/*start*/ 0x1A65, /*end*/ 0x1A6C, 14 /* Extend */],
                [/*start*/ 0x1A6D, /*end*/ 0x1A72, 14 /* Extend */],
                [/*start*/ 0x1A73, /*end*/ 0x1A7C, 14 /* Extend */],
                [/*start*/ 0x1A7F, /*end*/ 0x1A7F, 14 /* Extend */],
                [/*start*/ 0x1A80, /*end*/ 0x1A89, 9 /* Numeric */],
                [/*start*/ 0x1A90, /*end*/ 0x1A99, 9 /* Numeric */],
                [/*start*/ 0x1AB0, /*end*/ 0x1ABD, 14 /* Extend */],
                [/*start*/ 0x1ABE, /*end*/ 0x1ABE, 14 /* Extend */],
                [/*start*/ 0x1B00, /*end*/ 0x1B03, 14 /* Extend */],
                [/*start*/ 0x1B04, /*end*/ 0x1B04, 14 /* Extend */],
                [/*start*/ 0x1B05, /*end*/ 0x1B33, 11 /* ALetter */],
                [/*start*/ 0x1B34, /*end*/ 0x1B34, 14 /* Extend */],
                [/*start*/ 0x1B35, /*end*/ 0x1B35, 14 /* Extend */],
                [/*start*/ 0x1B36, /*end*/ 0x1B3A, 14 /* Extend */],
                [/*start*/ 0x1B3B, /*end*/ 0x1B3B, 14 /* Extend */],
                [/*start*/ 0x1B3C, /*end*/ 0x1B3C, 14 /* Extend */],
                [/*start*/ 0x1B3D, /*end*/ 0x1B41, 14 /* Extend */],
                [/*start*/ 0x1B42, /*end*/ 0x1B42, 14 /* Extend */],
                [/*start*/ 0x1B43, /*end*/ 0x1B44, 14 /* Extend */],
                [/*start*/ 0x1B45, /*end*/ 0x1B4B, 11 /* ALetter */],
                [/*start*/ 0x1B50, /*end*/ 0x1B59, 9 /* Numeric */],
                [/*start*/ 0x1B6B, /*end*/ 0x1B73, 14 /* Extend */],
                [/*start*/ 0x1B80, /*end*/ 0x1B81, 14 /* Extend */],
                [/*start*/ 0x1B82, /*end*/ 0x1B82, 14 /* Extend */],
                [/*start*/ 0x1B83, /*end*/ 0x1BA0, 11 /* ALetter */],
                [/*start*/ 0x1BA1, /*end*/ 0x1BA1, 14 /* Extend */],
                [/*start*/ 0x1BA2, /*end*/ 0x1BA5, 14 /* Extend */],
                [/*start*/ 0x1BA6, /*end*/ 0x1BA7, 14 /* Extend */],
                [/*start*/ 0x1BA8, /*end*/ 0x1BA9, 14 /* Extend */],
                [/*start*/ 0x1BAA, /*end*/ 0x1BAA, 14 /* Extend */],
                [/*start*/ 0x1BAB, /*end*/ 0x1BAD, 14 /* Extend */],
                [/*start*/ 0x1BAE, /*end*/ 0x1BAF, 11 /* ALetter */],
                [/*start*/ 0x1BB0, /*end*/ 0x1BB9, 9 /* Numeric */],
                [/*start*/ 0x1BBA, /*end*/ 0x1BE5, 11 /* ALetter */],
                [/*start*/ 0x1BE6, /*end*/ 0x1BE6, 14 /* Extend */],
                [/*start*/ 0x1BE7, /*end*/ 0x1BE7, 14 /* Extend */],
                [/*start*/ 0x1BE8, /*end*/ 0x1BE9, 14 /* Extend */],
                [/*start*/ 0x1BEA, /*end*/ 0x1BEC, 14 /* Extend */],
                [/*start*/ 0x1BED, /*end*/ 0x1BED, 14 /* Extend */],
                [/*start*/ 0x1BEE, /*end*/ 0x1BEE, 14 /* Extend */],
                [/*start*/ 0x1BEF, /*end*/ 0x1BF1, 14 /* Extend */],
                [/*start*/ 0x1BF2, /*end*/ 0x1BF3, 14 /* Extend */],
                [/*start*/ 0x1C00, /*end*/ 0x1C23, 11 /* ALetter */],
                [/*start*/ 0x1C24, /*end*/ 0x1C2B, 14 /* Extend */],
                [/*start*/ 0x1C2C, /*end*/ 0x1C33, 14 /* Extend */],
                [/*start*/ 0x1C34, /*end*/ 0x1C35, 14 /* Extend */],
                [/*start*/ 0x1C36, /*end*/ 0x1C37, 14 /* Extend */],
                [/*start*/ 0x1C40, /*end*/ 0x1C49, 9 /* Numeric */],
                [/*start*/ 0x1C4D, /*end*/ 0x1C4F, 11 /* ALetter */],
                [/*start*/ 0x1C50, /*end*/ 0x1C59, 9 /* Numeric */],
                [/*start*/ 0x1C5A, /*end*/ 0x1C77, 11 /* ALetter */],
                [/*start*/ 0x1C78, /*end*/ 0x1C7D, 11 /* ALetter */],
                [/*start*/ 0x1C80, /*end*/ 0x1C88, 11 /* ALetter */],
                [/*start*/ 0x1C90, /*end*/ 0x1CBA, 11 /* ALetter */],
                [/*start*/ 0x1CBD, /*end*/ 0x1CBF, 11 /* ALetter */],
                [/*start*/ 0x1CD0, /*end*/ 0x1CD2, 14 /* Extend */],
                [/*start*/ 0x1CD4, /*end*/ 0x1CE0, 14 /* Extend */],
                [/*start*/ 0x1CE1, /*end*/ 0x1CE1, 14 /* Extend */],
                [/*start*/ 0x1CE2, /*end*/ 0x1CE8, 14 /* Extend */],
                [/*start*/ 0x1CE9, /*end*/ 0x1CEC, 11 /* ALetter */],
                [/*start*/ 0x1CED, /*end*/ 0x1CED, 14 /* Extend */],
                [/*start*/ 0x1CEE, /*end*/ 0x1CF3, 11 /* ALetter */],
                [/*start*/ 0x1CF4, /*end*/ 0x1CF4, 14 /* Extend */],
                [/*start*/ 0x1CF5, /*end*/ 0x1CF6, 11 /* ALetter */],
                [/*start*/ 0x1CF7, /*end*/ 0x1CF7, 14 /* Extend */],
                [/*start*/ 0x1CF8, /*end*/ 0x1CF9, 14 /* Extend */],
                [/*start*/ 0x1CFA, /*end*/ 0x1CFA, 11 /* ALetter */],
                [/*start*/ 0x1D00, /*end*/ 0x1D2B, 11 /* ALetter */],
                [/*start*/ 0x1D2C, /*end*/ 0x1D6A, 11 /* ALetter */],
                [/*start*/ 0x1D6B, /*end*/ 0x1D77, 11 /* ALetter */],
                [/*start*/ 0x1D78, /*end*/ 0x1D78, 11 /* ALetter */],
                [/*start*/ 0x1D79, /*end*/ 0x1D9A, 11 /* ALetter */],
                [/*start*/ 0x1D9B, /*end*/ 0x1DBF, 11 /* ALetter */],
                [/*start*/ 0x1DC0, /*end*/ 0x1DF9, 14 /* Extend */],
                [/*start*/ 0x1DFB, /*end*/ 0x1DFF, 14 /* Extend */],
                [/*start*/ 0x1E00, /*end*/ 0x1F15, 11 /* ALetter */],
                [/*start*/ 0x1F18, /*end*/ 0x1F1D, 11 /* ALetter */],
                [/*start*/ 0x1F20, /*end*/ 0x1F45, 11 /* ALetter */],
                [/*start*/ 0x1F48, /*end*/ 0x1F4D, 11 /* ALetter */],
                [/*start*/ 0x1F50, /*end*/ 0x1F57, 11 /* ALetter */],
                [/*start*/ 0x1F59, /*end*/ 0x1F59, 11 /* ALetter */],
                [/*start*/ 0x1F5B, /*end*/ 0x1F5B, 11 /* ALetter */],
                [/*start*/ 0x1F5D, /*end*/ 0x1F5D, 11 /* ALetter */],
                [/*start*/ 0x1F5F, /*end*/ 0x1F7D, 11 /* ALetter */],
                [/*start*/ 0x1F80, /*end*/ 0x1FB4, 11 /* ALetter */],
                [/*start*/ 0x1FB6, /*end*/ 0x1FBC, 11 /* ALetter */],
                [/*start*/ 0x1FBE, /*end*/ 0x1FBE, 11 /* ALetter */],
                [/*start*/ 0x1FC2, /*end*/ 0x1FC4, 11 /* ALetter */],
                [/*start*/ 0x1FC6, /*end*/ 0x1FCC, 11 /* ALetter */],
                [/*start*/ 0x1FD0, /*end*/ 0x1FD3, 11 /* ALetter */],
                [/*start*/ 0x1FD6, /*end*/ 0x1FDB, 11 /* ALetter */],
                [/*start*/ 0x1FE0, /*end*/ 0x1FEC, 11 /* ALetter */],
                [/*start*/ 0x1FF2, /*end*/ 0x1FF4, 11 /* ALetter */],
                [/*start*/ 0x1FF6, /*end*/ 0x1FFC, 11 /* ALetter */],
                [/*start*/ 0x2000, /*end*/ 0x2006, 4 /* WSegSpace */],
                [/*start*/ 0x2008, /*end*/ 0x200A, 4 /* WSegSpace */],
                [/*start*/ 0x200C, /*end*/ 0x200C, 14 /* Extend */],
                [/*start*/ 0x200D, /*end*/ 0x200D, 16 /* ZWJ */],
                [/*start*/ 0x200E, /*end*/ 0x200F, 13 /* Format */],
                [/*start*/ 0x2018, /*end*/ 0x2018, 8 /* MidNumLet */],
                [/*start*/ 0x2019, /*end*/ 0x2019, 8 /* MidNumLet */],
                [/*start*/ 0x2024, /*end*/ 0x2024, 8 /* MidNumLet */],
                [/*start*/ 0x2027, /*end*/ 0x2027, 10 /* MidLetter */],
                [/*start*/ 0x2028, /*end*/ 0x2028, 2 /* Newline */],
                [/*start*/ 0x2029, /*end*/ 0x2029, 2 /* Newline */],
                [/*start*/ 0x202A, /*end*/ 0x202E, 13 /* Format */],
                [/*start*/ 0x202F, /*end*/ 0x202F, 12 /* ExtendNumLet */],
                [/*start*/ 0x203F, /*end*/ 0x2040, 12 /* ExtendNumLet */],
                [/*start*/ 0x2044, /*end*/ 0x2044, 7 /* MidNum */],
                [/*start*/ 0x2054, /*end*/ 0x2054, 12 /* ExtendNumLet */],
                [/*start*/ 0x205F, /*end*/ 0x205F, 4 /* WSegSpace */],
                [/*start*/ 0x2060, /*end*/ 0x2064, 13 /* Format */],
                [/*start*/ 0x2066, /*end*/ 0x206F, 13 /* Format */],
                [/*start*/ 0x2071, /*end*/ 0x2071, 11 /* ALetter */],
                [/*start*/ 0x207F, /*end*/ 0x207F, 11 /* ALetter */],
                [/*start*/ 0x2090, /*end*/ 0x209C, 11 /* ALetter */],
                [/*start*/ 0x20D0, /*end*/ 0x20DC, 14 /* Extend */],
                [/*start*/ 0x20DD, /*end*/ 0x20E0, 14 /* Extend */],
                [/*start*/ 0x20E1, /*end*/ 0x20E1, 14 /* Extend */],
                [/*start*/ 0x20E2, /*end*/ 0x20E4, 14 /* Extend */],
                [/*start*/ 0x20E5, /*end*/ 0x20F0, 14 /* Extend */],
                [/*start*/ 0x2102, /*end*/ 0x2102, 11 /* ALetter */],
                [/*start*/ 0x2107, /*end*/ 0x2107, 11 /* ALetter */],
                [/*start*/ 0x210A, /*end*/ 0x2113, 11 /* ALetter */],
                [/*start*/ 0x2115, /*end*/ 0x2115, 11 /* ALetter */],
                [/*start*/ 0x2119, /*end*/ 0x211D, 11 /* ALetter */],
                [/*start*/ 0x2124, /*end*/ 0x2124, 11 /* ALetter */],
                [/*start*/ 0x2126, /*end*/ 0x2126, 11 /* ALetter */],
                [/*start*/ 0x2128, /*end*/ 0x2128, 11 /* ALetter */],
                [/*start*/ 0x212A, /*end*/ 0x212D, 11 /* ALetter */],
                [/*start*/ 0x212F, /*end*/ 0x2134, 11 /* ALetter */],
                [/*start*/ 0x2135, /*end*/ 0x2138, 11 /* ALetter */],
                [/*start*/ 0x2139, /*end*/ 0x2139, 11 /* ALetter */],
                [/*start*/ 0x213C, /*end*/ 0x213F, 11 /* ALetter */],
                [/*start*/ 0x2145, /*end*/ 0x2149, 11 /* ALetter */],
                [/*start*/ 0x214E, /*end*/ 0x214E, 11 /* ALetter */],
                [/*start*/ 0x2160, /*end*/ 0x2182, 11 /* ALetter */],
                [/*start*/ 0x2183, /*end*/ 0x2184, 11 /* ALetter */],
                [/*start*/ 0x2185, /*end*/ 0x2188, 11 /* ALetter */],
                [/*start*/ 0x24B6, /*end*/ 0x24E9, 11 /* ALetter */],
                [/*start*/ 0x2C00, /*end*/ 0x2C2E, 11 /* ALetter */],
                [/*start*/ 0x2C30, /*end*/ 0x2C5E, 11 /* ALetter */],
                [/*start*/ 0x2C60, /*end*/ 0x2C7B, 11 /* ALetter */],
                [/*start*/ 0x2C7C, /*end*/ 0x2C7D, 11 /* ALetter */],
                [/*start*/ 0x2C7E, /*end*/ 0x2CE4, 11 /* ALetter */],
                [/*start*/ 0x2CEB, /*end*/ 0x2CEE, 11 /* ALetter */],
                [/*start*/ 0x2CEF, /*end*/ 0x2CF1, 14 /* Extend */],
                [/*start*/ 0x2CF2, /*end*/ 0x2CF3, 11 /* ALetter */],
                [/*start*/ 0x2D00, /*end*/ 0x2D25, 11 /* ALetter */],
                [/*start*/ 0x2D27, /*end*/ 0x2D27, 11 /* ALetter */],
                [/*start*/ 0x2D2D, /*end*/ 0x2D2D, 11 /* ALetter */],
                [/*start*/ 0x2D30, /*end*/ 0x2D67, 11 /* ALetter */],
                [/*start*/ 0x2D6F, /*end*/ 0x2D6F, 11 /* ALetter */],
                [/*start*/ 0x2D7F, /*end*/ 0x2D7F, 14 /* Extend */],
                [/*start*/ 0x2D80, /*end*/ 0x2D96, 11 /* ALetter */],
                [/*start*/ 0x2DA0, /*end*/ 0x2DA6, 11 /* ALetter */],
                [/*start*/ 0x2DA8, /*end*/ 0x2DAE, 11 /* ALetter */],
                [/*start*/ 0x2DB0, /*end*/ 0x2DB6, 11 /* ALetter */],
                [/*start*/ 0x2DB8, /*end*/ 0x2DBE, 11 /* ALetter */],
                [/*start*/ 0x2DC0, /*end*/ 0x2DC6, 11 /* ALetter */],
                [/*start*/ 0x2DC8, /*end*/ 0x2DCE, 11 /* ALetter */],
                [/*start*/ 0x2DD0, /*end*/ 0x2DD6, 11 /* ALetter */],
                [/*start*/ 0x2DD8, /*end*/ 0x2DDE, 11 /* ALetter */],
                [/*start*/ 0x2DE0, /*end*/ 0x2DFF, 14 /* Extend */],
                [/*start*/ 0x2E2F, /*end*/ 0x2E2F, 11 /* ALetter */],
                [/*start*/ 0x3000, /*end*/ 0x3000, 4 /* WSegSpace */],
                [/*start*/ 0x3005, /*end*/ 0x3005, 11 /* ALetter */],
                [/*start*/ 0x302A, /*end*/ 0x302D, 14 /* Extend */],
                [/*start*/ 0x302E, /*end*/ 0x302F, 14 /* Extend */],
                [/*start*/ 0x3031, /*end*/ 0x3035, 17 /* Katakana */],
                [/*start*/ 0x303B, /*end*/ 0x303B, 11 /* ALetter */],
                [/*start*/ 0x303C, /*end*/ 0x303C, 11 /* ALetter */],
                [/*start*/ 0x3099, /*end*/ 0x309A, 14 /* Extend */],
                [/*start*/ 0x309B, /*end*/ 0x309C, 17 /* Katakana */],
                [/*start*/ 0x30A0, /*end*/ 0x30A0, 17 /* Katakana */],
                [/*start*/ 0x30A1, /*end*/ 0x30FA, 17 /* Katakana */],
                [/*start*/ 0x30FC, /*end*/ 0x30FE, 17 /* Katakana */],
                [/*start*/ 0x30FF, /*end*/ 0x30FF, 17 /* Katakana */],
                [/*start*/ 0x3105, /*end*/ 0x312F, 11 /* ALetter */],
                [/*start*/ 0x3131, /*end*/ 0x318E, 11 /* ALetter */],
                [/*start*/ 0x31A0, /*end*/ 0x31BA, 11 /* ALetter */],
                [/*start*/ 0x31F0, /*end*/ 0x31FF, 17 /* Katakana */],
                [/*start*/ 0x32D0, /*end*/ 0x32FE, 17 /* Katakana */],
                [/*start*/ 0x3300, /*end*/ 0x3357, 17 /* Katakana */],
                [/*start*/ 0xA000, /*end*/ 0xA014, 11 /* ALetter */],
                [/*start*/ 0xA015, /*end*/ 0xA015, 11 /* ALetter */],
                [/*start*/ 0xA016, /*end*/ 0xA48C, 11 /* ALetter */],
                [/*start*/ 0xA4D0, /*end*/ 0xA4F7, 11 /* ALetter */],
                [/*start*/ 0xA4F8, /*end*/ 0xA4FD, 11 /* ALetter */],
                [/*start*/ 0xA500, /*end*/ 0xA60B, 11 /* ALetter */],
                [/*start*/ 0xA60C, /*end*/ 0xA60C, 11 /* ALetter */],
                [/*start*/ 0xA610, /*end*/ 0xA61F, 11 /* ALetter */],
                [/*start*/ 0xA620, /*end*/ 0xA629, 9 /* Numeric */],
                [/*start*/ 0xA62A, /*end*/ 0xA62B, 11 /* ALetter */],
                [/*start*/ 0xA640, /*end*/ 0xA66D, 11 /* ALetter */],
                [/*start*/ 0xA66E, /*end*/ 0xA66E, 11 /* ALetter */],
                [/*start*/ 0xA66F, /*end*/ 0xA66F, 14 /* Extend */],
                [/*start*/ 0xA670, /*end*/ 0xA672, 14 /* Extend */],
                [/*start*/ 0xA674, /*end*/ 0xA67D, 14 /* Extend */],
                [/*start*/ 0xA67F, /*end*/ 0xA67F, 11 /* ALetter */],
                [/*start*/ 0xA680, /*end*/ 0xA69B, 11 /* ALetter */],
                [/*start*/ 0xA69C, /*end*/ 0xA69D, 11 /* ALetter */],
                [/*start*/ 0xA69E, /*end*/ 0xA69F, 14 /* Extend */],
                [/*start*/ 0xA6A0, /*end*/ 0xA6E5, 11 /* ALetter */],
                [/*start*/ 0xA6E6, /*end*/ 0xA6EF, 11 /* ALetter */],
                [/*start*/ 0xA6F0, /*end*/ 0xA6F1, 14 /* Extend */],
                [/*start*/ 0xA717, /*end*/ 0xA71F, 11 /* ALetter */],
                [/*start*/ 0xA720, /*end*/ 0xA721, 11 /* ALetter */],
                [/*start*/ 0xA722, /*end*/ 0xA76F, 11 /* ALetter */],
                [/*start*/ 0xA770, /*end*/ 0xA770, 11 /* ALetter */],
                [/*start*/ 0xA771, /*end*/ 0xA787, 11 /* ALetter */],
                [/*start*/ 0xA788, /*end*/ 0xA788, 11 /* ALetter */],
                [/*start*/ 0xA789, /*end*/ 0xA78A, 11 /* ALetter */],
                [/*start*/ 0xA78B, /*end*/ 0xA78E, 11 /* ALetter */],
                [/*start*/ 0xA78F, /*end*/ 0xA78F, 11 /* ALetter */],
                [/*start*/ 0xA790, /*end*/ 0xA7BF, 11 /* ALetter */],
                [/*start*/ 0xA7C2, /*end*/ 0xA7C6, 11 /* ALetter */],
                [/*start*/ 0xA7F7, /*end*/ 0xA7F7, 11 /* ALetter */],
                [/*start*/ 0xA7F8, /*end*/ 0xA7F9, 11 /* ALetter */],
                [/*start*/ 0xA7FA, /*end*/ 0xA7FA, 11 /* ALetter */],
                [/*start*/ 0xA7FB, /*end*/ 0xA801, 11 /* ALetter */],
                [/*start*/ 0xA802, /*end*/ 0xA802, 14 /* Extend */],
                [/*start*/ 0xA803, /*end*/ 0xA805, 11 /* ALetter */],
                [/*start*/ 0xA806, /*end*/ 0xA806, 14 /* Extend */],
                [/*start*/ 0xA807, /*end*/ 0xA80A, 11 /* ALetter */],
                [/*start*/ 0xA80B, /*end*/ 0xA80B, 14 /* Extend */],
                [/*start*/ 0xA80C, /*end*/ 0xA822, 11 /* ALetter */],
                [/*start*/ 0xA823, /*end*/ 0xA824, 14 /* Extend */],
                [/*start*/ 0xA825, /*end*/ 0xA826, 14 /* Extend */],
                [/*start*/ 0xA827, /*end*/ 0xA827, 14 /* Extend */],
                [/*start*/ 0xA840, /*end*/ 0xA873, 11 /* ALetter */],
                [/*start*/ 0xA880, /*end*/ 0xA881, 14 /* Extend */],
                [/*start*/ 0xA882, /*end*/ 0xA8B3, 11 /* ALetter */],
                [/*start*/ 0xA8B4, /*end*/ 0xA8C3, 14 /* Extend */],
                [/*start*/ 0xA8C4, /*end*/ 0xA8C5, 14 /* Extend */],
                [/*start*/ 0xA8D0, /*end*/ 0xA8D9, 9 /* Numeric */],
                [/*start*/ 0xA8E0, /*end*/ 0xA8F1, 14 /* Extend */],
                [/*start*/ 0xA8F2, /*end*/ 0xA8F7, 11 /* ALetter */],
                [/*start*/ 0xA8FB, /*end*/ 0xA8FB, 11 /* ALetter */],
                [/*start*/ 0xA8FD, /*end*/ 0xA8FE, 11 /* ALetter */],
                [/*start*/ 0xA8FF, /*end*/ 0xA8FF, 14 /* Extend */],
                [/*start*/ 0xA900, /*end*/ 0xA909, 9 /* Numeric */],
                [/*start*/ 0xA90A, /*end*/ 0xA925, 11 /* ALetter */],
                [/*start*/ 0xA926, /*end*/ 0xA92D, 14 /* Extend */],
                [/*start*/ 0xA930, /*end*/ 0xA946, 11 /* ALetter */],
                [/*start*/ 0xA947, /*end*/ 0xA951, 14 /* Extend */],
                [/*start*/ 0xA952, /*end*/ 0xA953, 14 /* Extend */],
                [/*start*/ 0xA960, /*end*/ 0xA97C, 11 /* ALetter */],
                [/*start*/ 0xA980, /*end*/ 0xA982, 14 /* Extend */],
                [/*start*/ 0xA983, /*end*/ 0xA983, 14 /* Extend */],
                [/*start*/ 0xA984, /*end*/ 0xA9B2, 11 /* ALetter */],
                [/*start*/ 0xA9B3, /*end*/ 0xA9B3, 14 /* Extend */],
                [/*start*/ 0xA9B4, /*end*/ 0xA9B5, 14 /* Extend */],
                [/*start*/ 0xA9B6, /*end*/ 0xA9B9, 14 /* Extend */],
                [/*start*/ 0xA9BA, /*end*/ 0xA9BB, 14 /* Extend */],
                [/*start*/ 0xA9BC, /*end*/ 0xA9BD, 14 /* Extend */],
                [/*start*/ 0xA9BE, /*end*/ 0xA9C0, 14 /* Extend */],
                [/*start*/ 0xA9CF, /*end*/ 0xA9CF, 11 /* ALetter */],
                [/*start*/ 0xA9D0, /*end*/ 0xA9D9, 9 /* Numeric */],
                [/*start*/ 0xA9E5, /*end*/ 0xA9E5, 14 /* Extend */],
                [/*start*/ 0xA9F0, /*end*/ 0xA9F9, 9 /* Numeric */],
                [/*start*/ 0xAA00, /*end*/ 0xAA28, 11 /* ALetter */],
                [/*start*/ 0xAA29, /*end*/ 0xAA2E, 14 /* Extend */],
                [/*start*/ 0xAA2F, /*end*/ 0xAA30, 14 /* Extend */],
                [/*start*/ 0xAA31, /*end*/ 0xAA32, 14 /* Extend */],
                [/*start*/ 0xAA33, /*end*/ 0xAA34, 14 /* Extend */],
                [/*start*/ 0xAA35, /*end*/ 0xAA36, 14 /* Extend */],
                [/*start*/ 0xAA40, /*end*/ 0xAA42, 11 /* ALetter */],
                [/*start*/ 0xAA43, /*end*/ 0xAA43, 14 /* Extend */],
                [/*start*/ 0xAA44, /*end*/ 0xAA4B, 11 /* ALetter */],
                [/*start*/ 0xAA4C, /*end*/ 0xAA4C, 14 /* Extend */],
                [/*start*/ 0xAA4D, /*end*/ 0xAA4D, 14 /* Extend */],
                [/*start*/ 0xAA50, /*end*/ 0xAA59, 9 /* Numeric */],
                [/*start*/ 0xAA7B, /*end*/ 0xAA7B, 14 /* Extend */],
                [/*start*/ 0xAA7C, /*end*/ 0xAA7C, 14 /* Extend */],
                [/*start*/ 0xAA7D, /*end*/ 0xAA7D, 14 /* Extend */],
                [/*start*/ 0xAAB0, /*end*/ 0xAAB0, 14 /* Extend */],
                [/*start*/ 0xAAB2, /*end*/ 0xAAB4, 14 /* Extend */],
                [/*start*/ 0xAAB7, /*end*/ 0xAAB8, 14 /* Extend */],
                [/*start*/ 0xAABE, /*end*/ 0xAABF, 14 /* Extend */],
                [/*start*/ 0xAAC1, /*end*/ 0xAAC1, 14 /* Extend */],
                [/*start*/ 0xAAE0, /*end*/ 0xAAEA, 11 /* ALetter */],
                [/*start*/ 0xAAEB, /*end*/ 0xAAEB, 14 /* Extend */],
                [/*start*/ 0xAAEC, /*end*/ 0xAAED, 14 /* Extend */],
                [/*start*/ 0xAAEE, /*end*/ 0xAAEF, 14 /* Extend */],
                [/*start*/ 0xAAF2, /*end*/ 0xAAF2, 11 /* ALetter */],
                [/*start*/ 0xAAF3, /*end*/ 0xAAF4, 11 /* ALetter */],
                [/*start*/ 0xAAF5, /*end*/ 0xAAF5, 14 /* Extend */],
                [/*start*/ 0xAAF6, /*end*/ 0xAAF6, 14 /* Extend */],
                [/*start*/ 0xAB01, /*end*/ 0xAB06, 11 /* ALetter */],
                [/*start*/ 0xAB09, /*end*/ 0xAB0E, 11 /* ALetter */],
                [/*start*/ 0xAB11, /*end*/ 0xAB16, 11 /* ALetter */],
                [/*start*/ 0xAB20, /*end*/ 0xAB26, 11 /* ALetter */],
                [/*start*/ 0xAB28, /*end*/ 0xAB2E, 11 /* ALetter */],
                [/*start*/ 0xAB30, /*end*/ 0xAB5A, 11 /* ALetter */],
                [/*start*/ 0xAB5B, /*end*/ 0xAB5B, 11 /* ALetter */],
                [/*start*/ 0xAB5C, /*end*/ 0xAB5F, 11 /* ALetter */],
                [/*start*/ 0xAB60, /*end*/ 0xAB67, 11 /* ALetter */],
                [/*start*/ 0xAB70, /*end*/ 0xABBF, 11 /* ALetter */],
                [/*start*/ 0xABC0, /*end*/ 0xABE2, 11 /* ALetter */],
                [/*start*/ 0xABE3, /*end*/ 0xABE4, 14 /* Extend */],
                [/*start*/ 0xABE5, /*end*/ 0xABE5, 14 /* Extend */],
                [/*start*/ 0xABE6, /*end*/ 0xABE7, 14 /* Extend */],
                [/*start*/ 0xABE8, /*end*/ 0xABE8, 14 /* Extend */],
                [/*start*/ 0xABE9, /*end*/ 0xABEA, 14 /* Extend */],
                [/*start*/ 0xABEC, /*end*/ 0xABEC, 14 /* Extend */],
                [/*start*/ 0xABED, /*end*/ 0xABED, 14 /* Extend */],
                [/*start*/ 0xABF0, /*end*/ 0xABF9, 9 /* Numeric */],
                [/*start*/ 0xAC00, /*end*/ 0xD7A3, 11 /* ALetter */],
                [/*start*/ 0xD7B0, /*end*/ 0xD7C6, 11 /* ALetter */],
                [/*start*/ 0xD7CB, /*end*/ 0xD7FB, 11 /* ALetter */],
                [/*start*/ 0xFB00, /*end*/ 0xFB06, 11 /* ALetter */],
                [/*start*/ 0xFB13, /*end*/ 0xFB17, 11 /* ALetter */],
                [/*start*/ 0xFB1D, /*end*/ 0xFB1D, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB1E, /*end*/ 0xFB1E, 14 /* Extend */],
                [/*start*/ 0xFB1F, /*end*/ 0xFB28, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB2A, /*end*/ 0xFB36, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB38, /*end*/ 0xFB3C, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB3E, /*end*/ 0xFB3E, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB40, /*end*/ 0xFB41, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB43, /*end*/ 0xFB44, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB46, /*end*/ 0xFB4F, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB50, /*end*/ 0xFBB1, 11 /* ALetter */],
                [/*start*/ 0xFBD3, /*end*/ 0xFD3D, 11 /* ALetter */],
                [/*start*/ 0xFD50, /*end*/ 0xFD8F, 11 /* ALetter */],
                [/*start*/ 0xFD92, /*end*/ 0xFDC7, 11 /* ALetter */],
                [/*start*/ 0xFDF0, /*end*/ 0xFDFB, 11 /* ALetter */],
                [/*start*/ 0xFE00, /*end*/ 0xFE0F, 14 /* Extend */],
                [/*start*/ 0xFE10, /*end*/ 0xFE10, 7 /* MidNum */],
                [/*start*/ 0xFE13, /*end*/ 0xFE13, 10 /* MidLetter */],
                [/*start*/ 0xFE14, /*end*/ 0xFE14, 7 /* MidNum */],
                [/*start*/ 0xFE20, /*end*/ 0xFE2F, 14 /* Extend */],
                [/*start*/ 0xFE33, /*end*/ 0xFE34, 12 /* ExtendNumLet */],
                [/*start*/ 0xFE4D, /*end*/ 0xFE4F, 12 /* ExtendNumLet */],
                [/*start*/ 0xFE50, /*end*/ 0xFE50, 7 /* MidNum */],
                [/*start*/ 0xFE52, /*end*/ 0xFE52, 8 /* MidNumLet */],
                [/*start*/ 0xFE54, /*end*/ 0xFE54, 7 /* MidNum */],
                [/*start*/ 0xFE55, /*end*/ 0xFE55, 10 /* MidLetter */],
                [/*start*/ 0xFE70, /*end*/ 0xFE74, 11 /* ALetter */],
                [/*start*/ 0xFE76, /*end*/ 0xFEFC, 11 /* ALetter */],
                [/*start*/ 0xFEFF, /*end*/ 0xFEFF, 13 /* Format */],
                [/*start*/ 0xFF07, /*end*/ 0xFF07, 8 /* MidNumLet */],
                [/*start*/ 0xFF0C, /*end*/ 0xFF0C, 7 /* MidNum */],
                [/*start*/ 0xFF0E, /*end*/ 0xFF0E, 8 /* MidNumLet */],
                [/*start*/ 0xFF10, /*end*/ 0xFF19, 9 /* Numeric */],
                [/*start*/ 0xFF1A, /*end*/ 0xFF1A, 10 /* MidLetter */],
                [/*start*/ 0xFF1B, /*end*/ 0xFF1B, 7 /* MidNum */],
                [/*start*/ 0xFF21, /*end*/ 0xFF3A, 11 /* ALetter */],
                [/*start*/ 0xFF3F, /*end*/ 0xFF3F, 12 /* ExtendNumLet */],
                [/*start*/ 0xFF41, /*end*/ 0xFF5A, 11 /* ALetter */],
                [/*start*/ 0xFF66, /*end*/ 0xFF6F, 17 /* Katakana */],
                [/*start*/ 0xFF70, /*end*/ 0xFF70, 17 /* Katakana */],
                [/*start*/ 0xFF71, /*end*/ 0xFF9D, 17 /* Katakana */],
                [/*start*/ 0xFF9E, /*end*/ 0xFF9F, 14 /* Extend */],
                [/*start*/ 0xFFA0, /*end*/ 0xFFBE, 11 /* ALetter */],
                [/*start*/ 0xFFC2, /*end*/ 0xFFC7, 11 /* ALetter */],
                [/*start*/ 0xFFCA, /*end*/ 0xFFCF, 11 /* ALetter */],
                [/*start*/ 0xFFD2, /*end*/ 0xFFD7, 11 /* ALetter */],
                [/*start*/ 0xFFDA, /*end*/ 0xFFDC, 11 /* ALetter */],
                [/*start*/ 0xFFF9, /*end*/ 0xFFFB, 13 /* Format */],
                [/*start*/ 0x10000, /*end*/ 0x1000B, 11 /* ALetter */],
                [/*start*/ 0x1000D, /*end*/ 0x10026, 11 /* ALetter */],
                [/*start*/ 0x10028, /*end*/ 0x1003A, 11 /* ALetter */],
                [/*start*/ 0x1003C, /*end*/ 0x1003D, 11 /* ALetter */],
                [/*start*/ 0x1003F, /*end*/ 0x1004D, 11 /* ALetter */],
                [/*start*/ 0x10050, /*end*/ 0x1005D, 11 /* ALetter */],
                [/*start*/ 0x10080, /*end*/ 0x100FA, 11 /* ALetter */],
                [/*start*/ 0x10140, /*end*/ 0x10174, 11 /* ALetter */],
                [/*start*/ 0x101FD, /*end*/ 0x101FD, 14 /* Extend */],
                [/*start*/ 0x10280, /*end*/ 0x1029C, 11 /* ALetter */],
                [/*start*/ 0x102A0, /*end*/ 0x102D0, 11 /* ALetter */],
                [/*start*/ 0x102E0, /*end*/ 0x102E0, 14 /* Extend */],
                [/*start*/ 0x10300, /*end*/ 0x1031F, 11 /* ALetter */],
                [/*start*/ 0x1032D, /*end*/ 0x10340, 11 /* ALetter */],
                [/*start*/ 0x10341, /*end*/ 0x10341, 11 /* ALetter */],
                [/*start*/ 0x10342, /*end*/ 0x10349, 11 /* ALetter */],
                [/*start*/ 0x1034A, /*end*/ 0x1034A, 11 /* ALetter */],
                [/*start*/ 0x10350, /*end*/ 0x10375, 11 /* ALetter */],
                [/*start*/ 0x10376, /*end*/ 0x1037A, 14 /* Extend */],
                [/*start*/ 0x10380, /*end*/ 0x1039D, 11 /* ALetter */],
                [/*start*/ 0x103A0, /*end*/ 0x103C3, 11 /* ALetter */],
                [/*start*/ 0x103C8, /*end*/ 0x103CF, 11 /* ALetter */],
                [/*start*/ 0x103D1, /*end*/ 0x103D5, 11 /* ALetter */],
                [/*start*/ 0x10400, /*end*/ 0x1044F, 11 /* ALetter */],
                [/*start*/ 0x10450, /*end*/ 0x1049D, 11 /* ALetter */],
                [/*start*/ 0x104A0, /*end*/ 0x104A9, 9 /* Numeric */],
                [/*start*/ 0x104B0, /*end*/ 0x104D3, 11 /* ALetter */],
                [/*start*/ 0x104D8, /*end*/ 0x104FB, 11 /* ALetter */],
                [/*start*/ 0x10500, /*end*/ 0x10527, 11 /* ALetter */],
                [/*start*/ 0x10530, /*end*/ 0x10563, 11 /* ALetter */],
                [/*start*/ 0x10600, /*end*/ 0x10736, 11 /* ALetter */],
                [/*start*/ 0x10740, /*end*/ 0x10755, 11 /* ALetter */],
                [/*start*/ 0x10760, /*end*/ 0x10767, 11 /* ALetter */],
                [/*start*/ 0x10800, /*end*/ 0x10805, 11 /* ALetter */],
                [/*start*/ 0x10808, /*end*/ 0x10808, 11 /* ALetter */],
                [/*start*/ 0x1080A, /*end*/ 0x10835, 11 /* ALetter */],
                [/*start*/ 0x10837, /*end*/ 0x10838, 11 /* ALetter */],
                [/*start*/ 0x1083C, /*end*/ 0x1083C, 11 /* ALetter */],
                [/*start*/ 0x1083F, /*end*/ 0x10855, 11 /* ALetter */],
                [/*start*/ 0x10860, /*end*/ 0x10876, 11 /* ALetter */],
                [/*start*/ 0x10880, /*end*/ 0x1089E, 11 /* ALetter */],
                [/*start*/ 0x108E0, /*end*/ 0x108F2, 11 /* ALetter */],
                [/*start*/ 0x108F4, /*end*/ 0x108F5, 11 /* ALetter */],
                [/*start*/ 0x10900, /*end*/ 0x10915, 11 /* ALetter */],
                [/*start*/ 0x10920, /*end*/ 0x10939, 11 /* ALetter */],
                [/*start*/ 0x10980, /*end*/ 0x109B7, 11 /* ALetter */],
                [/*start*/ 0x109BE, /*end*/ 0x109BF, 11 /* ALetter */],
                [/*start*/ 0x10A00, /*end*/ 0x10A00, 11 /* ALetter */],
                [/*start*/ 0x10A01, /*end*/ 0x10A03, 14 /* Extend */],
                [/*start*/ 0x10A05, /*end*/ 0x10A06, 14 /* Extend */],
                [/*start*/ 0x10A0C, /*end*/ 0x10A0F, 14 /* Extend */],
                [/*start*/ 0x10A10, /*end*/ 0x10A13, 11 /* ALetter */],
                [/*start*/ 0x10A15, /*end*/ 0x10A17, 11 /* ALetter */],
                [/*start*/ 0x10A19, /*end*/ 0x10A35, 11 /* ALetter */],
                [/*start*/ 0x10A38, /*end*/ 0x10A3A, 14 /* Extend */],
                [/*start*/ 0x10A3F, /*end*/ 0x10A3F, 14 /* Extend */],
                [/*start*/ 0x10A60, /*end*/ 0x10A7C, 11 /* ALetter */],
                [/*start*/ 0x10A80, /*end*/ 0x10A9C, 11 /* ALetter */],
                [/*start*/ 0x10AC0, /*end*/ 0x10AC7, 11 /* ALetter */],
                [/*start*/ 0x10AC9, /*end*/ 0x10AE4, 11 /* ALetter */],
                [/*start*/ 0x10AE5, /*end*/ 0x10AE6, 14 /* Extend */],
                [/*start*/ 0x10B00, /*end*/ 0x10B35, 11 /* ALetter */],
                [/*start*/ 0x10B40, /*end*/ 0x10B55, 11 /* ALetter */],
                [/*start*/ 0x10B60, /*end*/ 0x10B72, 11 /* ALetter */],
                [/*start*/ 0x10B80, /*end*/ 0x10B91, 11 /* ALetter */],
                [/*start*/ 0x10C00, /*end*/ 0x10C48, 11 /* ALetter */],
                [/*start*/ 0x10C80, /*end*/ 0x10CB2, 11 /* ALetter */],
                [/*start*/ 0x10CC0, /*end*/ 0x10CF2, 11 /* ALetter */],
                [/*start*/ 0x10D00, /*end*/ 0x10D23, 11 /* ALetter */],
                [/*start*/ 0x10D24, /*end*/ 0x10D27, 14 /* Extend */],
                [/*start*/ 0x10D30, /*end*/ 0x10D39, 9 /* Numeric */],
                [/*start*/ 0x10F00, /*end*/ 0x10F1C, 11 /* ALetter */],
                [/*start*/ 0x10F27, /*end*/ 0x10F27, 11 /* ALetter */],
                [/*start*/ 0x10F30, /*end*/ 0x10F45, 11 /* ALetter */],
                [/*start*/ 0x10F46, /*end*/ 0x10F50, 14 /* Extend */],
                [/*start*/ 0x10FE0, /*end*/ 0x10FF6, 11 /* ALetter */],
                [/*start*/ 0x11000, /*end*/ 0x11000, 14 /* Extend */],
                [/*start*/ 0x11001, /*end*/ 0x11001, 14 /* Extend */],
                [/*start*/ 0x11002, /*end*/ 0x11002, 14 /* Extend */],
                [/*start*/ 0x11003, /*end*/ 0x11037, 11 /* ALetter */],
                [/*start*/ 0x11038, /*end*/ 0x11046, 14 /* Extend */],
                [/*start*/ 0x11066, /*end*/ 0x1106F, 9 /* Numeric */],
                [/*start*/ 0x1107F, /*end*/ 0x11081, 14 /* Extend */],
                [/*start*/ 0x11082, /*end*/ 0x11082, 14 /* Extend */],
                [/*start*/ 0x11083, /*end*/ 0x110AF, 11 /* ALetter */],
                [/*start*/ 0x110B0, /*end*/ 0x110B2, 14 /* Extend */],
                [/*start*/ 0x110B3, /*end*/ 0x110B6, 14 /* Extend */],
                [/*start*/ 0x110B7, /*end*/ 0x110B8, 14 /* Extend */],
                [/*start*/ 0x110B9, /*end*/ 0x110BA, 14 /* Extend */],
                [/*start*/ 0x110BD, /*end*/ 0x110BD, 13 /* Format */],
                [/*start*/ 0x110CD, /*end*/ 0x110CD, 13 /* Format */],
                [/*start*/ 0x110D0, /*end*/ 0x110E8, 11 /* ALetter */],
                [/*start*/ 0x110F0, /*end*/ 0x110F9, 9 /* Numeric */],
                [/*start*/ 0x11100, /*end*/ 0x11102, 14 /* Extend */],
                [/*start*/ 0x11103, /*end*/ 0x11126, 11 /* ALetter */],
                [/*start*/ 0x11127, /*end*/ 0x1112B, 14 /* Extend */],
                [/*start*/ 0x1112C, /*end*/ 0x1112C, 14 /* Extend */],
                [/*start*/ 0x1112D, /*end*/ 0x11134, 14 /* Extend */],
                [/*start*/ 0x11136, /*end*/ 0x1113F, 9 /* Numeric */],
                [/*start*/ 0x11144, /*end*/ 0x11144, 11 /* ALetter */],
                [/*start*/ 0x11145, /*end*/ 0x11146, 14 /* Extend */],
                [/*start*/ 0x11150, /*end*/ 0x11172, 11 /* ALetter */],
                [/*start*/ 0x11173, /*end*/ 0x11173, 14 /* Extend */],
                [/*start*/ 0x11176, /*end*/ 0x11176, 11 /* ALetter */],
                [/*start*/ 0x11180, /*end*/ 0x11181, 14 /* Extend */],
                [/*start*/ 0x11182, /*end*/ 0x11182, 14 /* Extend */],
                [/*start*/ 0x11183, /*end*/ 0x111B2, 11 /* ALetter */],
                [/*start*/ 0x111B3, /*end*/ 0x111B5, 14 /* Extend */],
                [/*start*/ 0x111B6, /*end*/ 0x111BE, 14 /* Extend */],
                [/*start*/ 0x111BF, /*end*/ 0x111C0, 14 /* Extend */],
                [/*start*/ 0x111C1, /*end*/ 0x111C4, 11 /* ALetter */],
                [/*start*/ 0x111C9, /*end*/ 0x111CC, 14 /* Extend */],
                [/*start*/ 0x111D0, /*end*/ 0x111D9, 9 /* Numeric */],
                [/*start*/ 0x111DA, /*end*/ 0x111DA, 11 /* ALetter */],
                [/*start*/ 0x111DC, /*end*/ 0x111DC, 11 /* ALetter */],
                [/*start*/ 0x11200, /*end*/ 0x11211, 11 /* ALetter */],
                [/*start*/ 0x11213, /*end*/ 0x1122B, 11 /* ALetter */],
                [/*start*/ 0x1122C, /*end*/ 0x1122E, 14 /* Extend */],
                [/*start*/ 0x1122F, /*end*/ 0x11231, 14 /* Extend */],
                [/*start*/ 0x11232, /*end*/ 0x11233, 14 /* Extend */],
                [/*start*/ 0x11234, /*end*/ 0x11234, 14 /* Extend */],
                [/*start*/ 0x11235, /*end*/ 0x11235, 14 /* Extend */],
                [/*start*/ 0x11236, /*end*/ 0x11237, 14 /* Extend */],
                [/*start*/ 0x1123E, /*end*/ 0x1123E, 14 /* Extend */],
                [/*start*/ 0x11280, /*end*/ 0x11286, 11 /* ALetter */],
                [/*start*/ 0x11288, /*end*/ 0x11288, 11 /* ALetter */],
                [/*start*/ 0x1128A, /*end*/ 0x1128D, 11 /* ALetter */],
                [/*start*/ 0x1128F, /*end*/ 0x1129D, 11 /* ALetter */],
                [/*start*/ 0x1129F, /*end*/ 0x112A8, 11 /* ALetter */],
                [/*start*/ 0x112B0, /*end*/ 0x112DE, 11 /* ALetter */],
                [/*start*/ 0x112DF, /*end*/ 0x112DF, 14 /* Extend */],
                [/*start*/ 0x112E0, /*end*/ 0x112E2, 14 /* Extend */],
                [/*start*/ 0x112E3, /*end*/ 0x112EA, 14 /* Extend */],
                [/*start*/ 0x112F0, /*end*/ 0x112F9, 9 /* Numeric */],
                [/*start*/ 0x11300, /*end*/ 0x11301, 14 /* Extend */],
                [/*start*/ 0x11302, /*end*/ 0x11303, 14 /* Extend */],
                [/*start*/ 0x11305, /*end*/ 0x1130C, 11 /* ALetter */],
                [/*start*/ 0x1130F, /*end*/ 0x11310, 11 /* ALetter */],
                [/*start*/ 0x11313, /*end*/ 0x11328, 11 /* ALetter */],
                [/*start*/ 0x1132A, /*end*/ 0x11330, 11 /* ALetter */],
                [/*start*/ 0x11332, /*end*/ 0x11333, 11 /* ALetter */],
                [/*start*/ 0x11335, /*end*/ 0x11339, 11 /* ALetter */],
                [/*start*/ 0x1133B, /*end*/ 0x1133C, 14 /* Extend */],
                [/*start*/ 0x1133D, /*end*/ 0x1133D, 11 /* ALetter */],
                [/*start*/ 0x1133E, /*end*/ 0x1133F, 14 /* Extend */],
                [/*start*/ 0x11340, /*end*/ 0x11340, 14 /* Extend */],
                [/*start*/ 0x11341, /*end*/ 0x11344, 14 /* Extend */],
                [/*start*/ 0x11347, /*end*/ 0x11348, 14 /* Extend */],
                [/*start*/ 0x1134B, /*end*/ 0x1134D, 14 /* Extend */],
                [/*start*/ 0x11350, /*end*/ 0x11350, 11 /* ALetter */],
                [/*start*/ 0x11357, /*end*/ 0x11357, 14 /* Extend */],
                [/*start*/ 0x1135D, /*end*/ 0x11361, 11 /* ALetter */],
                [/*start*/ 0x11362, /*end*/ 0x11363, 14 /* Extend */],
                [/*start*/ 0x11366, /*end*/ 0x1136C, 14 /* Extend */],
                [/*start*/ 0x11370, /*end*/ 0x11374, 14 /* Extend */],
                [/*start*/ 0x11400, /*end*/ 0x11434, 11 /* ALetter */],
                [/*start*/ 0x11435, /*end*/ 0x11437, 14 /* Extend */],
                [/*start*/ 0x11438, /*end*/ 0x1143F, 14 /* Extend */],
                [/*start*/ 0x11440, /*end*/ 0x11441, 14 /* Extend */],
                [/*start*/ 0x11442, /*end*/ 0x11444, 14 /* Extend */],
                [/*start*/ 0x11445, /*end*/ 0x11445, 14 /* Extend */],
                [/*start*/ 0x11446, /*end*/ 0x11446, 14 /* Extend */],
                [/*start*/ 0x11447, /*end*/ 0x1144A, 11 /* ALetter */],
                [/*start*/ 0x11450, /*end*/ 0x11459, 9 /* Numeric */],
                [/*start*/ 0x1145E, /*end*/ 0x1145E, 14 /* Extend */],
                [/*start*/ 0x1145F, /*end*/ 0x1145F, 11 /* ALetter */],
                [/*start*/ 0x11480, /*end*/ 0x114AF, 11 /* ALetter */],
                [/*start*/ 0x114B0, /*end*/ 0x114B2, 14 /* Extend */],
                [/*start*/ 0x114B3, /*end*/ 0x114B8, 14 /* Extend */],
                [/*start*/ 0x114B9, /*end*/ 0x114B9, 14 /* Extend */],
                [/*start*/ 0x114BA, /*end*/ 0x114BA, 14 /* Extend */],
                [/*start*/ 0x114BB, /*end*/ 0x114BE, 14 /* Extend */],
                [/*start*/ 0x114BF, /*end*/ 0x114C0, 14 /* Extend */],
                [/*start*/ 0x114C1, /*end*/ 0x114C1, 14 /* Extend */],
                [/*start*/ 0x114C2, /*end*/ 0x114C3, 14 /* Extend */],
                [/*start*/ 0x114C4, /*end*/ 0x114C5, 11 /* ALetter */],
                [/*start*/ 0x114C7, /*end*/ 0x114C7, 11 /* ALetter */],
                [/*start*/ 0x114D0, /*end*/ 0x114D9, 9 /* Numeric */],
                [/*start*/ 0x11580, /*end*/ 0x115AE, 11 /* ALetter */],
                [/*start*/ 0x115AF, /*end*/ 0x115B1, 14 /* Extend */],
                [/*start*/ 0x115B2, /*end*/ 0x115B5, 14 /* Extend */],
                [/*start*/ 0x115B8, /*end*/ 0x115BB, 14 /* Extend */],
                [/*start*/ 0x115BC, /*end*/ 0x115BD, 14 /* Extend */],
                [/*start*/ 0x115BE, /*end*/ 0x115BE, 14 /* Extend */],
                [/*start*/ 0x115BF, /*end*/ 0x115C0, 14 /* Extend */],
                [/*start*/ 0x115D8, /*end*/ 0x115DB, 11 /* ALetter */],
                [/*start*/ 0x115DC, /*end*/ 0x115DD, 14 /* Extend */],
                [/*start*/ 0x11600, /*end*/ 0x1162F, 11 /* ALetter */],
                [/*start*/ 0x11630, /*end*/ 0x11632, 14 /* Extend */],
                [/*start*/ 0x11633, /*end*/ 0x1163A, 14 /* Extend */],
                [/*start*/ 0x1163B, /*end*/ 0x1163C, 14 /* Extend */],
                [/*start*/ 0x1163D, /*end*/ 0x1163D, 14 /* Extend */],
                [/*start*/ 0x1163E, /*end*/ 0x1163E, 14 /* Extend */],
                [/*start*/ 0x1163F, /*end*/ 0x11640, 14 /* Extend */],
                [/*start*/ 0x11644, /*end*/ 0x11644, 11 /* ALetter */],
                [/*start*/ 0x11650, /*end*/ 0x11659, 9 /* Numeric */],
                [/*start*/ 0x11680, /*end*/ 0x116AA, 11 /* ALetter */],
                [/*start*/ 0x116AB, /*end*/ 0x116AB, 14 /* Extend */],
                [/*start*/ 0x116AC, /*end*/ 0x116AC, 14 /* Extend */],
                [/*start*/ 0x116AD, /*end*/ 0x116AD, 14 /* Extend */],
                [/*start*/ 0x116AE, /*end*/ 0x116AF, 14 /* Extend */],
                [/*start*/ 0x116B0, /*end*/ 0x116B5, 14 /* Extend */],
                [/*start*/ 0x116B6, /*end*/ 0x116B6, 14 /* Extend */],
                [/*start*/ 0x116B7, /*end*/ 0x116B7, 14 /* Extend */],
                [/*start*/ 0x116B8, /*end*/ 0x116B8, 11 /* ALetter */],
                [/*start*/ 0x116C0, /*end*/ 0x116C9, 9 /* Numeric */],
                [/*start*/ 0x1171D, /*end*/ 0x1171F, 14 /* Extend */],
                [/*start*/ 0x11720, /*end*/ 0x11721, 14 /* Extend */],
                [/*start*/ 0x11722, /*end*/ 0x11725, 14 /* Extend */],
                [/*start*/ 0x11726, /*end*/ 0x11726, 14 /* Extend */],
                [/*start*/ 0x11727, /*end*/ 0x1172B, 14 /* Extend */],
                [/*start*/ 0x11730, /*end*/ 0x11739, 9 /* Numeric */],
                [/*start*/ 0x11800, /*end*/ 0x1182B, 11 /* ALetter */],
                [/*start*/ 0x1182C, /*end*/ 0x1182E, 14 /* Extend */],
                [/*start*/ 0x1182F, /*end*/ 0x11837, 14 /* Extend */],
                [/*start*/ 0x11838, /*end*/ 0x11838, 14 /* Extend */],
                [/*start*/ 0x11839, /*end*/ 0x1183A, 14 /* Extend */],
                [/*start*/ 0x118A0, /*end*/ 0x118DF, 11 /* ALetter */],
                [/*start*/ 0x118E0, /*end*/ 0x118E9, 9 /* Numeric */],
                [/*start*/ 0x118FF, /*end*/ 0x118FF, 11 /* ALetter */],
                [/*start*/ 0x119A0, /*end*/ 0x119A7, 11 /* ALetter */],
                [/*start*/ 0x119AA, /*end*/ 0x119D0, 11 /* ALetter */],
                [/*start*/ 0x119D1, /*end*/ 0x119D3, 14 /* Extend */],
                [/*start*/ 0x119D4, /*end*/ 0x119D7, 14 /* Extend */],
                [/*start*/ 0x119DA, /*end*/ 0x119DB, 14 /* Extend */],
                [/*start*/ 0x119DC, /*end*/ 0x119DF, 14 /* Extend */],
                [/*start*/ 0x119E0, /*end*/ 0x119E0, 14 /* Extend */],
                [/*start*/ 0x119E1, /*end*/ 0x119E1, 11 /* ALetter */],
                [/*start*/ 0x119E3, /*end*/ 0x119E3, 11 /* ALetter */],
                [/*start*/ 0x119E4, /*end*/ 0x119E4, 14 /* Extend */],
                [/*start*/ 0x11A00, /*end*/ 0x11A00, 11 /* ALetter */],
                [/*start*/ 0x11A01, /*end*/ 0x11A0A, 14 /* Extend */],
                [/*start*/ 0x11A0B, /*end*/ 0x11A32, 11 /* ALetter */],
                [/*start*/ 0x11A33, /*end*/ 0x11A38, 14 /* Extend */],
                [/*start*/ 0x11A39, /*end*/ 0x11A39, 14 /* Extend */],
                [/*start*/ 0x11A3A, /*end*/ 0x11A3A, 11 /* ALetter */],
                [/*start*/ 0x11A3B, /*end*/ 0x11A3E, 14 /* Extend */],
                [/*start*/ 0x11A47, /*end*/ 0x11A47, 14 /* Extend */],
                [/*start*/ 0x11A50, /*end*/ 0x11A50, 11 /* ALetter */],
                [/*start*/ 0x11A51, /*end*/ 0x11A56, 14 /* Extend */],
                [/*start*/ 0x11A57, /*end*/ 0x11A58, 14 /* Extend */],
                [/*start*/ 0x11A59, /*end*/ 0x11A5B, 14 /* Extend */],
                [/*start*/ 0x11A5C, /*end*/ 0x11A89, 11 /* ALetter */],
                [/*start*/ 0x11A8A, /*end*/ 0x11A96, 14 /* Extend */],
                [/*start*/ 0x11A97, /*end*/ 0x11A97, 14 /* Extend */],
                [/*start*/ 0x11A98, /*end*/ 0x11A99, 14 /* Extend */],
                [/*start*/ 0x11A9D, /*end*/ 0x11A9D, 11 /* ALetter */],
                [/*start*/ 0x11AC0, /*end*/ 0x11AF8, 11 /* ALetter */],
                [/*start*/ 0x11C00, /*end*/ 0x11C08, 11 /* ALetter */],
                [/*start*/ 0x11C0A, /*end*/ 0x11C2E, 11 /* ALetter */],
                [/*start*/ 0x11C2F, /*end*/ 0x11C2F, 14 /* Extend */],
                [/*start*/ 0x11C30, /*end*/ 0x11C36, 14 /* Extend */],
                [/*start*/ 0x11C38, /*end*/ 0x11C3D, 14 /* Extend */],
                [/*start*/ 0x11C3E, /*end*/ 0x11C3E, 14 /* Extend */],
                [/*start*/ 0x11C3F, /*end*/ 0x11C3F, 14 /* Extend */],
                [/*start*/ 0x11C40, /*end*/ 0x11C40, 11 /* ALetter */],
                [/*start*/ 0x11C50, /*end*/ 0x11C59, 9 /* Numeric */],
                [/*start*/ 0x11C72, /*end*/ 0x11C8F, 11 /* ALetter */],
                [/*start*/ 0x11C92, /*end*/ 0x11CA7, 14 /* Extend */],
                [/*start*/ 0x11CA9, /*end*/ 0x11CA9, 14 /* Extend */],
                [/*start*/ 0x11CAA, /*end*/ 0x11CB0, 14 /* Extend */],
                [/*start*/ 0x11CB1, /*end*/ 0x11CB1, 14 /* Extend */],
                [/*start*/ 0x11CB2, /*end*/ 0x11CB3, 14 /* Extend */],
                [/*start*/ 0x11CB4, /*end*/ 0x11CB4, 14 /* Extend */],
                [/*start*/ 0x11CB5, /*end*/ 0x11CB6, 14 /* Extend */],
                [/*start*/ 0x11D00, /*end*/ 0x11D06, 11 /* ALetter */],
                [/*start*/ 0x11D08, /*end*/ 0x11D09, 11 /* ALetter */],
                [/*start*/ 0x11D0B, /*end*/ 0x11D30, 11 /* ALetter */],
                [/*start*/ 0x11D31, /*end*/ 0x11D36, 14 /* Extend */],
                [/*start*/ 0x11D3A, /*end*/ 0x11D3A, 14 /* Extend */],
                [/*start*/ 0x11D3C, /*end*/ 0x11D3D, 14 /* Extend */],
                [/*start*/ 0x11D3F, /*end*/ 0x11D45, 14 /* Extend */],
                [/*start*/ 0x11D46, /*end*/ 0x11D46, 11 /* ALetter */],
                [/*start*/ 0x11D47, /*end*/ 0x11D47, 14 /* Extend */],
                [/*start*/ 0x11D50, /*end*/ 0x11D59, 9 /* Numeric */],
                [/*start*/ 0x11D60, /*end*/ 0x11D65, 11 /* ALetter */],
                [/*start*/ 0x11D67, /*end*/ 0x11D68, 11 /* ALetter */],
                [/*start*/ 0x11D6A, /*end*/ 0x11D89, 11 /* ALetter */],
                [/*start*/ 0x11D8A, /*end*/ 0x11D8E, 14 /* Extend */],
                [/*start*/ 0x11D90, /*end*/ 0x11D91, 14 /* Extend */],
                [/*start*/ 0x11D93, /*end*/ 0x11D94, 14 /* Extend */],
                [/*start*/ 0x11D95, /*end*/ 0x11D95, 14 /* Extend */],
                [/*start*/ 0x11D96, /*end*/ 0x11D96, 14 /* Extend */],
                [/*start*/ 0x11D97, /*end*/ 0x11D97, 14 /* Extend */],
                [/*start*/ 0x11D98, /*end*/ 0x11D98, 11 /* ALetter */],
                [/*start*/ 0x11DA0, /*end*/ 0x11DA9, 9 /* Numeric */],
                [/*start*/ 0x11EE0, /*end*/ 0x11EF2, 11 /* ALetter */],
                [/*start*/ 0x11EF3, /*end*/ 0x11EF4, 14 /* Extend */],
                [/*start*/ 0x11EF5, /*end*/ 0x11EF6, 14 /* Extend */],
                [/*start*/ 0x12000, /*end*/ 0x12399, 11 /* ALetter */],
                [/*start*/ 0x12400, /*end*/ 0x1246E, 11 /* ALetter */],
                [/*start*/ 0x12480, /*end*/ 0x12543, 11 /* ALetter */],
                [/*start*/ 0x13000, /*end*/ 0x1342E, 11 /* ALetter */],
                [/*start*/ 0x13430, /*end*/ 0x13438, 13 /* Format */],
                [/*start*/ 0x14400, /*end*/ 0x14646, 11 /* ALetter */],
                [/*start*/ 0x16800, /*end*/ 0x16A38, 11 /* ALetter */],
                [/*start*/ 0x16A40, /*end*/ 0x16A5E, 11 /* ALetter */],
                [/*start*/ 0x16A60, /*end*/ 0x16A69, 9 /* Numeric */],
                [/*start*/ 0x16AD0, /*end*/ 0x16AED, 11 /* ALetter */],
                [/*start*/ 0x16AF0, /*end*/ 0x16AF4, 14 /* Extend */],
                [/*start*/ 0x16B00, /*end*/ 0x16B2F, 11 /* ALetter */],
                [/*start*/ 0x16B30, /*end*/ 0x16B36, 14 /* Extend */],
                [/*start*/ 0x16B40, /*end*/ 0x16B43, 11 /* ALetter */],
                [/*start*/ 0x16B50, /*end*/ 0x16B59, 9 /* Numeric */],
                [/*start*/ 0x16B63, /*end*/ 0x16B77, 11 /* ALetter */],
                [/*start*/ 0x16B7D, /*end*/ 0x16B8F, 11 /* ALetter */],
                [/*start*/ 0x16E40, /*end*/ 0x16E7F, 11 /* ALetter */],
                [/*start*/ 0x16F00, /*end*/ 0x16F4A, 11 /* ALetter */],
                [/*start*/ 0x16F4F, /*end*/ 0x16F4F, 14 /* Extend */],
                [/*start*/ 0x16F50, /*end*/ 0x16F50, 11 /* ALetter */],
                [/*start*/ 0x16F51, /*end*/ 0x16F87, 14 /* Extend */],
                [/*start*/ 0x16F8F, /*end*/ 0x16F92, 14 /* Extend */],
                [/*start*/ 0x16F93, /*end*/ 0x16F9F, 11 /* ALetter */],
                [/*start*/ 0x16FE0, /*end*/ 0x16FE1, 11 /* ALetter */],
                [/*start*/ 0x16FE3, /*end*/ 0x16FE3, 11 /* ALetter */],
                [/*start*/ 0x1B000, /*end*/ 0x1B000, 17 /* Katakana */],
                [/*start*/ 0x1B164, /*end*/ 0x1B167, 17 /* Katakana */],
                [/*start*/ 0x1BC00, /*end*/ 0x1BC6A, 11 /* ALetter */],
                [/*start*/ 0x1BC70, /*end*/ 0x1BC7C, 11 /* ALetter */],
                [/*start*/ 0x1BC80, /*end*/ 0x1BC88, 11 /* ALetter */],
                [/*start*/ 0x1BC90, /*end*/ 0x1BC99, 11 /* ALetter */],
                [/*start*/ 0x1BC9D, /*end*/ 0x1BC9E, 14 /* Extend */],
                [/*start*/ 0x1BCA0, /*end*/ 0x1BCA3, 13 /* Format */],
                [/*start*/ 0x1D165, /*end*/ 0x1D166, 14 /* Extend */],
                [/*start*/ 0x1D167, /*end*/ 0x1D169, 14 /* Extend */],
                [/*start*/ 0x1D16D, /*end*/ 0x1D172, 14 /* Extend */],
                [/*start*/ 0x1D173, /*end*/ 0x1D17A, 13 /* Format */],
                [/*start*/ 0x1D17B, /*end*/ 0x1D182, 14 /* Extend */],
                [/*start*/ 0x1D185, /*end*/ 0x1D18B, 14 /* Extend */],
                [/*start*/ 0x1D1AA, /*end*/ 0x1D1AD, 14 /* Extend */],
                [/*start*/ 0x1D242, /*end*/ 0x1D244, 14 /* Extend */],
                [/*start*/ 0x1D400, /*end*/ 0x1D454, 11 /* ALetter */],
                [/*start*/ 0x1D456, /*end*/ 0x1D49C, 11 /* ALetter */],
                [/*start*/ 0x1D49E, /*end*/ 0x1D49F, 11 /* ALetter */],
                [/*start*/ 0x1D4A2, /*end*/ 0x1D4A2, 11 /* ALetter */],
                [/*start*/ 0x1D4A5, /*end*/ 0x1D4A6, 11 /* ALetter */],
                [/*start*/ 0x1D4A9, /*end*/ 0x1D4AC, 11 /* ALetter */],
                [/*start*/ 0x1D4AE, /*end*/ 0x1D4B9, 11 /* ALetter */],
                [/*start*/ 0x1D4BB, /*end*/ 0x1D4BB, 11 /* ALetter */],
                [/*start*/ 0x1D4BD, /*end*/ 0x1D4C3, 11 /* ALetter */],
                [/*start*/ 0x1D4C5, /*end*/ 0x1D505, 11 /* ALetter */],
                [/*start*/ 0x1D507, /*end*/ 0x1D50A, 11 /* ALetter */],
                [/*start*/ 0x1D50D, /*end*/ 0x1D514, 11 /* ALetter */],
                [/*start*/ 0x1D516, /*end*/ 0x1D51C, 11 /* ALetter */],
                [/*start*/ 0x1D51E, /*end*/ 0x1D539, 11 /* ALetter */],
                [/*start*/ 0x1D53B, /*end*/ 0x1D53E, 11 /* ALetter */],
                [/*start*/ 0x1D540, /*end*/ 0x1D544, 11 /* ALetter */],
                [/*start*/ 0x1D546, /*end*/ 0x1D546, 11 /* ALetter */],
                [/*start*/ 0x1D54A, /*end*/ 0x1D550, 11 /* ALetter */],
                [/*start*/ 0x1D552, /*end*/ 0x1D6A5, 11 /* ALetter */],
                [/*start*/ 0x1D6A8, /*end*/ 0x1D6C0, 11 /* ALetter */],
                [/*start*/ 0x1D6C2, /*end*/ 0x1D6DA, 11 /* ALetter */],
                [/*start*/ 0x1D6DC, /*end*/ 0x1D6FA, 11 /* ALetter */],
                [/*start*/ 0x1D6FC, /*end*/ 0x1D714, 11 /* ALetter */],
                [/*start*/ 0x1D716, /*end*/ 0x1D734, 11 /* ALetter */],
                [/*start*/ 0x1D736, /*end*/ 0x1D74E, 11 /* ALetter */],
                [/*start*/ 0x1D750, /*end*/ 0x1D76E, 11 /* ALetter */],
                [/*start*/ 0x1D770, /*end*/ 0x1D788, 11 /* ALetter */],
                [/*start*/ 0x1D78A, /*end*/ 0x1D7A8, 11 /* ALetter */],
                [/*start*/ 0x1D7AA, /*end*/ 0x1D7C2, 11 /* ALetter */],
                [/*start*/ 0x1D7C4, /*end*/ 0x1D7CB, 11 /* ALetter */],
                [/*start*/ 0x1D7CE, /*end*/ 0x1D7FF, 9 /* Numeric */],
                [/*start*/ 0x1DA00, /*end*/ 0x1DA36, 14 /* Extend */],
                [/*start*/ 0x1DA3B, /*end*/ 0x1DA6C, 14 /* Extend */],
                [/*start*/ 0x1DA75, /*end*/ 0x1DA75, 14 /* Extend */],
                [/*start*/ 0x1DA84, /*end*/ 0x1DA84, 14 /* Extend */],
                [/*start*/ 0x1DA9B, /*end*/ 0x1DA9F, 14 /* Extend */],
                [/*start*/ 0x1DAA1, /*end*/ 0x1DAAF, 14 /* Extend */],
                [/*start*/ 0x1E000, /*end*/ 0x1E006, 14 /* Extend */],
                [/*start*/ 0x1E008, /*end*/ 0x1E018, 14 /* Extend */],
                [/*start*/ 0x1E01B, /*end*/ 0x1E021, 14 /* Extend */],
                [/*start*/ 0x1E023, /*end*/ 0x1E024, 14 /* Extend */],
                [/*start*/ 0x1E026, /*end*/ 0x1E02A, 14 /* Extend */],
                [/*start*/ 0x1E100, /*end*/ 0x1E12C, 11 /* ALetter */],
                [/*start*/ 0x1E130, /*end*/ 0x1E136, 14 /* Extend */],
                [/*start*/ 0x1E137, /*end*/ 0x1E13D, 11 /* ALetter */],
                [/*start*/ 0x1E140, /*end*/ 0x1E149, 9 /* Numeric */],
                [/*start*/ 0x1E14E, /*end*/ 0x1E14E, 11 /* ALetter */],
                [/*start*/ 0x1E2C0, /*end*/ 0x1E2EB, 11 /* ALetter */],
                [/*start*/ 0x1E2EC, /*end*/ 0x1E2EF, 14 /* Extend */],
                [/*start*/ 0x1E2F0, /*end*/ 0x1E2F9, 9 /* Numeric */],
                [/*start*/ 0x1E800, /*end*/ 0x1E8C4, 11 /* ALetter */],
                [/*start*/ 0x1E8D0, /*end*/ 0x1E8D6, 14 /* Extend */],
                [/*start*/ 0x1E900, /*end*/ 0x1E943, 11 /* ALetter */],
                [/*start*/ 0x1E944, /*end*/ 0x1E94A, 14 /* Extend */],
                [/*start*/ 0x1E94B, /*end*/ 0x1E94B, 11 /* ALetter */],
                [/*start*/ 0x1E950, /*end*/ 0x1E959, 9 /* Numeric */],
                [/*start*/ 0x1EE00, /*end*/ 0x1EE03, 11 /* ALetter */],
                [/*start*/ 0x1EE05, /*end*/ 0x1EE1F, 11 /* ALetter */],
                [/*start*/ 0x1EE21, /*end*/ 0x1EE22, 11 /* ALetter */],
                [/*start*/ 0x1EE24, /*end*/ 0x1EE24, 11 /* ALetter */],
                [/*start*/ 0x1EE27, /*end*/ 0x1EE27, 11 /* ALetter */],
                [/*start*/ 0x1EE29, /*end*/ 0x1EE32, 11 /* ALetter */],
                [/*start*/ 0x1EE34, /*end*/ 0x1EE37, 11 /* ALetter */],
                [/*start*/ 0x1EE39, /*end*/ 0x1EE39, 11 /* ALetter */],
                [/*start*/ 0x1EE3B, /*end*/ 0x1EE3B, 11 /* ALetter */],
                [/*start*/ 0x1EE42, /*end*/ 0x1EE42, 11 /* ALetter */],
                [/*start*/ 0x1EE47, /*end*/ 0x1EE47, 11 /* ALetter */],
                [/*start*/ 0x1EE49, /*end*/ 0x1EE49, 11 /* ALetter */],
                [/*start*/ 0x1EE4B, /*end*/ 0x1EE4B, 11 /* ALetter */],
                [/*start*/ 0x1EE4D, /*end*/ 0x1EE4F, 11 /* ALetter */],
                [/*start*/ 0x1EE51, /*end*/ 0x1EE52, 11 /* ALetter */],
                [/*start*/ 0x1EE54, /*end*/ 0x1EE54, 11 /* ALetter */],
                [/*start*/ 0x1EE57, /*end*/ 0x1EE57, 11 /* ALetter */],
                [/*start*/ 0x1EE59, /*end*/ 0x1EE59, 11 /* ALetter */],
                [/*start*/ 0x1EE5B, /*end*/ 0x1EE5B, 11 /* ALetter */],
                [/*start*/ 0x1EE5D, /*end*/ 0x1EE5D, 11 /* ALetter */],
                [/*start*/ 0x1EE5F, /*end*/ 0x1EE5F, 11 /* ALetter */],
                [/*start*/ 0x1EE61, /*end*/ 0x1EE62, 11 /* ALetter */],
                [/*start*/ 0x1EE64, /*end*/ 0x1EE64, 11 /* ALetter */],
                [/*start*/ 0x1EE67, /*end*/ 0x1EE6A, 11 /* ALetter */],
                [/*start*/ 0x1EE6C, /*end*/ 0x1EE72, 11 /* ALetter */],
                [/*start*/ 0x1EE74, /*end*/ 0x1EE77, 11 /* ALetter */],
                [/*start*/ 0x1EE79, /*end*/ 0x1EE7C, 11 /* ALetter */],
                [/*start*/ 0x1EE7E, /*end*/ 0x1EE7E, 11 /* ALetter */],
                [/*start*/ 0x1EE80, /*end*/ 0x1EE89, 11 /* ALetter */],
                [/*start*/ 0x1EE8B, /*end*/ 0x1EE9B, 11 /* ALetter */],
                [/*start*/ 0x1EEA1, /*end*/ 0x1EEA3, 11 /* ALetter */],
                [/*start*/ 0x1EEA5, /*end*/ 0x1EEA9, 11 /* ALetter */],
                [/*start*/ 0x1EEAB, /*end*/ 0x1EEBB, 11 /* ALetter */],
                [/*start*/ 0x1F130, /*end*/ 0x1F149, 11 /* ALetter */],
                [/*start*/ 0x1F150, /*end*/ 0x1F169, 11 /* ALetter */],
                [/*start*/ 0x1F170, /*end*/ 0x1F189, 11 /* ALetter */],
                [/*start*/ 0x1F1E6, /*end*/ 0x1F1FF, 18 /* Regional_Indicator */],
                [/*start*/ 0x1F3FB, /*end*/ 0x1F3FF, 14 /* Extend */],
                [/*start*/ 0xE0001, /*end*/ 0xE0001, 13 /* Format */],
                [/*start*/ 0xE0020, /*end*/ 0xE007F, 14 /* Extend */],
                [/*start*/ 0xE0100, /*end*/ 0xE01EF, 14 /* Extend */],
            ];
        })(data = wordBreakers.data || (wordBreakers.data = {}));
    })(wordBreakers || (wordBreakers = {}));
    // Include the word-breaking data here:
    /// <reference path="./data.ts" />
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * Word breaker based on Unicode Standard Annex #29, Section 4.1:
         * Default Word Boundary Specification.
         *
         * @see http://unicode.org/reports/tr29/#Word_Boundaries
         * @see https://github.com/eddieantonio/unicode-default-word-boundary/tree/v12.0.0
         */
        function default_(text) {
            var boundaries = findBoundaries(text);
            if (boundaries.length == 0) {
                return [];
            }
            // All non-empty strings have at least TWO boundaries at the start and end of
            // the string.
            var spans = [];
            for (var i = 0; i < boundaries.length - 1; i++) {
                var start = boundaries[i];
                var end = boundaries[i + 1];
                var span = new LazySpan(text, start, end);
                if (isNonSpace(span.text)) {
                    spans.push(span);
                    // Preserve a sequence-final space if it exists.  Needed to signal "end of word".
                }
                else if (i == boundaries.length - 2) { // if "we just checked the final boundary"...
                    // We don't want to return the whitespace itself; the correct token is simply ''.
                    span = new LazySpan(text, end, end);
                    spans.push(span);
                }
            }
            return spans;
        }
        wordBreakers.default_ = default_;
        var WORD_BREAK_PROPERTY = wordBreakers.data.WORD_BREAK_PROPERTY;
        /**
         * A span that does not cut out the substring until it absolutely has to!
         */
        var LazySpan = /** @class */ (function () {
            function LazySpan(source, start, end) {
                this._source = source;
                this.start = start;
                this.end = end;
            }
            Object.defineProperty(LazySpan.prototype, "text", {
                get: function () {
                    return this._source.substring(this.start, this.end);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LazySpan.prototype, "length", {
                get: function () {
                    return this.end - this.start;
                },
                enumerable: true,
                configurable: true
            });
            return LazySpan;
        }());
        /**
         * Returns true when the chunk does not solely consist of whitespace.
         *
         * @param chunk a chunk of text. Starts and ends at word boundaries.
         */
        function isNonSpace(chunk) {
            return !Array.from(chunk).map(property).every(function (wb) {
                return (wb === 3 /* CR */ ||
                    wb === 1 /* LF */ ||
                    wb === 2 /* Newline */ ||
                    wb === 4 /* WSegSpace */);
            });
        }
        /**
         * Yields a series of string indices where a word break should
         * occur. That is, there should be a break BEFORE each string
         * index yielded by this generator.
         *
         * @param text Text to find word boundaries in.
         */
        function findBoundaries(text) {
            var _a, _b, _c;
            // WB1 and WB2: no boundaries if given an empty string.
            if (text.length === 0) {
                // There are no boundaries in an empty string!
                return [];
            }
            // This algorithm works by maintaining a sliding window of four SCALAR VALUES.
            //
            //  - Scalar values? JavaScript strings are NOT actually a string of
            //    Unicode code points; some characters are made up of TWO
            //    JavaScript indices. e.g.,
            //        "💩".length === 2;
            //        "💩"[0] === '\uD83D';
            //        "💩"[1] === '\uDCA9';
            //
            //    These characters that are represented by TWO indices are
            //    called "surrogate pairs". Since we don't want to be in the
            //    "middle" of a character, make sure we're always advancing
            //    by scalar values, and NOT indices. That means, we sometimes
            //    need to advance by TWO indices, not just one.
            //  - Four values? Some rules look at what's to the left of
            //    left, and some look at what's to the right of right. So
            //    keep track of this!
            var boundaries = [];
            var rightPos;
            var lookaheadPos = 0; // lookahead, one scalar value to the right of right.
            // Before the start of the string is also the start of the string.
            var lookbehind;
            var left = 19 /* sot */;
            var right = 19 /* sot */;
            var lookahead = wordbreakPropertyAt(0);
            // Count RIs to make sure we're not splitting emoji flags:
            var nConsecutiveRegionalIndicators = 0;
            do {
                // Shift all positions, one scalar value to the right.
                rightPos = lookaheadPos;
                lookaheadPos = positionAfter(lookaheadPos);
                // Shift all properties, one scalar value to the right.
                _a = [left, right, lookahead, wordbreakPropertyAt(lookaheadPos)], lookbehind = _a[0], left = _a[1], right = _a[2], lookahead = _a[3];
                // Break at the start and end of text, unless the text is empty.
                // WB1: Break at start of text...
                if (left === 19 /* sot */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // WB2: Break at the end of text...
                if (right === 20 /* eot */) {
                    boundaries.push(rightPos);
                    break; // Reached the end of the string. We're done!
                }
                // WB3: Do not break within CRLF:
                if (left === 3 /* CR */ && right === 1 /* LF */)
                    continue;
                // WB3b: Otherwise, break after...
                if (left === 2 /* Newline */ ||
                    left === 3 /* CR */ ||
                    left === 1 /* LF */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // WB3a: ...and before newlines
                if (right === 2 /* Newline */ ||
                    right === 3 /* CR */ ||
                    right === 1 /* LF */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // TODO: WB3c is not implemented, due to its complex, error-prone
                // implementation, requiring a ginormous regexp, and the fact that
                // the only thing it does is prevent big emoji sequences from being
                // split up, like 🧚🏼‍♂️
                // https://www.unicode.org/Public/emoji/12.0/emoji-zwj-sequences.txt
                // WB3d: Keep horizontal whitespace together
                if (left === 4 /* WSegSpace */ && right == 4 /* WSegSpace */)
                    continue;
                // WB4: Ignore format and extend characters
                // This is to keep grapheme clusters together!
                // See: Section 6.2: https://unicode.org/reports/tr29/#Grapheme_Cluster_and_Format_Rules
                // N.B.: The rule about "except after sot, CR, LF, and
                // Newline" already been by WB1, WB2, WB3a, and WB3b above.
                while (right === 13 /* Format */ ||
                    right === 14 /* Extend */ ||
                    right === 16 /* ZWJ */) {
                    // Continue advancing in the string, as if these
                    // characters do not exist. DO NOT update left and
                    // lookbehind however!
                    _b = [lookaheadPos, positionAfter(lookaheadPos)], rightPos = _b[0], lookaheadPos = _b[1];
                    _c = [lookahead, wordbreakPropertyAt(lookaheadPos)], right = _c[0], lookahead = _c[1];
                }
                // In ignoring the characters in the previous loop, we could
                // have fallen off the end of the string, so end the loop
                // prematurely if that happens!
                if (right === 20 /* eot */) {
                    boundaries.push(rightPos);
                    break;
                }
                // WB4 (continued): Lookahead must ALSO ignore these format,
                // extend, ZWJ characters!
                while (lookahead === 13 /* Format */ ||
                    lookahead === 14 /* Extend */ ||
                    lookahead === 16 /* ZWJ */) {
                    // Continue advancing in the string, as if these
                    // characters do not exist. DO NOT update left and right,
                    // however!
                    lookaheadPos = positionAfter(lookaheadPos);
                    lookahead = wordbreakPropertyAt(lookaheadPos);
                }
                // WB5: Do not break between most letters.
                if (isAHLetter(left) && isAHLetter(right))
                    continue;
                // Do not break across certain punctuation
                // WB6: (Don't break before apostrophes in contractions)
                if (isAHLetter(left) && isAHLetter(lookahead) &&
                    (right === 10 /* MidLetter */ || isMidNumLetQ(right)))
                    continue;
                // WB7: (Don't break after apostrophes in contractions)
                if (isAHLetter(lookbehind) && isAHLetter(right) &&
                    (left === 10 /* MidLetter */ || isMidNumLetQ(left)))
                    continue;
                // WB7a
                if (left === 15 /* Hebrew_Letter */ && right === 6 /* Single_Quote */)
                    continue;
                // WB7b
                if (left === 15 /* Hebrew_Letter */ && right === 5 /* Double_Quote */ &&
                    lookahead === 15 /* Hebrew_Letter */)
                    continue;
                // WB7c
                if (lookbehind === 15 /* Hebrew_Letter */ && left === 5 /* Double_Quote */ &&
                    right === 15 /* Hebrew_Letter */)
                    continue;
                // Do not break within sequences of digits, or digits adjacent to letters.
                // e.g., "3a" or "A3"
                // WB8
                if (left === 9 /* Numeric */ && right === 9 /* Numeric */)
                    continue;
                // WB9
                if (isAHLetter(left) && right === 9 /* Numeric */)
                    continue;
                // WB10
                if (left === 9 /* Numeric */ && isAHLetter(right))
                    continue;
                // Do not break within sequences, such as 3.2, 3,456.789
                // WB11
                if (lookbehind === 9 /* Numeric */ && right === 9 /* Numeric */ &&
                    (left === 7 /* MidNum */ || isMidNumLetQ(left)))
                    continue;
                // WB12
                if (left === 9 /* Numeric */ && lookahead === 9 /* Numeric */ &&
                    (right === 7 /* MidNum */ || isMidNumLetQ(right)))
                    continue;
                // WB13: Do not break between Katakana
                if (left === 17 /* Katakana */ && right === 17 /* Katakana */)
                    continue;
                // Do not break from extenders (e.g., U+202F NARROW NO-BREAK SPACE)
                // WB13a
                if ((isAHLetter(left) ||
                    left === 9 /* Numeric */ ||
                    left === 17 /* Katakana */ ||
                    left === 12 /* ExtendNumLet */) &&
                    right === 12 /* ExtendNumLet */)
                    continue;
                // WB13b
                if ((isAHLetter(right) ||
                    right === 9 /* Numeric */ ||
                    right === 17 /* Katakana */) && left === 12 /* ExtendNumLet */)
                    continue;
                // WB15 & WB16:
                // Do not break within emoji flag sequences. That is, do not break between
                // regional indicator (RI) symbols if there is an odd number of RI
                // characters before the break point.
                if (right === 18 /* Regional_Indicator */) {
                    // Emoji flags are actually composed of TWO scalar values, each being a
                    // "regional indicator". These indicators correspond to Latin letters. Put
                    // two of them together, and they spell out an ISO 3166-1-alpha-2 country
                    // code. Since these always come in pairs, NEVER split the pairs! So, if
                    // we happen to be inside the middle of an odd numbered of
                    // Regional_Indicators, DON'T SPLIT IT!
                    nConsecutiveRegionalIndicators += 1;
                    if ((nConsecutiveRegionalIndicators % 2) == 1) {
                        continue;
                    }
                }
                else {
                    nConsecutiveRegionalIndicators = 0;
                }
                // WB999: Otherwise, break EVERYWHERE (including around ideographs)
                boundaries.push(rightPos);
            } while (rightPos < text.length);
            return boundaries;
            ///// Internal utility functions /////
            /**
             * Returns the position of the start of the next scalar value. This jumps
             * over surrogate pairs.
             *
             * If asked for the character AFTER the end of the string, this always
             * returns the length of the string.
             */
            function positionAfter(pos) {
                if (pos >= text.length) {
                    return text.length;
                }
                else if (isStartOfSurrogatePair(text[pos])) {
                    return pos + 2;
                }
                return pos + 1;
            }
            /**
             * Return the value of the Word_Break property at the given string index.
             * @param pos position in the text.
             */
            function wordbreakPropertyAt(pos) {
                if (pos < 0) {
                    return 19 /* sot */; // Always "start of string" before the string starts!
                }
                else if (pos >= text.length) {
                    return 20 /* eot */; // Always "end of string" after the string ends!
                }
                else if (isStartOfSurrogatePair(text[pos])) {
                    // Surrogate pairs the next TWO items from the string!
                    return property(text[pos] + text[pos + 1]);
                }
                return property(text[pos]);
            }
            // Word_Break rule macros
            // See: https://unicode.org/reports/tr29/#WB_Rule_Macros
            function isAHLetter(prop) {
                return prop === 11 /* ALetter */ ||
                    prop === 15 /* Hebrew_Letter */;
            }
            function isMidNumLetQ(prop) {
                return prop === 8 /* MidNumLet */ ||
                    prop === 6 /* Single_Quote */;
            }
        }
        function isStartOfSurrogatePair(character) {
            var codeUnit = character.charCodeAt(0);
            return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;
        }
        /**
         * Return the Word_Break property value for a character.
         * Note that
         * @param character a scalar value
         */
        function property(character) {
            // This MUST be a scalar value.
            // TODO: remove dependence on character.codepointAt()?
            var codepoint = character.codePointAt(0);
            return searchForProperty(codepoint, 0, WORD_BREAK_PROPERTY.length - 1);
        }
        /**
         * Binary search for the word break property of a given CODE POINT.
         */
        function searchForProperty(codePoint, left, right) {
            // All items that are not found in the array are assigned the 'Other' property.
            if (right < left) {
                return 0 /* Other */;
            }
            var midpoint = left + ~~((right - left) / 2);
            var candidate = WORD_BREAK_PROPERTY[midpoint];
            if (codePoint < candidate[0 /* Start */]) {
                return searchForProperty(codePoint, left, midpoint - 1);
            }
            else if (codePoint > candidate[1 /* End */]) {
                return searchForProperty(codePoint, midpoint + 1, right);
            }
            else {
                // We found it!
                return candidate[2 /* Value */];
            }
        }
    })(wordBreakers || (wordBreakers = {}));
    // We cannot export a member whose name is a reserved word when
    // implementing a namespace, BUT we can manually make the
    // assignment and **declare** it as part of the namespace.
    wordBreakers['default'] = wordBreakers.default_;
    //# sourceMappingURL=index.js.map
}
/// <reference path="embedded_worker.d.ts" />
/// <reference path="worker-interface.d.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                // Unfortunately, importing like this loses all type information for the modules.
                // It's that, or massively overhaul lm-layer to be module-based instead of
                // namespace-based.
                var fs = require("fs");
                var vm = require("vm");
                var VirtualizedWorkerContext = /** @class */ (function () {
                    function VirtualizedWorkerContext() {
                        this.self = this;
                    }
                    VirtualizedWorkerContext.prototype.importScripts = function () {
                        var scriptNames = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            scriptNames[_i] = arguments[_i];
                        }
                        /* Use of vm.createContext and script.runInContext allow us to avoid
                          * polluting the global scope with imports.  When we throw away the
                          * context object, imported scripts will be automatically GC'd.
                          */
                        for (var _a = 0, scriptNames_1 = scriptNames; _a < scriptNames_1.length; _a++) {
                            var script = scriptNames_1[_a];
                            this.__importScriptString(fs.readFileSync(script, "UTF-8"));
                        }
                    };
                    VirtualizedWorkerContext.prototype.__importScriptString = function (scriptStr) {
                        var context = vm.createContext(this);
                        var script = new vm.Script(scriptStr);
                        script.runInContext(context);
                    };
                    return VirtualizedWorkerContext;
                }());
                /**
                 * Note:  this does not create an actual Worker, separate process, or thread.  Everything will
                 *        be executed in-line on a virtualized context.
                 *
                 *        In the future, it might be nice to use Node's Worker Threads implementation.
                 */
                var VirtualizedWorker = /** @class */ (function () {
                    function VirtualizedWorker(scriptStr) {
                        this._workerContext = new VirtualizedWorkerContext();
                        // Needs to exist before setting up the worker; must exist by `.install()`.
                        this._workerContext.postMessage = this.workerPostMessage.bind(this);
                        // Initialize the "worker".
                        this._workerContext.__importScriptString(scriptStr);
                    }
                    // Sends the worker's postMessage messages to the appropriate `onmessage` handler.
                    VirtualizedWorker.prototype.workerPostMessage = function (message) {
                        if (this.onmessage) {
                            this.onmessage({ data: message });
                        }
                    };
                    VirtualizedWorker.prototype.postMessage = function (message) {
                        var msgObj = { data: message };
                        var msgJSON = JSON.stringify(msgObj);
                        /*
                         * Execute the command within the virtualized worker's scope.  The worker's returned
                         * `postMessage` calls will still reach outside, as they have a reference to `this` via
                         * `postMessage` (which we've set to a bound `this.workerPostMessage`).
                         *
                         * Among other things, this will allow the worker to use its internal namespaces without issue.
                         */
                        var msgCommand = "onmessage(" + msgJSON + ")";
                        this._workerContext.__importScriptString(msgCommand);
                    };
                    VirtualizedWorker.prototype.terminate = function () {
                        this._workerContext = null;
                    };
                    return VirtualizedWorker;
                }());
                prediction.VirtualizedWorker = VirtualizedWorker;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
///<reference path="virtualizedWorker.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                var DefaultWorker = /** @class */ (function () {
                    function DefaultWorker() {
                    }
                    DefaultWorker.constructInstance = function () {
                        var scriptStr = prediction.LMLayer.unwrap(LMLayerWorkerCode);
                        var worker = new prediction.VirtualizedWorker(scriptStr);
                        return worker;
                    };
                    return DefaultWorker;
                }());
                prediction.DefaultWorker = DefaultWorker;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var has = Object.prototype.hasOwnProperty, prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() { }
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__)
        prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
    else
        emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
        emitter._events = new Events();
    else
        delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
        return names;
    for (name in (events = this._events)) {
        if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
        return [];
    if (handlers.fn)
        return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
    }
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
        return 0;
    if (listeners.fn)
        return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
        return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once)
            this.removeListener(event, listeners.fn, undefined, true);
        switch (len) {
            case 1: return listeners.fn.call(listeners.context), true;
            case 2: return listeners.fn.call(listeners.context, a1), true;
            case 3: return listeners.fn.call(listeners.context, a1, a2), true;
            case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
    }
    else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
            if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, undefined, true);
            switch (len) {
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args)
                        for (j = 1, args = new Array(len - 1); j < len; j++) {
                            args[j - 1] = arguments[j];
                        }
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
        return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn &&
            (!once || listeners.once) &&
            (!context || listeners.context === context)) {
            clearEvent(this, evt);
        }
    }
    else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn ||
                (once && !listeners[i].once) ||
                (context && listeners[i].context !== context)) {
                events.push(listeners[i]);
            }
        }
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
        else
            clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
            clearEvent(this, evt);
    }
    else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
//
// Expose the module.
//
if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
}
// Implements Node's EventEmitter class and related module components in a near
// browser-compatible way.  (Just requires a blank 'module' object on the window.)
///<reference path="../../node_modules/eventemitter3/index.js" />
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
/**
 * Constructs a string from one or more Unicode character codepoint values
 * passed as integer parameters.
 *
 * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
 * @return {string|null}      The new String object.
 */
String.kmwFromCharCode = function (cp0) {
    var chars = [], i;
    for (i = 0; i < arguments.length; i++) {
        var c = Number(arguments[i]);
        if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
            throw new RangeError("Invalid code point " + c);
        }
        if (c < 0x10000) {
            chars.push(c);
        }
        else {
            c -= 0x10000;
            chars.push((c >> 10) + 0xD800);
            chars.push((c % 0x400) + 0xDC00);
        }
    }
    return String.fromCharCode.apply(undefined, chars);
};
/**
 * Returns a number indicating the Unicode value of the character at the given
 * code point index, with support for supplementary plane characters.
 *
 * @param  {number}  codePointIndex  The code point index into the string (not
                                     the code unit index) to return
 * @return {number}                  The Unicode character value
 */
String.prototype.kmwCharCodeAt = function (codePointIndex) {
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0 || codePointIndex >= str.length) {
        return NaN;
    }
    for (var i = 0; i < codePointIndex; i++) {
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        if (codeUnitIndex === null)
            return NaN;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
        }
    }
    return first;
};
/**
 * Returns the code point index within the calling String object of the first occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  [fromIndex]    Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.indexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the code point index within the calling String object of the last occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  fromIndex      Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the length of the string in code points, as opposed to code units.
 *
 * @return {number}                 The length of the string in code points
 */
String.prototype.kmwLength = function () {
    var str = String(this);
    if (str.length == 0)
        return 0;
    for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return i;
};
/**
 * Extracts a section of a string and returns a new string.
 *
 * @param  {number}  beginSlice    The start code point index in the string to
 *                                 extract from
 * @param  {number}  endSlice      Optional end code point index in the string
 *                                 to extract to
 * @return {string}                The substring as selected by beginSlice and
 *                                 endSlice
 */
String.prototype.kmwSlice = function (beginSlice, endSlice) {
    var str = String(this);
    var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
    var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
    if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
        return '';
    else
        return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
};
/**
 * Returns the characters in a string beginning at the specified location through
 * the specified number of characters.
 *
 * @param  {number}  start         The start code point index in the string to
 *                                 extract from
 * @param  {number=}  length        Optional length to extract
 * @return {string}                The substring as selected by start and length
 */
String.prototype.kmwSubstr = function (start, length) {
    var str = String(this);
    if (start < 0) {
        start = str.kmwLength() + start;
    }
    if (start < 0)
        start = 0;
    var startCodeUnit = str.kmwCodePointToCodeUnit(start);
    var endCodeUnit = startCodeUnit;
    if (startCodeUnit === null)
        return '';
    if (arguments.length < 2) {
        endCodeUnit = str.length;
    }
    else {
        for (var i = 0; i < length; i++)
            endCodeUnit = str.kmwNextChar(endCodeUnit);
    }
    if (endCodeUnit === null)
        return str.substring(startCodeUnit);
    else
        return str.substring(startCodeUnit, endCodeUnit);
};
/**
 * Returns the characters in a string between two indexes into the string.
 *
 * @param  {number}  indexA        The start code point index in the string to
 *                                 extract from
 * @param  {number}  indexB        The end code point index in the string to
 *                                 extract to
 * @return {string}                The substring as selected by indexA and indexB
 */
String.prototype.kmwSubstring = function (indexA, indexB) {
    var str = String(this), indexACodeUnit, indexBCodeUnit;
    if (typeof (indexB) == 'undefined') {
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.length;
    }
    else {
        if (indexA > indexB) {
            var c = indexA;
            indexA = indexB;
            indexB = c;
        }
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
    }
    if (isNaN(indexACodeUnit) || indexACodeUnit === null)
        indexACodeUnit = 0;
    if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
        indexBCodeUnit = str.length;
    return str.substring(indexACodeUnit, indexBCodeUnit);
};
/*
  Helper functions
*/
/**
 * Returns the code unit index for the next code point in the string, accounting for
 * supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to increment
 * @return {number|null}                 The index of the next code point in the string,
 *                                       in code units
 */
String.prototype.kmwNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            if (codeUnitIndex == str.length - 2) {
                return null;
            }
            return codeUnitIndex + 2;
        }
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string, accounting
 * for supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to decrement
 * @return {number|null}                 The index of the previous code point in the
 *                                       string, in code units
*/
String.prototype.kmwPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    var second = str.charCodeAt(codeUnitIndex - 1);
    if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
        var first = str.charCodeAt(codeUnitIndex - 2);
        if (first >= 0xD800 && first <= 0xDBFF) {
            return codeUnitIndex - 2;
        }
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the corresponding code unit index to the code point index passed
 *
 * @param  {number|null} codePointIndex  A code point index in the string
 * @return {number|null}                 The corresponding code unit index
 */
String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
    if (codePointIndex === null)
        return null;
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0) {
        codeUnitIndex = str.length;
        for (var i = 0; i > codePointIndex; i--)
            codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
        return codeUnitIndex;
    }
    if (codePointIndex == str.kmwLength())
        return str.length;
    for (var i = 0; i < codePointIndex; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return codeUnitIndex;
};
/**
 * Returns the corresponding code point index to the code unit index passed
 *
 * @param  {number|null}  codeUnitIndex  A code unit index in the string
 * @return {number|null}                 The corresponding code point index
 */
String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null)
        return null;
    else if (codeUnitIndex == 0)
        return 0;
    else if (codeUnitIndex < 0)
        return str.substr(codeUnitIndex).kmwLength();
    else
        return str.substr(0, codeUnitIndex).kmwLength();
};
/**
 * Returns the character at a the code point index passed
 *
 * @param  {number}  codePointIndex  A code point index in the string
 * @return {string}                  The corresponding character
 */
String.prototype.kmwCharAt = function (codePointIndex) {
    var str = String(this);
    if (codePointIndex >= 0)
        return str.kmwSubstr(codePointIndex, 1);
    else
        return '';
};
/**
 * String prototype library extensions for basic plane characters,
 * to simplify enabling or disabling supplementary plane functionality (I3319)
 */
/**
 * Returns the code unit index for the next code point in the string
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string
 *
 * @param  {number}  codeUnitIndex    A code unit index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the code unit index for a code point index
 *
 * @param  {number}  codePointIndex   A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
    return codePointIndex;
};
/**
 * Returns the code point index for a code unit index
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
    return codeUnitIndex;
};
/**
 * Returns the length of a BMP string
 *
 * @return {number}                   The length in code points
 */
String.prototype.kmwBMPLength = function () {
    var str = String(this);
    return str.length;
};
/**
 * Returns a substring
 *
 * @param  {number}  n
 * @param  {number=}  ln
 * @return {string}
 */
String.prototype.kmwBMPSubstr = function (n, ln) {
    var str = String(this);
    if (n > -1)
        return str.substr(n, ln);
    else
        return str.substr(str.length + n, -n);
};
/**
 * Enable or disable supplementary plane string handling
 *
 * @param  {boolean}  bEnable
 */
String.kmwEnableSupplementaryPlane = function (bEnable) {
    var p = String.prototype;
    String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
    p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
    p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
    p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
    p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
    p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
    p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
    p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
    p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
    p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
    p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
    p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
    p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
};
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            text.Codes = {
                // Define Keyman Developer modifier bit-flags (exposed for use by other modules)
                modifierCodes: {
                    "LCTRL": 0x0001,
                    "RCTRL": 0x0002,
                    "LALT": 0x0004,
                    "RALT": 0x0008,
                    "SHIFT": 0x0010,
                    "CTRL": 0x0020,
                    "ALT": 0x0040,
                    "CAPS": 0x0100,
                    "NO_CAPS": 0x0200,
                    "NUM_LOCK": 0x0400,
                    "NO_NUM_LOCK": 0x0800,
                    "SCROLL_LOCK": 0x1000,
                    "NO_SCROLL_LOCK": 0x2000,
                    "VIRTUAL_KEY": 0x4000
                },
                modifierBitmasks: {
                    "ALL": 0x007F,
                    "ALT_GR_SIM": (0x0001 | 0x0004),
                    "CHIRAL": 0x001F,
                    "IS_CHIRAL": 0x000F,
                    "NON_CHIRAL": 0x0070 // The default bitmask, for non-chiral keyboards
                },
                stateBitmasks: {
                    "ALL": 0x3F00,
                    "CAPS": 0x0300,
                    "NUM_LOCK": 0x0C00,
                    "SCROLL_LOCK": 0x3000
                },
                // Define standard keycode numbers (exposed for use by other modules)
                keyCodes: {
                    "K_BKSP": 8, "K_TAB": 9, "K_ENTER": 13,
                    "K_SHIFT": 16, "K_CONTROL": 17, "K_ALT": 18, "K_PAUSE": 19, "K_CAPS": 20,
                    "K_ESC": 27, "K_SPACE": 32, "K_PGUP": 33,
                    "K_PGDN": 34, "K_END": 35, "K_HOME": 36, "K_LEFT": 37, "K_UP": 38,
                    "K_RIGHT": 39, "K_DOWN": 40, "K_SEL": 41, "K_PRINT": 42, "K_EXEC": 43,
                    "K_INS": 45, "K_DEL": 46, "K_HELP": 47, "K_0": 48,
                    "K_1": 49, "K_2": 50, "K_3": 51, "K_4": 52, "K_5": 53, "K_6": 54, "K_7": 55,
                    "K_8": 56, "K_9": 57, "K_A": 65, "K_B": 66, "K_C": 67, "K_D": 68, "K_E": 69,
                    "K_F": 70, "K_G": 71, "K_H": 72, "K_I": 73, "K_J": 74, "K_K": 75, "K_L": 76,
                    "K_M": 77, "K_N": 78, "K_O": 79, "K_P": 80, "K_Q": 81, "K_R": 82, "K_S": 83,
                    "K_T": 84, "K_U": 85, "K_V": 86, "K_W": 87, "K_X": 88, "K_Y": 89, "K_Z": 90,
                    "K_NP0": 96, "K_NP1": 97, "K_NP2": 98,
                    "K_NP3": 99, "K_NP4": 100, "K_NP5": 101, "K_NP6": 102,
                    "K_NP7": 103, "K_NP8": 104, "K_NP9": 105, "K_NPSTAR": 106,
                    "K_NPPLUS": 107, "K_SEPARATOR": 108, "K_NPMINUS": 109, "K_NPDOT": 110,
                    "K_NPSLASH": 111, "K_F1": 112, "K_F2": 113, "K_F3": 114, "K_F4": 115,
                    "K_F5": 116, "K_F6": 117, "K_F7": 118, "K_F8": 119, "K_F9": 120,
                    "K_F10": 121, "K_F11": 122, "K_F12": 123, "K_NUMLOCK": 144, "K_SCROLL": 145,
                    "K_LSHIFT": 160, "K_RSHIFT": 161, "K_LCONTROL": 162, "K_RCONTROL": 163,
                    "K_LALT": 164, "K_RALT": 165,
                    "K_COLON": 186, "K_EQUAL": 187, "K_COMMA": 188, "K_HYPHEN": 189,
                    "K_PERIOD": 190, "K_SLASH": 191, "K_BKQUOTE": 192,
                    "K_LBRKT": 219, "K_BKSLASH": 220, "K_RBRKT": 221,
                    "K_QUOTE": 222, "K_oE2": 226, "K_OE2": 226,
                    "K_LOPT": 50001, "K_ROPT": 50002,
                    "K_NUMERALS": 50003, "K_SYMBOLS": 50004, "K_CURRENCIES": 50005,
                    "K_UPPER": 50006, "K_LOWER": 50007, "K_ALPHA": 50008,
                    "K_SHIFTED": 50009, "K_ALTGR": 50010,
                    "K_TABBACK": 50011, "K_TABFWD": 50012
                },
                codesUS: [
                    ['0123456789', ';=,-./`', '[\\]\''],
                    [')!@#$%^&*(', ':+<_>?~', '{|}"']
                ]
            };
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var Browser;
            (function (Browser) {
                Browser["Chrome"] = "chrome";
                Browser["Edge"] = "edge";
                Browser["Firefox"] = "firefox";
                Browser["Native"] = "native";
                Browser["Opera"] = "opera";
                Browser["Safari"] = "safari";
                Browser["Other"] = "other";
            })(Browser = text.Browser || (text.Browser = {}));
            var OperatingSystem;
            (function (OperatingSystem) {
                OperatingSystem["Windows"] = "windows";
                OperatingSystem["macOS"] = "macosx";
                OperatingSystem["Linux"] = "linux";
                OperatingSystem["Android"] = "android";
                OperatingSystem["iOS"] = "ios";
                OperatingSystem["Other"] = "other";
            })(OperatingSystem = text.OperatingSystem || (text.OperatingSystem = {}));
            var FormFactor;
            (function (FormFactor) {
                FormFactor["Desktop"] = "desktop";
                FormFactor["Phone"] = "phone";
                FormFactor["Tablet"] = "tablet";
            })(FormFactor = text.FormFactor || (text.FormFactor = {}));
            /**
             * This class provides an abstract version of com.keyman.Device that is core-friendly,
             * containing only the information needed by web-core for text processing use, devoid
             * of any direct references to the DOM.
             */
            var EngineDeviceSpec = /** @class */ (function () {
                function EngineDeviceSpec(browser, formFactor, OS, touchable) {
                    switch (browser.toLowerCase()) {
                        case Browser.Chrome:
                        case Browser.Edge:
                        case Browser.Firefox:
                        case Browser.Native:
                        case Browser.Opera:
                        case Browser.Safari:
                            this.browser = browser.toLowerCase();
                            break;
                        default:
                            this.browser = Browser.Other;
                    }
                    switch (formFactor.toLowerCase()) {
                        case FormFactor.Desktop:
                        case FormFactor.Phone:
                        case FormFactor.Tablet:
                            this.formFactor = formFactor.toLowerCase();
                            break;
                        default:
                            throw ("Invalid form factor specified for device: " + formFactor);
                    }
                    switch (OS.toLowerCase()) {
                        case OperatingSystem.Windows.toLowerCase():
                        case OperatingSystem.macOS.toLowerCase():
                        case OperatingSystem.Linux.toLowerCase():
                        case OperatingSystem.Android.toLowerCase():
                        case OperatingSystem.iOS.toLowerCase():
                            this.OS = OS.toLowerCase();
                            break;
                        default:
                            this.OS = OperatingSystem.Other;
                    }
                    this.touchable = touchable;
                }
                return EngineDeviceSpec;
            }());
            text.EngineDeviceSpec = EngineDeviceSpec;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            // Defines the base Deadkey-tracking object.
            var Deadkey = /** @class */ (function () {
                function Deadkey(pos, id) {
                    this.p = pos;
                    this.d = id;
                    this.o = Deadkey.ordinalSeed++;
                }
                Deadkey.prototype.match = function (p, d) {
                    var result = (this.p == p && this.d == d);
                    return result;
                };
                Deadkey.prototype.set = function () {
                    this.matched = 1;
                };
                Deadkey.prototype.reset = function () {
                    this.matched = 0;
                };
                Deadkey.prototype.before = function (other) {
                    return this.o < other.o;
                };
                Deadkey.prototype.clone = function () {
                    var dk = new Deadkey(this.p, this.d);
                    dk.o = this.o;
                    return dk;
                };
                Deadkey.ordinalSeed = 0;
                /**
                 * Sorts the deadkeys in reverse order.
                 */
                Deadkey.sortFunc = function (a, b) {
                    // We want descending order, so we want 'later' deadkeys first.
                    if (a.p != b.p) {
                        return b.p - a.p;
                    }
                    else {
                        return b.o - a.o;
                    }
                };
                return Deadkey;
            }());
            text.Deadkey = Deadkey;
            // Object-orients deadkey management.
            var DeadkeyTracker = /** @class */ (function () {
                function DeadkeyTracker() {
                    this.dks = [];
                }
                DeadkeyTracker.prototype.toSortedArray = function () {
                    this.dks = this.dks.sort(Deadkey.sortFunc);
                    return [].concat(this.dks);
                };
                DeadkeyTracker.prototype.clone = function () {
                    var dkt = new DeadkeyTracker();
                    var dks = this.toSortedArray();
                    // Make sure to clone the deadkeys themselves - the Deadkey object is mutable.
                    dkt.dks = [];
                    dks.forEach(function (value) {
                        dkt.dks.push(value.clone());
                    });
                    return dkt;
                };
                /**
                 * Function     isMatch
                 * Scope        Public
                 * @param       {number}      caretPos  current cursor position
                 * @param       {number}      n         expected offset of deadkey from cursor
                 * @param       {number}      d         deadkey
                 * @return      {boolean}               True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                DeadkeyTracker.prototype.isMatch = function (caretPos, n, d) {
                    if (this.dks.length == 0) {
                        return false; // I3318
                    }
                    var sp = caretPos;
                    n = sp - n;
                    for (var i = 0; i < this.dks.length; i++) {
                        // Don't re-match an already-matched deadkey.  It's possible to have two identical 
                        // entries, and they should be kept separately.
                        if (this.dks[i].match(n, d) && !this.dks[i].matched) {
                            this.dks[i].set();
                            // Assumption:  since we match the first possible entry in the array, we
                            // match the entry with the lower ordinal - the 'first' deadkey in the position.
                            return true; // I3318
                        }
                    }
                    this.resetMatched(); // I3318
                    return false;
                };
                DeadkeyTracker.prototype.add = function (dk) {
                    this.dks = this.dks.concat(dk);
                };
                DeadkeyTracker.prototype.remove = function (dk) {
                    var index = this.dks.indexOf(dk);
                    this.dks.splice(index, 1);
                };
                DeadkeyTracker.prototype.clear = function () {
                    this.dks = [];
                };
                DeadkeyTracker.prototype.resetMatched = function () {
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        dk.reset();
                    }
                };
                DeadkeyTracker.prototype.deleteMatched = function () {
                    for (var Li = 0; Li < this.dks.length; Li++) {
                        if (this.dks[Li].matched) {
                            this.dks.splice(Li--, 1); // Don't forget to decrement!
                        }
                    }
                };
                /**
                 * Function     adjustPositions (formerly _DeadkeyAdjustPos)
                 * Scope        Private
                 * @param       {number}      Lstart      start position in context
                 * @param       {number}      Ldelta      characters to adjust by
                 * Description  Adjust saved positions of deadkeys in context
                 */
                DeadkeyTracker.prototype.adjustPositions = function (Lstart, Ldelta) {
                    if (Ldelta == 0) {
                        return;
                    }
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        if (dk.p > Lstart) {
                            dk.p += Ldelta;
                        }
                    }
                };
                DeadkeyTracker.prototype.count = function () {
                    return this.dks.length;
                };
                return DeadkeyTracker;
            }());
            text.DeadkeyTracker = DeadkeyTracker;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines KMW's string extension functions.
///<reference path="../text/kmwstring.ts" />
// Defines deadkey management in a manner attachable to each element interface.
///<reference path="../text/deadkeys.ts" />
// Defines the KeyEvent type.
///<reference path="keyEvent.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text_1) {
            var TextTransform = /** @class */ (function () {
                function TextTransform(insert, deleteLeft, deleteRight) {
                    this.insert = insert;
                    this.deleteLeft = deleteLeft;
                    this.deleteRight = deleteRight || 0;
                }
                TextTransform.nil = new TextTransform('', 0, 0);
                return TextTransform;
            }());
            text_1.TextTransform = TextTransform;
            var Transcription = /** @class */ (function () {
                function Transcription(keystroke, transform, preInput, alternates /*, removedDks: Deadkey[], insertedDks: Deadkey[]*/) {
                    var token = this.token = Transcription.tokenSeed++;
                    this.keystroke = keystroke;
                    this.transform = transform;
                    this.alternates = alternates;
                    this.preInput = preInput;
                    this.transform.id = this.token;
                    // Assign the ID to each alternate, as well.
                    if (alternates) {
                        alternates.forEach(function (alt) {
                            alt.sample.id = token;
                        });
                    }
                }
                Transcription.tokenSeed = 0;
                return Transcription;
            }());
            text_1.Transcription = Transcription;
            var OutputTarget = /** @class */ (function () {
                function OutputTarget() {
                    this._dks = new text.DeadkeyTracker();
                }
                Object.defineProperty(OutputTarget.prototype, "isSynthetic", {
                    /**
                     * Signifies that this OutputTarget has no default key processing behaviors.  This should be false
                     * for OutputTargets backed by web elements like HTMLInputElement or HTMLTextAreaElement.
                     */
                    get: function () {
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                OutputTarget.prototype.resetContext = function () {
                    this.deadkeys().clear();
                };
                OutputTarget.prototype.deadkeys = function () {
                    return this._dks;
                };
                OutputTarget.prototype.hasDeadkeyMatch = function (n, d) {
                    return this.deadkeys().isMatch(this.getDeadkeyCaret(), n, d);
                };
                OutputTarget.prototype.insertDeadkeyBeforeCaret = function (d) {
                    var dk = new text_1.Deadkey(this.getDeadkeyCaret(), d);
                    this.deadkeys().add(dk);
                };
                /**
                 * Should be called by each output target immediately before text mutation operations occur.
                 *
                 * Maintains solutions to old issues:  I3318,I3319
                 * @param {number} delta  Use negative values if characters were deleted, positive if characters were added.
                 */
                OutputTarget.prototype.adjustDeadkeys = function (delta) {
                    this.deadkeys().adjustPositions(this.getDeadkeyCaret(), delta);
                };
                /**
                 * Needed to properly clone deadkeys for use with Mock element interfaces toward predictive text purposes.
                 * @param {object}  dks   An existing set of deadkeys to deep-copy for use by this element interface.
                 */
                OutputTarget.prototype.setDeadkeys = function (dks) {
                    this._dks = dks.clone();
                };
                /**
                 * Determines the basic operations needed to reconstruct the current OutputTarget's text from the prior state specified
                 * by another OutputTarget based on their text and caret positions.
                 *
                 * This is designed for use as a "before and after" comparison to determine the effect of a single keyboard rule at a time.
                 * As such, it assumes that the caret is immediately after any inserted text.
                 * @param from An output target (preferably a Mock) representing the prior state of the input/output system.
                 */
                OutputTarget.prototype.buildTransformFrom = function (original) {
                    var to = this.getText();
                    var from = original.getText();
                    var fromCaret = original.getDeadkeyCaret();
                    var toCaret = this.getDeadkeyCaret();
                    // Step 1:  Determine the number of left-deletions.
                    for (var newCaret = 0; newCaret < fromCaret; newCaret++) {
                        if (from._kmwCharAt(newCaret) != to._kmwCharAt(newCaret)) {
                            break;
                        }
                    }
                    var deletedLeft = fromCaret - newCaret;
                    // Step 2:  Determine the other properties.
                    // Since the 'after' OutputTarget's caret indicates the end of any inserted text, we
                    // can easily calculate the rest.
                    var insertedLength = toCaret - newCaret;
                    var delta = to._kmwSubstr(newCaret, insertedLength);
                    var undeletedRight = to._kmwLength() - toCaret;
                    var originalRight = from._kmwLength() - fromCaret;
                    return new TextTransform(delta, deletedLeft, originalRight - undeletedRight);
                };
                OutputTarget.prototype.buildTranscriptionFrom = function (original, keyEvent, alternates) {
                    var transform = this.buildTransformFrom(original);
                    // If we ever decide to re-add deadkey tracking, this is the place for it.
                    return new Transcription(keyEvent, transform, Mock.from(original), alternates);
                };
                /**
                 * Restores the `OutputTarget` to the indicated state.  Designed for use with `Transcription.preInput`.
                 * @param original An `OutputTarget` (usually a `Mock`).
                 */
                OutputTarget.prototype.restoreTo = function (original) {
                    //
                    this.setTextBeforeCaret(original.getTextBeforeCaret());
                    this.setTextAfterCaret(original.getTextAfterCaret());
                    // Also, restore the deadkeys!
                    this._dks = original._dks.clone();
                };
                OutputTarget.prototype.apply = function (transform) {
                    if (transform.deleteRight) {
                        this.setTextAfterCaret(this.getTextAfterCaret()._kmwSubstr(transform.deleteRight));
                    }
                    if (transform.deleteLeft) {
                        this.deleteCharsBeforeCaret(transform.deleteLeft);
                    }
                    if (transform.insert) {
                        this.insertTextBeforeCaret(transform.insert);
                    }
                    // We assume that all deadkeys are invalidated after applying a Transform, since
                    // prediction implies we'll be completing a word, post-deadkeys.
                    this._dks.clear();
                };
                /**
                 * Helper to `restoreTo` - allows directly setting the 'before' context to that of another
                 * `OutputTarget`.
                 * @param s
                 */
                OutputTarget.prototype.setTextBeforeCaret = function (s) {
                    // This one's easy enough to provide a default implementation for.
                    this.deleteCharsBeforeCaret(this.getTextBeforeCaret()._kmwLength());
                    this.insertTextBeforeCaret(s);
                };
                /**
                 * Saves element-specific state properties prone to mutation, enabling restoration after
                 * text-output operations.
                 */
                OutputTarget.prototype.saveProperties = function () {
                    // Most element interfaces won't need anything here.
                };
                /**
                 * Restores previously-saved element-specific state properties.  Designed for use after text-output
                 * ops to facilitate more-seamless web-dev and user interactions.
                 */
                OutputTarget.prototype.restoreProperties = function () {
                    // Most element interfaces won't need anything here. 
                };
                return OutputTarget;
            }());
            text_1.OutputTarget = OutputTarget;
            // Due to some interesting requirements on compile ordering in TS,
            // this needs to be in the same file as OutputTarget now.
            var Mock = /** @class */ (function (_super) {
                __extends(Mock, _super);
                function Mock(text, caretPos) {
                    var _this = _super.call(this) || this;
                    _this.text = text ? text : "";
                    var defaultLength = _this.text._kmwLength();
                    _this.caretIndex = caretPos ? caretPos : defaultLength;
                    return _this;
                }
                // Clones the state of an existing EditableElement, creating a Mock version of its state.
                Mock.from = function (outputTarget) {
                    var preText = outputTarget.getTextBeforeCaret();
                    var caretIndex = preText._kmwLength();
                    // We choose to ignore (rather, pre-emptively remove) any actively-selected text,
                    // as since it's always removed instantly during any text mutation operations.
                    var clone = new Mock(preText + outputTarget.getTextAfterCaret(), caretIndex);
                    clone.setDeadkeys(outputTarget.deadkeys());
                    return clone;
                };
                Mock.prototype.clearSelection = function () {
                    return;
                };
                Mock.prototype.invalidateSelection = function () {
                    return;
                };
                Mock.prototype.hasSelection = function () {
                    return true;
                };
                Mock.prototype.getDeadkeyCaret = function () {
                    return this.caretIndex;
                };
                Mock.prototype.setDeadkeyCaret = function (index) {
                    if (index < 0 || index > this.text._kmwLength()) {
                        throw new Error("Provided caret index is out of range.");
                    }
                    this.caretIndex = index;
                };
                Mock.prototype.getTextBeforeCaret = function () {
                    return this.text.kmwSubstr(0, this.caretIndex);
                };
                Mock.prototype.getTextAfterCaret = function () {
                    return this.text.kmwSubstr(this.caretIndex);
                };
                Mock.prototype.getText = function () {
                    return this.text;
                };
                Mock.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn >= 0) {
                        if (dn > this.caretIndex) {
                            dn = this.caretIndex;
                        }
                        this.text = this.text.kmwSubstr(0, this.caretIndex - dn) + this.getTextAfterCaret();
                        this.caretIndex -= dn;
                    }
                };
                Mock.prototype.insertTextBeforeCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s + this.getTextAfterCaret();
                    this.caretIndex += s.kmwLength();
                };
                Mock.prototype.handleNewlineAtCaret = function () {
                    this.insertTextBeforeCaret('\n');
                };
                Mock.prototype.setTextAfterCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s;
                };
                Mock.prototype.doInputEvent = function () {
                    // Mock isn't backed by an element, so it won't have any event listeners.
                };
                return Mock;
            }(OutputTarget));
            text_1.Mock = Mock;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="engineDeviceSpec.ts" />
/// <reference path="outputTarget.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * This class is defined within its own file so that it can be loaded by code outside of KMW without
             * having to actually load the entirety of KMW.
             */
            var KeyEvent = /** @class */ (function () {
                function KeyEvent() {
                    /**
                     * `true` if this event was produced by sources other than a DOM-based KeyboardEvent.
                     */
                    this.isSynthetic = true;
                }
                return KeyEvent;
            }());
            text.KeyEvent = KeyEvent;
            ;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * Represents the commands and state changes that result from a matched keyboard rule.
             */
            var RuleBehavior = /** @class */ (function () {
                function RuleBehavior() {
                    /**
                     * A set of changed store values triggered by the matched keyboard rule.
                     */
                    this.setStore = {};
                    /**
                     * A set of variable stores with save requests triggered by the matched keyboard rule
                     */
                    this.saveStore = {};
                }
                RuleBehavior.prototype.finalize = function (processor) {
                    var outputTarget = this.transcription.keystroke.Ltarg;
                    if (processor.beepHandler && this.beep) {
                        processor.beepHandler(outputTarget);
                    }
                    for (var storeID in this.setStore) {
                        var sysStore = processor.keyboardInterface.systemStores[storeID];
                        if (sysStore) {
                            try {
                                sysStore.set(this.setStore[storeID]);
                            }
                            catch (error) {
                                if (processor.errorLogger) {
                                    processor.errorLogger("Rule attempted to perform illegal operation - 'platform' may not be changed.");
                                }
                            }
                        }
                        else if (processor.warningLogger) {
                            processor.warningLogger("Unknown store affected by keyboard rule: " + storeID);
                        }
                    }
                    if (processor.keyboardInterface.variableStoreSerializer) {
                        for (var storeID in this.saveStore) {
                            processor.keyboardInterface.variableStoreSerializer.saveStore(processor.activeKeyboard.id, storeID, this.saveStore[storeID]);
                        }
                    }
                    if (this.triggersDefaultCommand) {
                        var keyEvent = this.transcription.keystroke;
                        text.DefaultOutput.applyCommand(keyEvent);
                    }
                    if (processor.warningLogger && this.warningLog) {
                        processor.warningLogger(this.warningLog);
                    }
                    else if (processor.errorLogger && this.errorLog) {
                        processor.errorLogger(this.errorLog);
                    }
                };
                return RuleBehavior;
            }());
            text.RuleBehavior = RuleBehavior;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Establishes key-code definitions.
/// <reference path="codes.ts" />
// Defines our generalized "KeyEvent" class.
/// <reference path="keyEvent.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var EmulationKeystrokes;
            (function (EmulationKeystrokes) {
                EmulationKeystrokes["Space"] = " ";
                EmulationKeystrokes["Enter"] = "\n";
                EmulationKeystrokes["Backspace"] = "\b";
            })(EmulationKeystrokes = text.EmulationKeystrokes || (text.EmulationKeystrokes = {}));
            /**
             * Defines a collection of static library functions that define KeymanWeb's default (implied) keyboard rule behaviors.
             */
            var DefaultOutput = /** @class */ (function () {
                function DefaultOutput() {
                }
                DefaultOutput.codeForEvent = function (Lkc) {
                    return text.Codes.keyCodes[Lkc.kName] || Lkc.Lcode;
                    ;
                };
                /**
                 * Serves as a default keycode lookup table.  This may be referenced safely by mnemonic handling without fear of side-effects.
                 * Also used by Processor.defaultRuleBehavior to generate output after filtering for special cases.
                 */
                DefaultOutput.forAny = function (Lkc, isMnemonic) {
                    var char = '';
                    // A pretty simple table of lookups, corresponding VERY closely to the original defaultKeyOutput.
                    if ((char = DefaultOutput.forSpecialEmulation(Lkc)) != null) {
                        return char;
                    }
                    else if (!isMnemonic && ((char = DefaultOutput.forNumpadKeys(Lkc)) != null)) {
                        return char;
                    }
                    else if ((char = DefaultOutput.forUnicodeKeynames(Lkc)) != null) {
                        return char;
                    }
                    else if ((char = DefaultOutput.forBaseKeys(Lkc)) != null) {
                        return char;
                    }
                    else {
                        // // For headless and embeddded, we may well allow '\t'.  It's DOM mode that has other uses.
                        // // Not originally defined for text output within defaultKeyOutput.
                        // // We can't enable it yet, as it'll cause hardware keystrokes in the DOM to output '\t' rather
                        // // than rely on the browser-default handling.
                        var code = DefaultOutput.codeForEvent(Lkc);
                        switch (code) {
                            //   case Codes.keyCodes['K_TAB']:
                            //   case Codes.keyCodes['K_TABBACK']:
                            //   case Codes.keyCodes['K_TABFWD']:
                            //     return '\t';
                            default:
                                return '';
                        }
                    }
                };
                /**
                 * isCommand - returns a boolean indicating if a non-text event should be triggered by the keystroke.
                 */
                DefaultOutput.isCommand = function (Lkc) {
                    var code = DefaultOutput.codeForEvent(Lkc);
                    switch (code) {
                        // Should we ever implement them:
                        // case Codes.keyCodes['K_LEFT']:  // would not output text, but would alter the caret's position in the context.
                        // case Codes.keyCodes['K_RIGHT']:
                        //   return true;
                        default:
                            return false;
                    }
                };
                /**
                 * Used when a RuleBehavior represents a non-text "command" within the Engine.  This will generally
                 * trigger events that require context reset - often by moving the caret or by moving what OutputTarget
                 * the caret is in.  However, we let those events perform the actual context reset.
                 *
                 * Note:  is extended by DOM-aware KeymanWeb code.
                 */
                DefaultOutput.applyCommand = function (Lkc) {
                    // Notes for potential default-handling extensions:
                    // 
                    // switch(code) {
                    // // Problem:  clusters, and doing them right.
                    // // The commented-out code below should be a decent starting point, but clusters make it complex.
                    // // Mostly based on pre-12.0 code, but the general idea should be relatively clear.
                    //
                    // case Codes.keyCodes['K_LEFT']:
                    //   if(touchAlias) {
                    //     var caretPos = keymanweb.getTextCaret(Lelem);
                    //     keymanweb.setTextCaret(Lelem, caretPos - 1 >= 0 ? caretPos - 1 : 0);
                    //   }
                    //   break;
                    // case Codes.keyCodes['K_RIGHT']:
                    //   if(touchAlias) {
                    //     var caretPos = keymanweb.getTextCaret(Lelem);
                    //     keymanweb.setTextCaret(Lelem, caretPos + 1);
                    //   }
                    //   if(code == VisualKeyboard.keyCodes['K_RIGHT']) {
                    //     break;
                    //   }
                    // }
                    //
                    // Note that these would be useful even outside of a DOM context.
                };
                /**
                 * Codes matched here generally have default implementations when in a browser but require emulation
                 * for 'synthetic' `OutputTarget`s like `Mock`s, which have no default text handling.
                 */
                DefaultOutput.forSpecialEmulation = function (Lkc) {
                    var code = DefaultOutput.codeForEvent(Lkc);
                    switch (code) {
                        case text.Codes.keyCodes['K_BKSP']:
                            return EmulationKeystrokes.Backspace;
                        case text.Codes.keyCodes['K_ENTER']:
                            return EmulationKeystrokes.Enter;
                        // (Probably) only here for legacy reasons; it's always been handled alongside the other two.
                        case text.Codes.keyCodes['K_SPACE']:
                            return EmulationKeystrokes.Space;
                        // case Codes.keyCodes['K_DEL']:
                        //   return '\u007f'; // 127, ASCII / Unicode control code for DEL.
                        default:
                            return null;
                    }
                };
                // Should not be used for mnenomic keyboards.  forAny()'s use of this method checks first.
                DefaultOutput.forNumpadKeys = function (Lkc) {
                    // Translate numpad keystrokes into their non-numpad equivalents
                    if (Lkc.Lcode >= text.Codes.keyCodes["K_NP0"] && Lkc.Lcode <= text.Codes.keyCodes["K_NPSLASH"]) {
                        // Number pad, numlock on
                        if (Lkc.Lcode < 106) {
                            var Lch = Lkc.Lcode - 48;
                        }
                        else {
                            Lch = Lkc.Lcode - 64;
                        }
                        var ch = String._kmwFromCharCode(Lch); //I3319
                        return ch;
                    }
                    else {
                        return null;
                    }
                };
                // Test for fall back to U_xxxxxx key id
                // For this first test, we ignore the keyCode and use the keyName
                DefaultOutput.forUnicodeKeynames = function (Lkc, ruleBehavior) {
                    var keyName = Lkc.kName;
                    // Test for fall back to U_xxxxxx key id
                    // For this first test, we ignore the keyCode and use the keyName
                    if (!keyName || keyName.substr(0, 2) != 'U_') {
                        return null;
                    }
                    var codePoint = parseInt(keyName.substr(2, 6), 16);
                    if (((0x0 <= codePoint) && (codePoint <= 0x1F)) || ((0x80 <= codePoint) && (codePoint <= 0x9F))) {
                        // Code points [U_0000 - U_001F] and [U_0080 - U_009F] refer to Unicode C0 and C1 control codes.
                        // Check the codePoint number and do not allow output of these codes via U_xxxxxx shortcuts.
                        if (ruleBehavior) {
                            ruleBehavior.errorLog = ("Suppressing Unicode control code: U_00" + codePoint.toString(16));
                        }
                        return null;
                    }
                    else {
                        // String.fromCharCode() is inadequate to handle the entire range of Unicode
                        // Someday after upgrading to ES2015, can use String.fromCodePoint()
                        return String.kmwFromCharCode(codePoint);
                    }
                };
                // Test for otherwise unimplemented keys on the the base default & shift layers.
                // Those keys must be blocked by keyboard rules if intentionally unimplemented; otherwise, this function will trigger.
                DefaultOutput.forBaseKeys = function (Lkc, ruleBehavior) {
                    var n = Lkc.Lcode;
                    var keyShiftState = Lkc.Lmodifiers;
                    // check if exact match to SHIFT's code.  Only the 'default' and 'shift' layers should have default key outputs.
                    // TODO:  Extend to allow AltGr as well - better mnemonic support.
                    if (keyShiftState == text.Codes.modifierCodes['SHIFT']) {
                        keyShiftState = 1;
                    }
                    else if (keyShiftState != 0) {
                        if (ruleBehavior) {
                            ruleBehavior.warningLog = "KMW only defines default key output for the 'default' and 'shift' layers!";
                        }
                        return null;
                    }
                    // Now that keyShiftState is either 0 or 1, we can use the following structure to determine the default output.
                    try {
                        if (n >= text.Codes.keyCodes['K_0'] && n <= text.Codes.keyCodes['K_9']) { // The number keys.
                            return text.Codes.codesUS[keyShiftState][0][n - text.Codes.keyCodes['K_0']];
                        }
                        else if (n >= text.Codes.keyCodes['K_A'] && n <= text.Codes.keyCodes['K_Z']) { // The base letter keys
                            return String.fromCharCode(n + (keyShiftState ? 0 : 32)); // 32 is the offset from uppercase to lowercase.
                        }
                        else if (n >= text.Codes.keyCodes['K_COLON'] && n <= text.Codes.keyCodes['K_BKQUOTE']) {
                            return text.Codes.codesUS[keyShiftState][1][n - text.Codes.keyCodes['K_COLON']];
                        }
                        else if (n >= text.Codes.keyCodes['K_LBRKT'] && n <= text.Codes.keyCodes['K_QUOTE']) {
                            return text.Codes.codesUS[keyShiftState][2][n - text.Codes.keyCodes['K_LBRKT']];
                        }
                    }
                    catch (e) {
                        if (ruleBehavior) {
                            ruleBehavior.errorLog = "Error detected with default mapping for key:  code = " + n + ", shift state = " + (keyShiftState == 1 ? 'shift' : 'default');
                        }
                    }
                    return null;
                };
                return DefaultOutput;
            }());
            text.DefaultOutput = DefaultOutput;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
//Autogenerated file - do not modify!
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var environment;
        (function (environment) {
            environment.VERSION = "14.0";
            environment.BUILD = 52;
        })(environment = keyman.environment || (keyman.environment = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines build-environment variables, as used for versioning.
/// <reference path="../environment.inc.ts" />
// Ensure that this class contains no reference into core KMW code - it is referenced
// by components intended to be modular and possible to separate from core KMW.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            // Dotted-decimal version
            var Version = /** @class */ (function () {
                /**
                 * Parses version information, preparing it for use in comparisons.
                 * @param text Either a string representing a version number (ex: "9.0.0") or an array representing
                 *             its components (ex: [9, 0, 0]).
                 */
                function Version(text) {
                    // If a keyboard doesn't specify a version, use the DEVELOPER_VERSION_FALLBACK values.
                    if (text === undefined || text === null) {
                        this.components = [].concat(Version.DEVELOPER_VERSION_FALLBACK.components);
                        return;
                    }
                    if (Array.isArray(text)) {
                        var components = text;
                        if (components.length < 2) {
                            throw new Error("Version string must have at least a major and minor component!");
                        }
                        else {
                            this.components = [].concat(components);
                            return;
                        }
                    }
                    // else, standard constructor path.
                    var parts = text.split('.');
                    var componentArray = [];
                    if (parts.length < 2) {
                        throw new Error("Version string must have at least a major and minor component!");
                    }
                    for (var i = 0; i < parts.length; i++) {
                        var value = parseInt(parts[i], 10);
                        if (isNaN(value)) {
                            throw new Error("Version string components must be numerical!");
                        }
                        componentArray.push(value);
                    }
                    this.components = componentArray;
                }
                Object.defineProperty(Version.prototype, "major", {
                    get: function () {
                        return this.components[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Version.prototype, "minor", {
                    get: function () {
                        return this.components[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Version.prototype.toString = function () {
                    return this.components.join('.');
                };
                Version.prototype.toJSON = function () {
                    return this.toString();
                };
                Version.prototype.equals = function (other) {
                    return this.compareTo(other) == 0;
                };
                Version.prototype.precedes = function (other) {
                    return this.compareTo(other) < 0;
                };
                Version.prototype.compareTo = function (other) {
                    // If the version info depth differs, we need a flag to indicate which instance is shorter.
                    var isShorter = this.components.length < other.components.length;
                    var maxDepth = (this.components.length < other.components.length) ? this.components.length : other.components.length;
                    var i;
                    for (i = 0; i < maxDepth; i++) {
                        var delta = this.components[i] - other.components[i];
                        if (delta != 0) {
                            return delta;
                        }
                    }
                    var longList = isShorter ? other.components : this.components;
                    do {
                        if (longList[i] > 0) {
                            return isShorter ? -1 : 1;
                        }
                        i++;
                    } while (i < longList.length);
                    // Equal.
                    return 0;
                };
                Version.CURRENT = new Version(com.keyman.environment.VERSION);
                // Represents a default version value for keyboards compiled before this was compiled into keyboards.
                // The exact version is unknown at this point, but the value is "good enough" for what we need.
                Version.DEVELOPER_VERSION_FALLBACK = new Version([9, 0, 0]);
                // For 12.0, the old default behavior of adding missing keycaps to the default layers was removed,
                // as it results in unexpected, bug-like behavior for keyboard designers when it is unwanted.
                Version.NO_DEFAULT_KEYCAPS = new Version([12, 0]);
                Version.MAC_POSSIBLE_IPAD_ALIAS = new Version([10, 15]);
                return Version;
            }());
            utils.Version = Version;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Function     deepCopy
             * Scope        Private
             * @param       {Object}      p           object to copy
             * @param       {Array=}      c0          array member being copied
             * @return      {Object}                  clone ('deep copy') of object
             * Description  Makes an actual copy (not a reference) of an object, copying simple members,
             *              arrays and member objects but not functions, so use with care!
             */
            function deepCopy(p, c0) {
                var c = c0 || {};
                for (var i in p) {
                    if (typeof p[i] === 'object' && p[i] != null) {
                        c[i] = (p[i].constructor === Array) ? [] : {};
                        deepCopy(p[i], c[i]);
                    }
                    else {
                        c[i] = p[i];
                    }
                }
                return c;
            }
            utils.deepCopy = deepCopy;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 10.0
   Copyright 2017 SIL International
***/
///<reference path="../utils/version.ts"/>
///<reference path="../utils/deepCopy.ts"/>
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            var Codes = com.keyman.text.Codes;
            // This class manages default layout construction for consumption by OSKs without a specified layout.
            var Layouts = /** @class */ (function () {
                function Layouts() {
                }
                /**
                * Build a default layout for keyboards with no explicit layout
                *
                * @param   {Object}  PVK             keyboard object (as loaded)
                * @param   {Object}  kbdDevVersion   object representing the version of Developer that compiled the keyboard
                * @param   {number}  kbdBitmask      keyboard modifier bitmask
                * @param   {string}  formFactor
                * @return  {Object}
                */
                Layouts.buildDefaultLayout = function (PVK, keyboard, formFactor) {
                    // Build a layout using the default for the device
                    var layoutType = formFactor;
                    if (typeof Layouts.dfltLayout[layoutType] != 'object') {
                        layoutType = 'desktop';
                    }
                    var kbdBitmask = Codes.modifierBitmasks['NON_CHIRAL'];
                    // An unfortunate dependency there.  Should probably also set a version within web-core for use.
                    var kbdDevVersion = keyman.utils.Version.CURRENT;
                    if (keyboard) {
                        kbdBitmask = keyboard.modifierBitmask;
                        kbdDevVersion = keyboard.compilerVersion;
                    }
                    if (!PVK) {
                        PVK = this.DEFAULT_RAW_SPEC;
                    }
                    // Clone the default layout object for this device
                    var layout = keyman.utils.deepCopy(Layouts.dfltLayout[layoutType]);
                    var n, layers = layout['layer'], keyLabels = PVK['KLS'], key102 = PVK['K102'];
                    var i, j, k, m, row, rows, key, keys;
                    var chiral = (kbdBitmask & Codes.modifierBitmasks.IS_CHIRAL) != 0;
                    var kmw10Plus = !(typeof keyLabels == 'undefined' || !keyLabels);
                    if (!kmw10Plus) {
                        // Save the processed key label information to the keyboard's general data.
                        // Makes things more efficient elsewhere and for reloading after keyboard swaps.
                        keyLabels = PVK['KLS'] = Layouts.processLegacyDefinitions(PVK['BK']);
                    }
                    // Identify key labels (e.g. *Shift*) that require the special OSK font
                    var specialLabel = /\*\w+\*/;
                    // *** Step 1:  instantiate the layer objects. ***
                    // Get the list of valid layers, enforcing that the 'default' layer must be the first one processed.
                    var validIdList = Object.getOwnPropertyNames(keyLabels), invalidIdList = [];
                    validIdList.splice(validIdList.indexOf('default'), 1);
                    validIdList = ['default'].concat(validIdList);
                    // Automatic AltGr emulation if the 'leftctrl-leftalt' layer is otherwise undefined.
                    if (keyboard && keyboard.emulatesAltGr) {
                        // We insert only the layers that need to be emulated.
                        if ((validIdList.indexOf('leftctrl-leftalt') == -1) && validIdList.indexOf('rightalt') != -1) {
                            validIdList.push('leftctrl-leftalt');
                            keyLabels['leftctrl-leftalt'] = keyLabels['rightalt'];
                        }
                        if ((validIdList.indexOf('leftctrl-leftalt-shift') == -1) && validIdList.indexOf('rightalt-shift') != -1) {
                            validIdList.push('leftctrl-leftalt-shift');
                            keyLabels['leftctrl-leftalt-shift'] = keyLabels['rightalt-shift'];
                        }
                    }
                    // For desktop devices, we must create all layers, even if invalid.
                    if (formFactor == 'desktop') {
                        invalidIdList = Layouts.generateLayerIds(chiral);
                        // Filter out all ids considered valid.  (We also don't want duplicates in the following list...)
                        for (n = 0; n < invalidIdList.length; n++) {
                            if (validIdList.indexOf(invalidIdList[n]) != -1) {
                                invalidIdList.splice(n--, 1);
                            }
                        }
                    }
                    // This ensures all 'valid' layers are at the front of the layer array and managed by the main loop below.
                    // 'invalid' layers aren't handled by the loop and thus remain blank after it.
                    var idList = validIdList.concat(invalidIdList);
                    if (kmw10Plus && formFactor != 'desktop') { // KLS exists, so we know the exact layer set.
                        // Find the SHIFT key...
                        var shiftKey = null;
                        rows = layers[0]['row'];
                        for (var r = 0; r < rows.length; r++) {
                            keys = rows[r]['key'];
                            for (var c = 0; c < keys.length; c++) {
                                key = keys[c];
                                if (key['id'] == 'K_SHIFT') {
                                    shiftKey = key;
                                }
                            }
                        }
                        if (shiftKey) {
                            // Erase the legacy shifted subkey array.
                            shiftKey['sk'] = [];
                            for (var layerID in keyLabels) {
                                if (layerID == 'default' || layerID == 'shift') {
                                    // These two are accessible from the layer without subkeys.
                                    continue;
                                }
                                // Create a new subkey for the specified layer so that it will be accessible via OSK.
                                var specialChar = Layouts.modifierSpecials[layerID];
                                var subkey = {
                                    id: "K_" + specialChar,
                                    text: specialChar,
                                    sp: "1",
                                    nextlayer: layerID
                                };
                                shiftKey['sk'].push(subkey);
                            }
                        }
                        else {
                            // Seriously, this should never happen.  It's here for the debugging log only.
                            console.warn("Error in default layout - cannot find default Shift key!");
                        }
                    }
                    for (n = 0; n < idList.length; n++) {
                        // Populate non-default (shifted) keygroups
                        if (n > 0) {
                            layers[n] = keyman.utils.deepCopy(layers[0]);
                        }
                        layers[n]['id'] = idList[n];
                        layers[n]['nextlayer'] = idList[n]; // This would only be different for a dynamic keyboard
                        // Extraced into a helper method to improve readability.
                        Layouts.formatDefaultLayer(layers[n], chiral, formFactor, !!key102);
                    }
                    // *** Step 2: Layer objects now exist; time to fill them with the appropriate key labels and key styles ***
                    for (n = 0; n < layers.length; n++) {
                        var layer = layers[n], kx, shiftKey = null, nextKey = null, allText = '';
                        var capsKey = null, numKey = null, scrollKey = null; // null if not in the OSK layout.
                        var layerSpec = keyLabels[layer['id']];
                        var isShift = layer['id'] == 'shift' ? 1 : 0;
                        var isDefault = layer['id'] == 'default' || isShift ? 1 : 0;
                        rows = layer['row'];
                        for (i = 0; i < rows.length; i++) {
                            keys = rows[i]['key'];
                            for (j = 0; j < keys.length; j++) {
                                key = keys[j];
                                kx = Layouts.dfltCodes.indexOf(key['id']);
                                // Only create keys for defined layers.  ('default' and 'shift' are always defined.)
                                if (layerSpec || isDefault) {
                                    // Get keycap text from visual keyboard array, if defined in keyboard
                                    if (layerSpec) {
                                        if (kx >= 0 && kx < layerSpec.length)
                                            key['text'] = layerSpec[kx];
                                    }
                                    // Legacy (pre 12.0) behavior:  fall back to US English keycap text as default for the base two layers
                                    // if a key cap is not otherwise defined. (Any intentional 'ghost' keys must be explicitly defined.)
                                    if (isDefault && kbdDevVersion.precedes(keyman.utils.Version.NO_DEFAULT_KEYCAPS)) {
                                        if (key['id'] != 'K_SPACE' && kx + 65 * isShift < Layouts.dfltText.length && key['text'] !== null) {
                                            key['text'] = key['text'] || Layouts.dfltText[kx + 65 * isShift];
                                        }
                                    }
                                }
                                // Leave any unmarked key caps as null strings
                                if (key['text'] !== null) {
                                    key['text'] = key['text'] || '';
                                }
                                // Detect important tracking keys.
                                switch (key['id']) {
                                    case "K_SHIFT":
                                        shiftKey = key;
                                        break;
                                    case "K_TAB":
                                        nextKey = key;
                                        break;
                                    case "K_CAPS":
                                        capsKey = key;
                                        break;
                                    case "K_NUMLOCK":
                                        numKey = key;
                                        break;
                                    case "K_SCROLL":
                                        scrollKey = key;
                                        break;
                                }
                                // Remove pop-up shift keys referencing invalid layers (Build 349)
                                if (key['sk'] != null) {
                                    for (k = 0; k < key['sk'].length; k++) {
                                        if (validIdList.indexOf(key['sk'][k]['nextlayer']) == -1) {
                                            key['sk'].splice(k--, 1);
                                        }
                                    }
                                    if (key['sk'].length == 0) {
                                        key['sk'] = null;
                                    }
                                }
                            }
                        }
                        // We're done with the layer keys initialization pass.  Time to do post-analysis layer-level init where necessary.
                        layer.shiftKey = shiftKey;
                        layer.capsKey = capsKey;
                        layer.numKey = numKey;
                        layer.scrollKey = scrollKey;
                        // Set modifier key appearance and behaviour for non-desktop devices using the default layout
                        if (formFactor != 'desktop') {
                            if (n > 0 && shiftKey != null) {
                                shiftKey['sp'] = Layouts.buttonClasses['SHIFT-ON'];
                                shiftKey['sk'] = null;
                                shiftKey['text'] = Layouts.modifierSpecials[layers[n].id] ? Layouts.modifierSpecials[layers[n].id] : "*Shift*";
                            }
                        }
                    }
                    return layout;
                };
                /**
             * Function     getLayerId
             * Scope        Private
             * @param       {number}      m     shift modifier code
             * @return      {string}            layer string from shift modifier code (desktop keyboards)
             * Description  Get name of layer from code, where the modifer order is determined by ascending bit-flag value.
             */
                Layouts.getLayerId = function (m) {
                    var modifierCodes = Codes.modifierCodes;
                    var s = '';
                    if (m == 0) {
                        return 'default';
                    }
                    else {
                        if (m & modifierCodes['LCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftctrl';
                        }
                        if (m & modifierCodes['RCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightctrl';
                        }
                        if (m & modifierCodes['LALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftalt';
                        }
                        if (m & modifierCodes['RALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightalt';
                        }
                        if (m & modifierCodes['SHIFT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'shift';
                        }
                        if (m & modifierCodes['CTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'ctrl';
                        }
                        if (m & modifierCodes['ALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'alt';
                        }
                        return s;
                    }
                };
                /**
                 * Generates a list of potential layer ids for the specified chirality mode.
                 *
                 * @param   {boolean}   chiral    // Does the keyboard use chiral modifiers or not?
                 */
                Layouts.generateLayerIds = function (chiral) {
                    var layerCnt, offset;
                    if (chiral) {
                        layerCnt = 32;
                        offset = 0x01;
                    }
                    else {
                        layerCnt = 8;
                        offset = 0x10;
                    }
                    var layerIds = [];
                    for (var i = 0; i < layerCnt; i++) {
                        layerIds.push(Layouts.getLayerId(i * offset));
                    }
                    return layerIds;
                };
                /**
                 * Sets a formatting property for the modifier keys when constructing a default layout for a keyboard.
                 *
                 * @param   {Object}    layer   // One layer specification
                 * @param   {boolean}   chiral  // Whether or not the keyboard uses chiral modifier information.
                 * @param   {string}    formFactor  // The form factor of the device the layout is being constructed for.
                 * @param   {boolean}   key102      // Whether or not the extended key 102 should be hidden.
                 */
                Layouts.formatDefaultLayer = function (layer, chiral, formFactor, key102) {
                    var layerId = layer['id'];
                    var buttonClasses = Layouts.buttonClasses;
                    // Correct appearance of state-dependent modifier keys according to group
                    for (var i = 0; i < layer['row'].length; i++) {
                        var row = layer['row'][i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            switch (key['id']) {
                                case 'K_SHIFT':
                                case 'K_LSHIFT':
                                case 'K_RSHIFT':
                                    if (layerId.indexOf('shift') != -1) {
                                        key['sp'] = buttonClasses['SHIFT-ON'];
                                    }
                                    if ((formFactor != 'desktop') && (layerId != 'default')) {
                                        key['nextlayer'] = 'default';
                                    }
                                    break;
                                case 'K_LCTRL':
                                case 'K_LCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('leftctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RCTRL':
                                case 'K_RCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('rightctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_CONTROL':
                                    if (layerId.indexOf('ctrl') != -1) {
                                        if (!chiral || (layerId.indexOf('leftctrl') != -1 && layerId.indexOf('rightctrl') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_LALT':
                                    if (chiral) {
                                        if (layerId.indexOf('leftalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RALT':
                                    if (chiral) {
                                        if (layerId.indexOf('rightalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_ALT':
                                    if (layerId.indexOf('alt') != -1) {
                                        if (!chiral || (layerId.indexOf('leftalt') != -1 && layerId.indexOf('rightalt') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_oE2':
                                    if (typeof key102 == 'undefined' || !key102) {
                                        if (formFactor == 'desktop') {
                                            keys.splice(j--, 1);
                                            keys[0]['width'] = '200';
                                        }
                                        else {
                                            keys[j]['sp'] = buttonClasses['HIDDEN'];
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                };
                /**
                 * Converts the legacy BK property from pre 10.0 into the KLS keyboard layer spec format,
                 * sparsifying it as possible to pre-emptively check invalid layers.
                 *
                 * @param   {Array}   BK      keyboard object (as loaded)
                 * @return  {Object}
                 */
                Layouts.processLegacyDefinitions = function (BK) {
                    //['default','shift','ctrl','shiftctrl','alt','shiftalt','ctrlalt','shiftctrlalt'];
                    var idList = Layouts.generateLayerIds(false); // Non-chiral.
                    var KLS = {};
                    // The old default:  eight auto-managed layers...
                    for (var n = 0; n < idList.length; n++) {
                        var id = idList[n], arr = [], valid = false;
                        // ... with keycode mappings in blocks of 65.
                        for (var k = 0; k < 65; k++) {
                            var index = k + 65 * n;
                            arr.push(BK[index]);
                            // The entry for K_SPACE's keycode tends to hold ' ' instead of '', which causes
                            // the whole layer to be treated as 'valid' if not included in the conditional.
                            if (index < BK.length && BK[index] != '' && k != Layouts.dfltCodes.indexOf('K_SPACE')) {
                                valid = true;
                            }
                        }
                        if (valid) {
                            KLS[id] = arr;
                        }
                    }
                    // There must always be at least a plain 'default' layer.  Array(65).fill('') would be preferable but isn't supported on IE, 
                    // but buildDefaultLayer will set the defaults for these layers if no entry exists for them in the array due to length.
                    if (typeof KLS['default'] == 'undefined' || !KLS['default']) {
                        KLS['default'] = [''];
                    }
                    // There must always be at least a plain 'shift' layer.
                    if (typeof KLS['shift'] == 'undefined' || !KLS['shift']) {
                        KLS['shift'] = [''];
                    }
                    return KLS;
                };
                Layouts.dfltCodes = [
                    "K_BKQUOTE", "K_1", "K_2", "K_3", "K_4", "K_5", "K_6", "K_7", "K_8", "K_9", "K_0",
                    "K_HYPHEN", "K_EQUAL", "K_*", "K_*", "K_*", "K_Q", "K_W", "K_E", "K_R", "K_T",
                    "K_Y", "K_U", "K_I", "K_O", "K_P", "K_LBRKT", "K_RBRKT", "K_BKSLASH", "K_*",
                    "K_*", "K_*", "K_A", "K_S", "K_D", "K_F", "K_G", "K_H", "K_J", "K_K", "K_L",
                    "K_COLON", "K_QUOTE", "K_*", "K_*", "K_*", "K_*", "K_*", "K_oE2",
                    "K_Z", "K_X", "K_C", "K_V", "K_B", "K_N", "K_M", "K_COMMA", "K_PERIOD",
                    "K_SLASH", "K_*", "K_*", "K_*", "K_*", "K_*", "K_SPACE"
                ];
                Layouts.dfltText = '`1234567890-=\xA7~~qwertyuiop[]\\~~~asdfghjkl;\'~~~~~?zxcvbnm,./~~~~~ '
                    + '~!@#$%^&*()_+\xA7~~QWERTYUIOP{}\\~~~ASDFGHJKL:"~~~~~?ZXCVBNM<>?~~~~~ ';
                Layouts.DEFAULT_RAW_SPEC = { 'F': 'Tahoma', 'BK': Layouts.dfltText };
                // Cross-reference with the ids in osk.setButtonClass.
                Layouts.buttonClasses = {
                    'DEFAULT': '0',
                    'SHIFT': '1',
                    'SHIFT-ON': '2',
                    'SPECIAL': '3',
                    'SPECIAL-ON': '4',
                    'DEADKEY': '8',
                    'BLANK': '9',
                    'HIDDEN': '10'
                };
                Layouts.modifierSpecials = {
                    'leftalt': '*LAlt*',
                    'rightalt': '*RAlt*',
                    'alt': '*Alt*',
                    'leftctrl': '*LCtrl*',
                    'rightctrl': '*RCtrl*',
                    'ctrl': '*Ctrl*',
                    'ctrl-alt': '*AltGr*',
                    'leftctrl-leftalt': '*LAltCtrl*',
                    'rightctrl-rightalt': '*RAltCtrl*',
                    'leftctrl-leftalt-shift': '*LAltCtrlShift*',
                    'rightctrl-rightalt-shift': '*RAltCtrlShift*',
                    'shift': '*Shift*',
                    'shift-alt': '*AltShift*',
                    'shift-ctrl': '*CtrlShift*',
                    'shift-ctrl-alt': '*AltCtrlShift*',
                    'leftalt-shift': '*LAltShift*',
                    'rightalt-shift': '*RAltShift*',
                    'leftctrl-shift': '*LCtrlShift*',
                    'rightctrl-shift': '*RCtrlShift*'
                };
                // Defines the default visual layout for a keyboard.
                Layouts.dfltLayout = {
                    "desktop": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_BKQUOTE" },
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_TAB", "text": "*Tab*", "sp": "1", "width": "130" },
                                            { "id": "K_Q" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "id": "K_BKSLASH" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_CAPS", "text": "*Caps*", "sp": "1", "width": "165" },
                                            { "id": "K_A" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "165" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            { "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "130" },
                                            { "id": "K_oE2" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_RSHIFT", "text": "*Shift*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "5",
                                        "key": [
                                            { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" },
                                            { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_SPACE", "text": "", "width": "770" },
                                            { "id": "K_RALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_RCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "tablet": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "sp": "1", "width": "150" },
                                            { "id": "K_SPACE", "text": "", "width": "570" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "150" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "200" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "phone": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "width": "150", "sp": "1" },
                                            { "id": "K_SPACE", "width": "570", "text": "" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "width": "150", "sp": "1" },
                                            { "id": "K_ENTER", "text": "*Enter*", "width": "200", "sp": "1" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                };
                return Layouts;
            }());
            keyboards.Layouts = Layouts;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            var ActiveKey = /** @class */ (function () {
                function ActiveKey() {
                    this.isMnemonic = false;
                }
                ActiveKey.polyfill = function (key, layout, displayLayer) {
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveKey();
                    for (var prop in dummy) {
                        if (!key.hasOwnProperty(prop)) {
                            key[prop] = dummy[prop];
                        }
                    }
                    // Ensure subkeys are also properly extended.
                    if (key.sk) {
                        for (var _i = 0, _a = key.sk; _i < _a.length; _i++) {
                            var subkey = _a[_i];
                            ActiveKey.polyfill(subkey, layout, displayLayer);
                        }
                    }
                    var aKey = key;
                    aKey.displayLayer = displayLayer;
                    aKey.layer = aKey.layer || displayLayer;
                    // Compute the key's base KeyEvent properties for use in future event generation
                    aKey.constructBaseKeyEvent(layout, displayLayer);
                };
                ActiveKey.prototype.constructBaseKeyEvent = function (layout, displayLayer) {
                    // Get key name and keyboard shift state (needed only for default layouts and physical keyboard handling)
                    // Note - virtual keys should be treated case-insensitive, so we force uppercasing here.
                    var layer = this.layer || displayLayer || '';
                    var keyName = this.id ? this.id.toUpperCase() : null;
                    // Start:  mirrors _GetKeyEventProperties
                    // Override key shift state if specified for key in layout (corrected for popup keys KMEW-93)
                    var keyShiftState = keyman.text.KeyboardProcessor.getModifierState(layer);
                    // First check the virtual key, and process shift, control, alt or function keys
                    var Lkc = {
                        Ltarg: null,
                        Lmodifiers: keyShiftState,
                        Lstates: 0,
                        Lcode: keyName ? keyman.text.Codes.keyCodes[keyName] : 0,
                        LisVirtualKey: true,
                        vkCode: 0,
                        kName: keyName,
                        kLayer: layer,
                        kbdLayer: displayLayer,
                        kNextLayer: this.nextlayer,
                        device: null,
                        isSynthetic: true
                    };
                    if (layout.keyboard) {
                        var keyboard = layout.keyboard;
                        // Include *limited* support for mnemonic keyboards (Sept 2012)
                        // If a touch layout has been defined for a mnemonic keyout, do not perform mnemonic mapping for rules on touch devices.
                        if (keyboard.isMnemonic && !(layout.isDefault && layout.formFactor != 'desktop')) {
                            if (Lkc.Lcode != keyman.text.Codes.keyCodes['K_SPACE']) { // exception required, March 2013
                                // Jan 2019 - interesting that 'K_SPACE' also affects the caps-state check...
                                Lkc.vkCode = Lkc.Lcode;
                                this.isMnemonic = true;
                            }
                        }
                        else {
                            Lkc.vkCode = Lkc.Lcode;
                        }
                        // Support version 1.0 KeymanWeb keyboards that do not define positional vs mnemonic
                        if (!keyboard.definesPositionalOrMnemonic) {
                            // Not the best pattern, but currently safe - we don't look up any properties of any of the
                            // arguments in this use case, and the object's scope is extremely limited.
                            Lkc.Lcode = keyman.KeyMapping._USKeyCodeToCharCode(this.constructKeyEvent(null, null, null));
                            Lkc.LisVirtualKey = false;
                        }
                    }
                    this.baseKeyEvent = Lkc;
                };
                ActiveKey.prototype.constructKeyEvent = function (keyboardProcessor, target, device) {
                    // Make a deep copy of our preconstructed key event, filling it out from there.
                    var Lkc = keyman.utils.deepCopy(this.baseKeyEvent);
                    Lkc.Ltarg = target;
                    Lkc.device = device;
                    if (this.isMnemonic) {
                        keyman.text.KeyboardProcessor.setMnemonicCode(Lkc, this.layer.indexOf('shift') != -1, keyboardProcessor ? keyboardProcessor.stateKeys['K_CAPS'] : false);
                    }
                    // Performs common pre-analysis for both 'native' and 'embedded' OSK key & subkey input events.
                    // This part depends on the keyboard processor's active state.
                    if (keyboardProcessor) {
                        keyboardProcessor.setSyntheticEventDefaults(Lkc);
                    }
                    return Lkc;
                };
                ActiveKey.DEFAULT_PAD = 15; // Padding to left of key, in virtual units
                ActiveKey.DEFAULT_RIGHT_MARGIN = 15; // Padding to right of right-most key, in virtual units
                ActiveKey.DEFAULT_KEY_WIDTH = 100; // Width of a key, if not specified, in virtual units
                // Defines key defaults
                ActiveKey.DEFAULT_KEY = {
                    text: '',
                    width: ActiveKey.DEFAULT_KEY_WIDTH.toString(),
                    sp: '0',
                    pad: ActiveKey.DEFAULT_PAD.toString()
                };
                return ActiveKey;
            }());
            keyboards.ActiveKey = ActiveKey;
            var ActiveRow = /** @class */ (function () {
                function ActiveRow() {
                }
                ActiveRow.polyfill = function (row, layout, displayLayer, totalWidth, proportionalY) {
                    // Apply defaults, setting the width and other undefined properties for each key
                    var keys = row['key'];
                    for (var j = 0; j < keys.length; j++) {
                        var key = keys[j];
                        for (var tp in ActiveKey.DEFAULT_KEY) {
                            if (typeof key[tp] != 'string') {
                                key[tp] = ActiveKey.DEFAULT_KEY[tp];
                            }
                        }
                        // Modify the key type for special keys with non-standard labels
                        // to allow the keyboard font to ovveride the SpecialOSK font.
                        // Blank keys are no longer reclassed - can use before/after CSS to add text
                        switch (key['sp']) {
                            case '1':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '3';
                                }
                                break;
                            case '2':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '4';
                                }
                                break;
                        }
                        ActiveKey.polyfill(key, layout, displayLayer);
                    }
                    /* The calculations here are effectively 'virtualized'.  When used with the OSK, the VisualKeyboard
                     * will overwrite these values with their true runtime geometry.
                     *
                     * These calculations approximate those of the actual OSK (without fitting to a specific resolution)
                     * and are intended for use with layout testing (while headless) in the future.
                     */
                    // Calculate percentage-based scalings by summing defined widths and scaling each key to %.
                    // Save each percentage key width as a separate member (do *not* overwrite layout specified width!)
                    var keyPercent, padPercent, totalPercent = 0;
                    for (var j = 0; j < keys.length - 1; j++) {
                        keyPercent = parseInt(keys[j]['width'], 10) / totalWidth;
                        keys[j]['widthpc'] = keyPercent;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        // compute center's default x-coord (used in headless modes)
                        keys[j].proportionalX = (totalPercent + padPercent + (keyPercent / 2));
                        keys[j].proportionalWidth = keyPercent;
                        totalPercent += padPercent + keyPercent;
                    }
                    // Allow for right OSK margin (15 layout units)
                    var rightMargin = ActiveKey.DEFAULT_RIGHT_MARGIN / totalWidth;
                    totalPercent += rightMargin;
                    // If a single key, and padding is negative, add padding to right align the key
                    if (keys.length == 1 && parseInt(keys[0]['pad'], 10) < 0) {
                        keyPercent = parseInt(keys[0]['width'], 10) / totalWidth;
                        keys[0]['widthpc'] = keyPercent;
                        totalPercent += keyPercent;
                        keys[0]['padpc'] = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        keys[0].proportionalX = ((totalPercent - rightMargin) - keyPercent / 2);
                        keys[0].proportionalWidth = keyPercent;
                    }
                    else if (keys.length > 0) {
                        var j = keys.length - 1;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        totalPercent += padPercent;
                        keys[j]['widthpc'] = keyPercent = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        keys[j].proportionalX = (1 - rightMargin) - keyPercent / 2;
                        keys[j].proportionalWidth = keyPercent;
                    }
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveRow();
                    for (var key in dummy) {
                        if (!row.hasOwnProperty(key)) {
                            row[key] = dummy[key];
                        }
                    }
                    var aRow = row;
                    aRow.proportionalY = proportionalY;
                };
                ActiveRow.prototype.populateKeyMap = function (map) {
                    this.key.forEach(function (key) {
                        if (key.id) {
                            map[key.id] = key;
                        }
                    });
                };
                // Identify key labels (e.g. *Shift*) that require the special OSK font
                ActiveRow.SPECIAL_LABEL = /\*\w+\*/;
                return ActiveRow;
            }());
            var ActiveLayer = /** @class */ (function () {
                function ActiveLayer() {
                }
                ActiveLayer.polyfill = function (layer, layout) {
                    layer.aligned = false;
                    // Create a DIV for each row of the group
                    var rows = layer['row'];
                    // Calculate the maximum row width (in layout units)
                    var totalWidth = 0;
                    for (var i = 0; i < layer['row'].length; i++) {
                        var width = 0;
                        var row = rows[i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            // Test for a trailing comma included in spec, added as null object by IE
                            if (key == null) {
                                keys.length = keys.length - 1;
                            }
                            else {
                                var kw, kp;
                                kw = (typeof key['width'] == 'string' && key['width'] != '') ? parseInt(key['width'], 10) : ActiveKey.DEFAULT_KEY_WIDTH;
                                if (isNaN(kw) || kw == 0)
                                    kw = ActiveKey.DEFAULT_KEY_WIDTH;
                                key['width'] = kw.toString();
                                kp = (typeof key['pad'] == 'string' && key['pad'] != '') ? parseInt(key['pad'], 10) : ActiveKey.DEFAULT_PAD;
                                if (isNaN(kp) || kp == 0)
                                    kp = ActiveKey.DEFAULT_PAD; // KMEW-119
                                key['pad'] = kp.toString();
                                width += kw + kp;
                                //if(typeof key['width'] == 'string' && key['width'] != '') width += parseInt(key['width'],10); else width += DEFAULT_KEY_WIDTH;
                                //if(typeof key['pad'] == 'string' && key['pad'] != '') width += parseInt(key['pad'],10); else width += 5;
                            }
                        }
                        if (width > totalWidth) {
                            totalWidth = width;
                        }
                    }
                    // Add default right margin
                    if (layout.formFactor == 'desktop') {
                        totalWidth += 5; // TODO: resolve difference between touch and desktop; why don't we use ActiveKey.DEFAULT_RIGHT_MARGIN?
                    }
                    else {
                        totalWidth += ActiveKey.DEFAULT_RIGHT_MARGIN;
                    }
                    var rowCount = layer.row.length;
                    for (var i = 0; i < rowCount; i++) {
                        // Calculate proportional y-coord of row.  0 is at top with highest y-coord.
                        var rowProportionalY = (i + 0.5) / rowCount;
                        ActiveRow.polyfill(layer.row[i], layout, layer.id, totalWidth, rowProportionalY);
                    }
                    // Add class functions and properties to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayer();
                    for (var key in dummy) {
                        if (!layer.hasOwnProperty(key)) {
                            layer[key] = dummy[key];
                        }
                    }
                    var aLayer = layer;
                    aLayer.totalWidth = totalWidth;
                    aLayer.defaultKeyProportionalWidth = parseInt(ActiveKey.DEFAULT_KEY.width, 10) / totalWidth;
                    aLayer.rowProportionalHeight = 1.0 / rowCount;
                    aLayer.keyMap = aLayer.constructKeyMap();
                };
                ActiveLayer.prototype.constructKeyMap = function () {
                    var map = {};
                    this.row.forEach(function (row) {
                        row.populateKeyMap(map);
                    });
                    return map;
                };
                /**
                 * Builds a sorted-order array of most likely keys to be intended for a given touch.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.getTouchProbabilities = function (touchCoords, kbdScaleRatio) {
                    var distribution = this.simpleTouchDistribution(touchCoords, kbdScaleRatio);
                    var list = [];
                    for (var key in distribution) {
                        list.push({ keyId: key, p: distribution[key] });
                    }
                    return list.sort(function (a, b) {
                        return b.p - a.p; // Largest probability keys should be listed first.
                    });
                };
                /**
                 * Computes a probability distribution regarding the likelihood of a touch command being intended
                 * for each of the layout's keys.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.simpleTouchDistribution = function (touchCoords, kbdScaleRatio) {
                    var keyDists = this.keyTouchDistances(touchCoords, kbdScaleRatio);
                    var keyProbs = {};
                    var totalMass = 0;
                    // Should we wish to allow multiple different transforms for distance -> probability, use a function parameter in place
                    // of the formula in the loop below.
                    for (var key in keyDists) {
                        totalMass += keyProbs[key] = 1 / (keyDists[key] + 1e-6); // Prevent div-by-0 errors.
                    }
                    for (var key in keyProbs) {
                        keyProbs[key] /= totalMass;
                    }
                    return keyProbs;
                };
                /**
                 * Computes a squared 'pseudo-distance' for the touch from each key.  (Not a proper metric.)
                 * Intended for use in generating a probability distribution over the keys based on the touch input.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.keyTouchDistances = function (touchCoords, kbdScaleRatio) {
                    var layer = this;
                    var keyDists = {};
                    // This double-nested loop computes a pseudo-distance for the touch from each key.  Quite useful for
                    // generating a probability distribution.
                    this.row.forEach(function (row) {
                        row.key.forEach(function (key) {
                            // If the key lacks an ID, just skip it.  Sometimes used for padding.
                            if (!key.id) {
                                return;
                            }
                            // These represent the within-key distance of the touch from the key's center.
                            // Both should be on the interval [0, 0.5].
                            var dx = Math.abs(touchCoords.x - key.proportionalX);
                            var dy = Math.abs(touchCoords.y - row.proportionalY);
                            // If the touch isn't within the key, these store the out-of-key distance
                            // from the closest point on the key being checked.
                            var distX, distY;
                            if (dx > 0.5 * key.proportionalWidth) {
                                distX = (dx - 0.5 * key.proportionalWidth);
                                dx = 0.5;
                            }
                            else {
                                distX = 0;
                                dx /= key.proportionalWidth;
                            }
                            if (dy > 0.5 * layer.rowProportionalHeight) {
                                distY = (dy - 0.5 * layer.rowProportionalHeight);
                                dy = 0.5;
                            }
                            else {
                                distY = 0;
                                dy /= layer.rowProportionalHeight;
                            }
                            // Now that the differentials are computed, it's time to do distance scaling.
                            //
                            // For out-of-key distance, we scale the X component by the keyboard's aspect ratio
                            // to get the actual out-of-key distance rather than proportional.
                            distX *= kbdScaleRatio;
                            // While the keys are rarely perfect squares, we map all within-key distance
                            // to a square shape.  (ALT/CMD should seem as close to SPACE as a 'B'.)
                            //
                            // For that square, we take the rowHeight as its edge lengths.
                            distX += dx * layer.rowProportionalHeight;
                            distY += dy * layer.rowProportionalHeight;
                            var distance = distX * distX + distY * distY;
                            keyDists[key.id] = distance;
                        });
                    });
                    return keyDists;
                };
                ActiveLayer.prototype.getKey = function (keyId) {
                    // Keys usually are specified in a "long form" prefixed with their layer's ID.
                    if (keyId.indexOf(this.id + '-') == 0) {
                        keyId = keyId.replace(this.id + '-', '');
                    }
                    return this.keyMap[keyId];
                };
                return ActiveLayer;
            }());
            keyboards.ActiveLayer = ActiveLayer;
            var ActiveLayout = /** @class */ (function () {
                function ActiveLayout() {
                }
                ActiveLayout.prototype.getLayer = function (layerId) {
                    return this.layerMap[layerId];
                };
                /**
                 *
                 * @param layout
                 * @param formFactor
                 */
                ActiveLayout.polyfill = function (layout, keyboard, formFactor) {
                    if (layout == null) {
                        throw new Error("Cannot build an ActiveLayout for a null specification.");
                    }
                    // Create a separate OSK div for each OSK layer, only one of which will ever be visible
                    var n, i;
                    var layers, layer;
                    var layerMap = {};
                    var rows;
                    layers = layout['layer'];
                    // ***Delete any empty rows at the end added by compiler bug...
                    for (n = 0; n < layers.length; n++) {
                        layer = layers[n];
                        rows = layer['row'];
                        for (i = rows.length; i > 0; i--) {
                            if (rows[i - 1]['key'].length > 0) {
                                break;
                            }
                        }
                        if (i < rows.length) {
                            rows.splice(i - rows.length, rows.length - i);
                        }
                    }
                    // ...remove to here when compiler bug fixed ***
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayout();
                    for (var key in dummy) {
                        if (!layout.hasOwnProperty(key)) {
                            layout[key] = dummy[key];
                        }
                    }
                    var aLayout = layout;
                    aLayout.keyboard = keyboard;
                    aLayout.formFactor = formFactor;
                    for (n = 0; n < layers.length; n++) {
                        ActiveLayer.polyfill(layers[n], aLayout);
                        layerMap[layers[n].id] = layers[n];
                    }
                    aLayout.layerMap = layerMap;
                    return aLayout;
                };
                return ActiveLayout;
            }());
            keyboards.ActiveLayout = ActiveLayout;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="engineDeviceSpec.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * Defines common behaviors associated with system stores.
             */
            var SystemStore = /** @class */ (function () {
                function SystemStore(id) {
                    this.id = id;
                }
                SystemStore.prototype.set = function (value) {
                    throw new Error("System store with ID " + this.id + " may not be directly set.");
                };
                return SystemStore;
            }());
            text.SystemStore = SystemStore;
            var MutableSystemStore = /** @class */ (function (_super) {
                __extends(MutableSystemStore, _super);
                function MutableSystemStore(id, defaultValue) {
                    var _this = _super.call(this, id) || this;
                    _this.handler = null;
                    _this._value = defaultValue;
                    return _this;
                }
                Object.defineProperty(MutableSystemStore.prototype, "value", {
                    get: function () {
                        return this._value;
                    },
                    enumerable: true,
                    configurable: true
                });
                MutableSystemStore.prototype.matches = function (value) {
                    return this._value == value;
                };
                MutableSystemStore.prototype.set = function (value) {
                    if (this.handler) {
                        if (this.handler(this, value)) {
                            return;
                        }
                    }
                    this._value = value;
                };
                return MutableSystemStore;
            }(SystemStore));
            text.MutableSystemStore = MutableSystemStore;
            /**
             * Handles checks against the current platform.
             */
            var PlatformSystemStore = /** @class */ (function (_super) {
                __extends(PlatformSystemStore, _super);
                function PlatformSystemStore(keyboardInterface) {
                    var _this = _super.call(this, text.KeyboardInterface.TSS_PLATFORM) || this;
                    _this.kbdInterface = keyboardInterface;
                    return _this;
                }
                PlatformSystemStore.prototype.matches = function (value) {
                    var i, constraint, constraints = value.split(' ');
                    var device = this.kbdInterface.activeDevice;
                    for (i = 0; i < constraints.length; i++) {
                        constraint = constraints[i].toLowerCase();
                        switch (constraint) {
                            case 'touch':
                            case 'hardware':
                                if (device.touchable != (constraint == 'touch')) {
                                    return false;
                                }
                                break;
                            case 'macos':
                            case 'mac':
                                constraint = 'macosx';
                            // fall through
                            case 'macosx':
                            case 'windows':
                            case 'android':
                            case 'ios':
                            case 'linux':
                                if (device.OS != constraint) {
                                    return false;
                                }
                                break;
                            case 'tablet':
                            case 'phone':
                            case 'desktop':
                                if (device.formFactor != constraint) {
                                    return false;
                                }
                                break;
                            case 'web':
                                if (device.browser == 'native') {
                                    return false; // web matches anything other than 'native'
                                }
                                break;
                            case 'native':
                            // This will return true for embedded KeymanWeb
                            case 'ie':
                            case 'chrome':
                            case 'firefox':
                            case 'safari':
                            case 'edge':
                            case 'opera':
                                if (device.browser != constraint) {
                                    return false;
                                }
                                break;
                            default:
                                return false;
                        }
                    }
                    // Everything we checked against was valid and had matches - it's a match!
                    return true;
                };
                return PlatformSystemStore;
            }(SystemStore));
            text.PlatformSystemStore = PlatformSystemStore;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="deadkeys.ts" />
/// <reference path="ruleBehavior.ts" />
// Defines classes for handling system stores
/// <reference path="systemStores.ts" />
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            //#region Helper type definitions
            var KeyInformation = /** @class */ (function () {
                function KeyInformation() {
                }
                return KeyInformation;
            }());
            text.KeyInformation = KeyInformation;
            var RuleDeadkey = /** @class */ (function () {
                function RuleDeadkey() {
                }
                return RuleDeadkey;
            }());
            var ContextAny = /** @class */ (function () {
                function ContextAny() {
                }
                return ContextAny;
            }());
            var RuleIndex = /** @class */ (function () {
                function RuleIndex() {
                }
                return RuleIndex;
            }());
            var ContextEx = /** @class */ (function () {
                function ContextEx() {
                }
                return ContextEx;
            }());
            var ContextNul = /** @class */ (function () {
                function ContextNul() {
                }
                return ContextNul;
            }());
            var StoreBeep = /** @class */ (function () {
                function StoreBeep() {
                }
                return StoreBeep;
            }());
            /**
             * Cache of context storing and retrieving return values from KC
             * Must be reset prior to each keystroke and after any text changes
             * MCD 3/1/14
             **/
            var CachedContext = /** @class */ (function () {
                function CachedContext() {
                }
                CachedContext.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContext.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContext.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                return CachedContext;
            }());
            ;
            /**
             * An extended version of cached context storing designed to work with
             * `fullContextMatch` and its helper functions.
             */
            var CachedContextEx = /** @class */ (function () {
                function CachedContextEx() {
                }
                CachedContextEx.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContextEx.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContextEx.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                return CachedContextEx;
            }());
            ;
            //#endregion
            var KeyboardInterface = /** @class */ (function () {
                function KeyboardInterface(variableStoreSerializer) {
                    if (variableStoreSerializer === void 0) { variableStoreSerializer = null; }
                    this.cachedContext = new CachedContext();
                    this.cachedContextEx = new CachedContextEx();
                    this._AnyIndices = []; // AnyIndex - array of any/index match indices
                    this.systemStores = {};
                    this.systemStores[KeyboardInterface.TSS_PLATFORM] = new text.PlatformSystemStore(this);
                    this.systemStores[KeyboardInterface.TSS_LAYER] = new text.MutableSystemStore(KeyboardInterface.TSS_LAYER, 'default');
                    this.variableStoreSerializer = variableStoreSerializer;
                }
                /**
                 * Function     KSF
                 * Scope        Public
                 *
                 * Saves the document's current focus settings on behalf of the keyboard.  Often paired with insertText.
                 */
                KeyboardInterface.prototype.saveFocus = function () { };
                /**
                 * Function     registerKeyboard  KR
                 * Scope        Public
                 * @param       {Object}      Pk      Keyboard  object
                 * Description  Registers a keyboard with KeymanWeb once its script has fully loaded.
                 *
                 *              In web-core, this also activates the keyboard; in other modules, this method
                 *              may be replaced with other implementations.
                 */
                KeyboardInterface.prototype.registerKeyboard = function (Pk) {
                    // NOTE:  This implementation is web-core specific and is intentionally replaced, whole-sale, 
                    //        by DOM-aware code.
                    var keyboard = new keyman.keyboards.Keyboard(Pk);
                    this.activeKeyboard = keyboard;
                };
                /**
                 * Get *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "abcdef"  i.e. return as much as possible of the requested string
                 */
                KeyboardInterface.prototype.context = function (n, ln, outputTarget) {
                    var v = this.cachedContext.get(n, ln);
                    if (v !== null) {
                        return v;
                    }
                    var r = this.KC_(n, ln, outputTarget);
                    this.cachedContext.set(n, ln, r);
                    return r;
                };
                /**
                 * Get (uncached) keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "XXXXabcdef"  i.e. return as much as possible of the requested string, where X = \uFFFE
                 */
                KeyboardInterface.prototype.KC_ = function (n, ln, outputTarget) {
                    var tempContext = '';
                    tempContext = outputTarget.getTextBeforeCaret();
                    if (tempContext._kmwLength() < n) {
                        tempContext = Array(n - tempContext._kmwLength() + 1).join("\uFFFE") + tempContext;
                    }
                    return tempContext._kmwSubstr(-n)._kmwSubstr(0, ln);
                };
                /**
                 * Function     nul           KN
                 * Scope        Public
                 * @param       {number}      n       Length of context to check
                 * @param       {Object}      Ptarg   Element to work with (must be currently focused element)
                 * @return      {boolean}             True if length of context is less than or equal to n
                 * Description  Test length of context, return true if the length of the context is less than or equal to n
                 *
                 * Example     [abc|def] as INPUT, with the caret position marked by |:
                 *             KN(3,Pelem) == TRUE
                 *             KN(2,Pelem) == FALSE
                 *             KN(4,Pelem) == TRUE
                 */
                KeyboardInterface.prototype.nul = function (n, outputTarget) {
                    var cx = this.context(n + 1, 1, outputTarget);
                    // With #31, the result will be a replacement character if context is empty.
                    return cx === "\uFFFE";
                };
                /**
                 * Function     contextMatch  KCM
                 * Scope        Public
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {Object}      Ptarg   Focused element
                 * @param       {string}      val     String to match
                 * @param       {number}      ln      Number of characters to return
                 * @return      {boolean}             True if selected context matches val
                 * Description  Test keyboard context for match
                 */
                KeyboardInterface.prototype.contextMatch = function (n, outputTarget, val, ln) {
                    var cx = this.context(n, ln, outputTarget);
                    if (cx === val) {
                        return true; // I3318
                    }
                    outputTarget.deadkeys().resetMatched(); // I3318
                    return false;
                };
                /**
                 * Builds the *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {Array}               Context array (of strings and numbers)
                 */
                KeyboardInterface.prototype._BuildExtendedContext = function (n, ln, outputTarget) {
                    var cache = this.cachedContextEx.get(n, ln);
                    if (cache !== null) {
                        return cache;
                    }
                    else {
                        // By far the easiest way to correctly build what we want is to start from the right and work to what we need.
                        // We may have done it for a similar cursor position before.
                        cache = this.cachedContextEx.get(n, n);
                        if (cache === null) {
                            // First, let's make sure we have a cloned, sorted copy of the deadkey array.
                            var unmatchedDeadkeys = outputTarget.deadkeys().toSortedArray(); // Is reverse-order sorted for us already.
                            // Time to build from scratch!
                            var index = 0;
                            cache = { valContext: [], deadContext: [] };
                            while (cache.valContext.length < n) {
                                // As adapted from `deadkeyMatch`.
                                var sp = outputTarget.getDeadkeyCaret();
                                var deadPos = sp - index;
                                if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p > deadPos) {
                                    // We have deadkeys at the right-hand side of the caret!  They don't belong in the context, so pop 'em off.
                                    unmatchedDeadkeys.splice(0, 1);
                                    continue;
                                }
                                else if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p == deadPos) {
                                    // Take the deadkey.
                                    cache.deadContext[n - cache.valContext.length - 1] = unmatchedDeadkeys[0];
                                    cache.valContext = [unmatchedDeadkeys[0].d].concat(cache.valContext);
                                    unmatchedDeadkeys.splice(0, 1);
                                }
                                else {
                                    // Take the character.  We get "\ufffe" if it doesn't exist.
                                    var kc = this.context(++index, 1, outputTarget);
                                    cache.valContext = [kc].concat(cache.valContext);
                                }
                            }
                            this.cachedContextEx.set(n, n, cache);
                        }
                        // Now that we have the cache...
                        var subCache = cache;
                        subCache.valContext = subCache.valContext.slice(0, ln);
                        for (var i = 0; i < subCache.valContext.length; i++) {
                            if (subCache[i] == '\ufffe') {
                                subCache.valContext.splice(0, 1);
                                subCache.deadContext.splice(0, 1);
                            }
                        }
                        if (subCache.valContext.length == 0) {
                            subCache.valContext = ['\ufffe'];
                            subCache.deadContext = [];
                        }
                        this.cachedContextEx.set(n, ln, subCache);
                        return subCache;
                    }
                };
                /**
                 * Function       fullContextMatch    KFCM
                 * Scope          Private
                 * @param         {number}    n       Number of characters to move back from caret
                 * @param         {Object}    Ptarg   Focused element
                 * @param         {Array}     rule    An array of ContextEntries to match.
                 * @return        {boolean}           True if the fully-specified rule context matches the current KMW state.
                 *
                 * A KMW 10+ function designed to bring KMW closer to Keyman Desktop functionality,
                 * near-directly modeling (externally) the compiled form of Desktop rules' context section.
                 */
                KeyboardInterface.prototype.fullContextMatch = function (n, outputTarget, rule) {
                    // Stage one:  build the context index map.
                    var fullContext = this._BuildExtendedContext(n, rule.length, outputTarget);
                    var context = fullContext.valContext;
                    var deadContext = fullContext.deadContext;
                    var mismatch = false;
                    // This symbol internally indicates lack of context in a position.  (See KC_)
                    var NUL_CONTEXT = "\uFFFE";
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    // Stage two:  time to match against the rule specified.
                    for (var i = 0; i < rule.length; i++) {
                        if (typeof rule[i] == 'string') {
                            var str = rule[i];
                            if (str !== context[i]) {
                                mismatch = true;
                                break;
                            }
                        }
                        else {
                            // TypeScript needs a cast to this intermediate type to do its discriminated union magic.
                            var r = rule[i];
                            switch (r.t) {
                                case 'd':
                                    // We still need to set a flag here; 
                                    if (r['d'] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'a':
                                    var lookup;
                                    if (typeof context[i] == 'string') {
                                        lookup = context[i];
                                    }
                                    else {
                                        lookup = { 't': 'd', 'd': context[i] };
                                    }
                                    var result = this.any(i, lookup, r.a);
                                    if (!r.n) { // If it's a standard 'any'...
                                        if (!result) {
                                            mismatch = true;
                                        }
                                        else if (deadContext[i] !== undefined) {
                                            // It's a deadkey match, so indicate that.
                                            deadContext[i].set();
                                        }
                                        // 'n' for 'notany'.  If we actually match or if we have nul context (\uFFFE), notany fails.
                                    }
                                    else if (r.n && (result || context[i] !== NUL_CONTEXT)) {
                                        mismatch = true;
                                    }
                                    break;
                                case 'i':
                                    // The context will never hold a 'beep.'
                                    var ch = this._Index(r.i, r.o);
                                    if (ch !== undefined && (typeof (ch) == 'string' ? ch : ch.d) !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'c':
                                    if (context[r.c - 1] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'n':
                                    // \uFFFE is the internal 'no context here sentinel'.
                                    if (context[i] != NUL_CONTEXT) {
                                        mismatch = true;
                                    }
                                    break;
                                default:
                                    assertNever(r);
                            }
                        }
                    }
                    if (mismatch) {
                        // Reset the matched 'any' indices, if any.
                        outputTarget.deadkeys().resetMatched();
                        this._AnyIndices = [];
                    }
                    return !mismatch;
                };
                /**
                 * Function     KIK
                 * Scope        Public
                 * @param       {Object}  e   keystroke event
                 * @return      {boolean}     true if keypress event
                 * Description  Test if event as a keypress event
                 */
                KeyboardInterface.prototype.isKeypress = function (e) {
                    if (this.activeKeyboard.isMnemonic) { // I1380 - support KIK for positional layouts
                        return !e.LisVirtualKey; // will now return true for U_xxxx keys, but not for T_xxxx keys
                    }
                    else {
                        return keyman.KeyMapping._USKeyCodeToCharCode(e) ? true : false; // I1380 - support KIK for positional layouts
                    }
                };
                /**
                 * Function     keyMatch      KKM
                 * Scope        Public
                 * @param       {Object}      e           keystroke event
                 * @param       {number}      Lruleshift
                 * @param       {number}      Lrulekey
                 * @return      {boolean}                 True if key matches rule
                 * Description  Test keystroke with modifiers against rule
                 */
                KeyboardInterface.prototype.keyMatch = function (e, Lruleshift, Lrulekey) {
                    var retVal = false; // I3318
                    var keyCode = (e.Lcode == 173 ? 189 : e.Lcode); //I3555 (Firefox hyphen issue)
                    var bitmask = this.activeKeyboard.modifierBitmask;
                    var Codes = com.keyman.text.Codes;
                    var modifierBitmask = bitmask & Codes.modifierBitmasks["ALL"];
                    var stateBitmask = bitmask & Codes.stateBitmasks["ALL"];
                    if (e.vkCode > 255) {
                        keyCode = e.vkCode; // added to support extended (touch-hold) keys for mnemonic layouts
                    }
                    if (e.LisVirtualKey || keyCode > 255) {
                        if ((Lruleshift & 0x4000) == 0x4000 || (keyCode > 255)) { // added keyCode test to support extended keys
                            retVal = ((Lrulekey == keyCode) && ((Lruleshift & modifierBitmask) == e.Lmodifiers)); //I3318, I3555
                            retVal = retVal && this.stateMatch(e, Lruleshift & stateBitmask);
                        }
                    }
                    else if ((Lruleshift & 0x4000) == 0) {
                        retVal = (keyCode == Lrulekey); // I3318, I3555
                    }
                    if (!retVal) {
                        this.activeTargetOutput.deadkeys().resetMatched(); // I3318
                    }
                    return retVal; // I3318
                };
                ;
                /**
                 * Function     stateMatch    KSM
                 * Scope        Public
                 * @param       {Object}      e       keystroke event
                 * @param       {number}      Lstate
                 * Description  Test keystroke against state key rules
                 */
                KeyboardInterface.prototype.stateMatch = function (e, Lstate) {
                    return ((Lstate & e.Lstates) == Lstate);
                };
                /**
                 * Function     keyInformation  KKI
                 * Scope        Public
                 * @param       {Object}      e
                 * @return      {Object}              Object with event's virtual key flag, key code, and modifiers
                 * Description  Get object with extended key event information
                 */
                KeyboardInterface.prototype.keyInformation = function (e) {
                    var ei = new KeyInformation();
                    ei['vk'] = e.LisVirtualKey;
                    ei['code'] = e.Lcode;
                    ei['modifiers'] = e.Lmodifiers;
                    return ei;
                };
                ;
                /**
                 * Function     deadkeyMatch  KDM
                 * Scope        Public
                 * @param       {number}      n       offset from current cursor position
                 * @param       {Object}      Ptarg   target element
                 * @param       {number}      d       deadkey
                 * @return      {boolean}             True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                KeyboardInterface.prototype.deadkeyMatch = function (n, outputTarget, d) {
                    return outputTarget.hasDeadkeyMatch(n, d);
                };
                /**
                 * Function     beep          KB
                 * Scope        Public
                 * @param       {Object}      Pelem     element to flash
                 * Description  Flash body as substitute for audible beep; notify embedded device to vibrate
                 */
                KeyboardInterface.prototype.beep = function (outputTarget) {
                    this.resetContextCache();
                    // Denote as part of the matched rule's behavior.
                    this.ruleBehavior.beep = true;
                };
                KeyboardInterface.prototype._ExplodeStore = function (store) {
                    if (typeof (store) == 'string') {
                        var cachedStores = this.activeKeyboard.explodedStores;
                        // Is the result cached?
                        if (cachedStores[store]) {
                            return cachedStores[store];
                        }
                        // Nope, so let's build its cache.
                        var result = [];
                        for (var i = 0; i < store._kmwLength(); i++) {
                            result.push(store._kmwCharAt(i));
                        }
                        // Cache the result for later!
                        cachedStores[store] = result;
                        return result;
                    }
                    else {
                        return store;
                    }
                };
                /**
                 * Function     any           KA
                 * Scope        Public
                 * @param       {number}      n     character position (index)
                 * @param       {string}      ch    character to find in string
                 * @param       {string}      s     'any' string
                 * @return      {boolean}           True if character found in 'any' string, sets index accordingly
                 * Description  Test for character matching
                 */
                KeyboardInterface.prototype.any = function (n, ch, s) {
                    if (ch == '') {
                        return false;
                    }
                    s = this._ExplodeStore(s);
                    var Lix = -1;
                    for (var i = 0; i < s.length; i++) {
                        if (typeof (s[i]) == 'string') {
                            if (s[i] == ch) {
                                Lix = i;
                                break;
                            }
                        }
                        else if (s[i]['d'] === ch['d']) {
                            Lix = i;
                            break;
                        }
                    }
                    this._AnyIndices[n] = Lix;
                    return Lix >= 0;
                };
                /**
                 * Function     _Index
                 * Scope        Public
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * Description  Returns the character from a store string according to the offset in the index array
                 */
                KeyboardInterface.prototype._Index = function (Ps, Pn) {
                    Ps = this._ExplodeStore(Ps);
                    if (this._AnyIndices[Pn - 1] < Ps.length) { //I3319
                        return Ps[this._AnyIndices[Pn - 1]];
                    }
                    else {
                        /* Should not be possible for a compiled keyboard, but may arise
                        * during the development of handwritten keyboards.
                        */
                        console.warn("Unmatched contextual index() statement detected in rule with index " + Pn + "!");
                        return "";
                    }
                };
                /**
                 * Function     indexOutput   KIO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * @param       {Object}      Pelem   element to output to
                 * Description  Output a character selected from the string according to the offset in the index array
                 */
                KeyboardInterface.prototype.indexOutput = function (Pdn, Ps, Pn, outputTarget) {
                    this.resetContextCache();
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    var indexChar = this._Index(Ps, Pn);
                    if (indexChar !== "") {
                        if (typeof indexChar == 'string') {
                            this.output(Pdn, outputTarget, indexChar); //I3319
                        }
                        else if (indexChar['t']) {
                            var storeEntry = indexChar;
                            switch (storeEntry.t) {
                                case 'b': // Beep commands may appear within stores.
                                    this.beep(outputTarget);
                                    break;
                                case 'd':
                                    this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                                    break;
                                default:
                                    assertNever(storeEntry);
                            }
                        }
                        else { // For keyboards developed during 10.0's alpha phase - t:'d' was assumed.
                            this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                        }
                    }
                };
                /**
                 * Function     deleteContext KDC
                 * Scope        Public
                 * @param       {number}      dn      number of context entries to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.deleteContext = function (dn, outputTarget) {
                    var context;
                    // We want to control exactly which deadkeys get removed.
                    if (dn > 0) {
                        context = this._BuildExtendedContext(dn, dn, outputTarget);
                        var nulCount = 0;
                        for (var i = 0; i < context.valContext.length; i++) {
                            var dk = context.deadContext[i];
                            if (dk) {
                                // Remove deadkey in context.
                                outputTarget.deadkeys().remove(dk);
                                // Reduce our reported context size.
                                dn--;
                            }
                            else if (context.valContext[i] == "\uFFFE") {
                                // Count any `nul` sentinels that would contribute to our deletion count.
                                nulCount++;
                            }
                        }
                        // Prevent attempts to delete nul sentinels, as they don't exist in the actual context.
                        // (Addresses regression from KMW v 12.0 paired with Developer bug through same version)
                        var contextLength = context.valContext.length - nulCount;
                        if (dn > contextLength) {
                            dn = contextLength;
                        }
                    }
                    // If a matched deadkey hasn't been deleted, we don't WANT to delete it.
                    outputTarget.deadkeys().resetMatched();
                    // Why reinvent the wheel?  Delete the remaining characters by 'inserting a blank string'.
                    this.output(dn, outputTarget, '');
                };
                /**
                 * Function     output        KO
                 * Scope        Public
                 * @param       {number}      dn      number of characters to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.output = function (dn, outputTarget, s) {
                    this.resetContextCache();
                    outputTarget.saveProperties();
                    outputTarget.clearSelection();
                    outputTarget.deadkeys().deleteMatched(); // I3318
                    if (dn >= 0) {
                        // Automatically manages affected deadkey positions.  Does not delete deadkeys b/c legacy behavior support.
                        outputTarget.deleteCharsBeforeCaret(dn);
                    }
                    // Automatically manages affected deadkey positions.
                    outputTarget.insertTextBeforeCaret(s);
                    outputTarget.restoreProperties();
                };
                /**
                 * Function     deadkeyOutput KDO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {Object}      Pelem   element to output to
                 * @param       {number}      Pd      deadkey id
                 * Description  Record a deadkey at current cursor position, deleting Pdn characters first
                 */
                KeyboardInterface.prototype.deadkeyOutput = function (Pdn, outputTarget, Pd) {
                    this.resetContextCache();
                    if (Pdn >= 0) {
                        this.output(Pdn, outputTarget, ""); //I3318 corrected to >=
                    }
                    outputTarget.insertDeadkeyBeforeCaret(Pd);
                    //    _DebugDeadKeys(Pelem, 'KDeadKeyOutput: dn='+Pdn+'; deadKey='+Pd);
                };
                /**
                 * KIFS compares the content of a system store with a string value
                 *
                 * @param       {number}      systemId    ID of the system store to test (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String value to compare to
                 * @param       {Object}      Pelem       Currently active element (may be needed by future tests)
                 * @return      {boolean}                 True if the test succeeds
                 */
                KeyboardInterface.prototype.ifStore = function (systemId, strValue, outputTarget) {
                    var result = true;
                    var store = this.systemStores[systemId];
                    if (store) {
                        result = store.matches(strValue);
                    }
                    return result; //Moved from previous line, now supports layer selection, Build 350 
                };
                /**
                 * KSETS sets the value of a system store to a string
                 *
                 * @param       {number}      systemId    ID of the system store to set (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String to set as the system store content
                 * @param       {Object}      Pelem       Currently active element (may be needed in future tests)
                 * @return      {boolean}                 True if command succeeds
                 *                                        (i.e. for TSS_LAYER, if the layer is successfully selected)
                 *
                 * Note that option/variable stores are instead set within keyboard script code, as they only
                 * affect keyboard behavior.
                 */
                KeyboardInterface.prototype.setStore = function (systemId, strValue, outputTarget) {
                    this.resetContextCache();
                    if (systemId == KeyboardInterface.TSS_LAYER) {
                        // Denote the changed store as part of the matched rule's behavior.
                        this.ruleBehavior.setStore[systemId] = strValue;
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * Load an option store value from a cookie or default value
                 *
                 * @param       {string}      kbdName     keyboard internal name
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      dfltValue   default value
                 * @return      {string}                  current or default option value
                 *
                 * This will only ever be called when the keyboard is loaded, as it is used by keyboards
                 * to initialize a store value on the keyboard's script object.
                 */
                KeyboardInterface.prototype.loadStore = function (kbdName, storeName, dfltValue) {
                    this.resetContextCache();
                    if (this.variableStoreSerializer) {
                        var cValue = this.variableStoreSerializer.loadStore(kbdName, storeName);
                        return cValue[storeName] || dfltValue;
                    }
                    else {
                        return dfltValue;
                    }
                };
                /**
                 * Save an option store value to a cookie
                 *
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      optValue    option value to save
                 * @return      {boolean}                 true if save successful
                 *
                 * Note that a keyboard will freely manipulate the value of its variable stores on the
                 * script object within its own code.  This function's use is merely to _persist_ that
                 * value across sessions, providing a custom user default for later uses of the keyboard.
                 */
                KeyboardInterface.prototype.saveStore = function (storeName, optValue) {
                    this.resetContextCache();
                    var kbd = this.activeKeyboard;
                    if (!kbd || typeof kbd.id == 'undefined' || kbd.id == '') {
                        return false;
                    }
                    // And the lookup under that entry looks for the value under the store name, again.
                    var valueObj = {};
                    valueObj[storeName] = optValue;
                    // Null-check in case of invocation during unit-test
                    if (this.ruleBehavior) {
                        this.ruleBehavior.saveStore[storeName] = valueObj;
                    }
                    else {
                        // We're in a unit-test environment, directly invoking this method from outside of a keyboard.
                        // In this case, we should immediately commit the change.
                        this.variableStoreSerializer.saveStore(this.activeKeyboard.id, storeName, valueObj);
                    }
                    return true;
                };
                KeyboardInterface.prototype.resetContextCache = function () {
                    this.cachedContext.reset();
                    this.cachedContextEx.reset();
                };
                KeyboardInterface.prototype.defaultBackspace = function (outputTarget) {
                    this.output(1, outputTarget, "");
                };
                /**
                 * Function     processKeystroke
                 * Scope        Private
                 * @param       {Object}        element     The page element receiving input
                 * @param       {Object}        keystroke   The input keystroke (with its properties) to be mapped by the keyboard.
                 * Description  Encapsulates calls to keyboard input processing.
                 * @returns     {number}        0 if no match is made, otherwise 1.
                 */
                KeyboardInterface.prototype.processKeystroke = function (outputTarget, keystroke) {
                    // Clear internal state tracking data from prior keystrokes.
                    if (!outputTarget) {
                        throw "No target specified for keyboard output!";
                    }
                    else if (!this.activeKeyboard) {
                        throw "No active keyboard for keystroke processing!";
                    }
                    outputTarget.invalidateSelection();
                    outputTarget.deadkeys().resetMatched(); // I3318    
                    this.resetContextCache();
                    // Capture the initial state of the OutputTarget before any rules are matched.
                    var preInput = text.Mock.from(outputTarget);
                    // Establishes the results object, allowing corresponding commands to set values here as appropriate.
                    this.ruleBehavior = new text.RuleBehavior();
                    // Ensure the settings are in place so that KIFS/ifState activates and deactivates
                    // the appropriate rule(s) for the modeled device.
                    this.activeDevice = keystroke.device;
                    // Calls the start-group of the active keyboard.
                    this.activeTargetOutput = outputTarget;
                    var matched = this.activeKeyboard.process(outputTarget, keystroke);
                    this.activeTargetOutput = null;
                    if (!matched) {
                        return null;
                    }
                    // Finalize the rule's results.
                    this.ruleBehavior.transcription = outputTarget.buildTranscriptionFrom(preInput, keystroke);
                    // Clear our result-tracking variable to prevent any possible pollution for future processing.
                    var behavior = this.ruleBehavior;
                    this.ruleBehavior = null;
                    return behavior;
                };
                // Publishes the KeyboardInterface's shorthand API names.
                // Note that this may need to be called multiple times; a keyboard-processor consumer
                // may extend or overwrite some of the callbacks after this method's initial call.
                KeyboardInterface.__publishShorthandAPI = function () {
                    // Keyboard callbacks
                    var prototype = this.prototype;
                    var exportKBCallback = function (miniName, longName) {
                        prototype[miniName] = prototype[longName];
                    };
                    exportKBCallback('KSF', 'saveFocus');
                    exportKBCallback('KBR', 'beepReset');
                    exportKBCallback('KT', 'insertText');
                    exportKBCallback('KR', 'registerKeyboard');
                    exportKBCallback('KRS', 'registerStub');
                    exportKBCallback('KC', 'context');
                    exportKBCallback('KN', 'nul');
                    exportKBCallback('KCM', 'contextMatch');
                    exportKBCallback('KFCM', 'fullContextMatch');
                    exportKBCallback('KIK', 'isKeypress');
                    exportKBCallback('KKM', 'keyMatch');
                    exportKBCallback('KSM', 'stateMatch');
                    exportKBCallback('KKI', 'keyInformation');
                    exportKBCallback('KDM', 'deadkeyMatch');
                    exportKBCallback('KB', 'beep');
                    exportKBCallback('KA', 'any');
                    exportKBCallback('KDC', 'deleteContext');
                    exportKBCallback('KO', 'output');
                    exportKBCallback('KDO', 'deadkeyOutput');
                    exportKBCallback('KIO', 'indexOutput');
                    exportKBCallback('KIFS', 'ifStore');
                    exportKBCallback('KSETS', 'setStore');
                    exportKBCallback('KLOAD', 'loadStore');
                    exportKBCallback('KSAVE', 'saveStore');
                };
                KeyboardInterface.GLOBAL_NAME = 'KeymanWeb';
                KeyboardInterface.TSS_LAYER = 33;
                KeyboardInterface.TSS_PLATFORM = 31;
                return KeyboardInterface;
            }());
            text.KeyboardInterface = KeyboardInterface;
            (function () {
                // This will be the only call within the keyboard-processor module.
                KeyboardInterface.__publishShorthandAPI();
            }());
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="defaultLayouts.ts" />
/// <reference path="activeLayout.ts" />
/// <reference path="../text/kbdInterface.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            /**
             * Stores preprocessed properties of a keyboard for quick retrieval later.
             */
            var CacheTag = /** @class */ (function () {
                function CacheTag() {
                    this.stores = {};
                }
                return CacheTag;
            }());
            var LayoutState;
            (function (LayoutState) {
                LayoutState[LayoutState["NOT_LOADED"] = undefined] = "NOT_LOADED";
                LayoutState[LayoutState["POLYFILLED"] = 1] = "POLYFILLED";
                LayoutState[LayoutState["CALIBRATED"] = 2] = "CALIBRATED";
            })(LayoutState = keyboards.LayoutState || (keyboards.LayoutState = {}));
            /**
             * Acts as a wrapper class for Keyman keyboards compiled to JS, providing type information
             * and keyboard-centered functionality in an object-oriented way without modifying the
             * wrapped keyboard itself.
             */
            var Keyboard = /** @class */ (function () {
                function Keyboard(keyboardScript) {
                    if (keyboardScript) {
                        this.scriptObject = keyboardScript;
                    }
                    else {
                        this.scriptObject = Keyboard.DEFAULT_SCRIPT_OBJECT;
                    }
                    this.layoutStates = {};
                }
                /**
                 * Calls the keyboard's `gs` function, which represents the keyboard source's group(main).
                 */
                Keyboard.prototype.process = function (outputTarget, keystroke) {
                    return this.scriptObject['gs'](outputTarget, keystroke);
                };
                Object.defineProperty(Keyboard.prototype, "isHollow", {
                    get: function () {
                        return this.scriptObject == Keyboard.DEFAULT_SCRIPT_OBJECT;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "id", {
                    get: function () {
                        return this.scriptObject['KI'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "name", {
                    get: function () {
                        return this.scriptObject['KN'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "displaysUnderlyingKeys", {
                    get: function () {
                        // Returns false if undefined or false-like (including 0), true otherwise.
                        return !!this.scriptObject['KDU'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "_legacyLayoutSpec", {
                    // TODO:  Better typing.
                    get: function () {
                        return this.scriptObject['KV']; // used with buildDefaultLayout; layout must be constructed at runtime.
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "_layouts", {
                    // May return null if no layouts exist or have been initialized.
                    get: function () {
                        return this.scriptObject['KVKL']; // This one is compiled by Developer's visual keyboard layout editor.
                    },
                    set: function (value) {
                        this.scriptObject['KVKL'] = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "compilerVersion", {
                    get: function () {
                        return new keyman.utils.Version(this.scriptObject['KVER']);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isMnemonic", {
                    get: function () {
                        return !!this.scriptObject['KM'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "definesPositionalOrMnemonic", {
                    get: function () {
                        return typeof this.scriptObject['KM'] != 'undefined';
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "helpText", {
                    /**
                     * HTML help text which is a one liner intended for the status bar of the desktop OSK originally.
                     *
                     * Reference: https://help.keyman.com/developer/language/reference/kmw_helptext
                     */
                    get: function () {
                        return this.scriptObject['KH'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "hasHelpHTML", {
                    get: function () {
                        return !!this.scriptObject['KHF'];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Replaces the OSK with custom HTML, which may be interactive (like with sil_euro_latin).
                 *
                 * Reference: https://help.keyman.com/developer/language/reference/kmw_helpfile
                 */
                Keyboard.prototype.insertHelpHTML = function (e) {
                    // e:  Expects the OSKManager's _Box element.  We don't add type info here b/c it would
                    //     reference the DOM.
                    this.scriptObject['KHF'](e);
                };
                Object.defineProperty(Keyboard.prototype, "oskStyling", {
                    get: function () {
                        return this.scriptObject['KCSS'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isCJK", {
                    /**
                     * true if this keyboard uses a (legacy) pick list (Chinese, Japanese, Korean, etc.)
                     *
                     * TODO:  Make a property on keyboards (say, `isPickList` / `KPL`) to signal this when we
                     *        get around to better, generalized picker-list support.
                     */
                    get: function () {
                        var lg;
                        if (typeof (this.scriptObject['KLC']) != 'undefined') {
                            lg = this.scriptObject['KLC'];
                        }
                        else if (typeof (this.scriptObject['LanguageCode']) != 'undefined') {
                            lg = this.scriptObject['LanguageCode'];
                        }
                        // While some of these aren't proper BCP-47 language codes, the CJK keyboards predate our use of BCP-47.
                        // So, we preserve the old ISO 639-3 codes, as that's what the keyboards are matching against.
                        return ((lg == 'cmn') || (lg == 'jpn') || (lg == 'kor'));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isRTL", {
                    get: function () {
                        return !!this.scriptObject['KRTL'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "modifierBitmask", {
                    /**
                     * Obtains the currently-active modifier bitmask for the active keyboard.
                     */
                    get: function () {
                        // NON_CHIRAL is the default bitmask if KMBM is not defined.
                        // We always need a bitmask to compare against, as seen in `isChiral`.
                        return this.scriptObject['KMBM'] || keyman.text.Codes.modifierBitmasks['NON_CHIRAL'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isChiral", {
                    get: function () {
                        return !!(this.modifierBitmask & keyman.text.Codes.modifierBitmasks['IS_CHIRAL']);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "desktopFont", {
                    get: function () {
                        if (this.scriptObject['KV']) {
                            return this.scriptObject['KV']['F'];
                        }
                        else {
                            return null;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "cacheTag", {
                    get: function () {
                        var tag = this.scriptObject['_kmw'];
                        if (!tag) {
                            tag = new CacheTag();
                            this.scriptObject['_kmw'] = tag;
                        }
                        return tag;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "explodedStores", {
                    get: function () {
                        return this.cacheTag.stores;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "emulatesAltGr", {
                    /**
                     * Signifies whether or not a layout or OSK should include AltGr / Right-alt emulation for this keyboard.
                     * @param   {Object=}   keyLabels
                     * @return  {boolean}
                     */
                    get: function () {
                        var modifierCodes = keyman.text.Codes.modifierCodes;
                        // If we're not chiral, we're not emulating.
                        if (!this.isChiral) {
                            return false;
                        }
                        if (this._legacyLayoutSpec == null) {
                            return false;
                        }
                        // Only exists in KMW 10.0+, but before that Web had no chirality support, so... return false.
                        var layers = this._legacyLayoutSpec['KLS'];
                        if (!layers) {
                            return false;
                        }
                        var emulationMask = modifierCodes['LCTRL'] | modifierCodes['LALT'];
                        var unshiftedEmulationLayer = layers[keyboards.Layouts.getLayerId(emulationMask)];
                        var shiftedEmulationLayer = layers[keyboards.Layouts.getLayerId(modifierCodes['SHIFT'] | emulationMask)];
                        // buildDefaultLayout ensures that these are aliased to the original modifier set being emulated.
                        // As a result, we can directly test for reference equality.
                        //
                        // This allows us to still return `true` after creating the layers for emulation; during keyboard
                        // construction, the two layers should be null for AltGr emulation to succeed.
                        if (unshiftedEmulationLayer != null &&
                            unshiftedEmulationLayer != layers[keyboards.Layouts.getLayerId(modifierCodes['RALT'])]) {
                            return false;
                        }
                        if (shiftedEmulationLayer != null &&
                            shiftedEmulationLayer != layers[keyboards.Layouts.getLayerId(modifierCodes['RALT'] | modifierCodes['SHIFT'])]) {
                            return false;
                        }
                        // It's technically possible for the OSK to not specify anything while allowing chiral input.  A last-ditch catch:
                        var bitmask = this.modifierBitmask;
                        if ((bitmask & emulationMask) != emulationMask) {
                            // At least one of the emulation modifiers is never used by the keyboard!  We can confirm everything's safe.
                            return true;
                        }
                        if (unshiftedEmulationLayer == null && shiftedEmulationLayer == null) {
                            // We've run out of things to go on; we can't detect if chiral AltGr emulation is intended or not.
                            // TODO:  handle this again!
                            // if(!osk.altGrWarning) {
                            //   console.warn("Could not detect if AltGr emulation is safe, but defaulting to active emulation!")
                            //   // Avoid spamming the console with warnings on every call of the method.
                            //   osk.altGrWarning = true;
                            // }
                            return true;
                        }
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Keyboard.prototype.usesDesktopLayoutOnDevice = function (device) {
                    if (this.scriptObject['KVKL']) {
                        // A custom mobile layout is defined... but are we using it?
                        return device.formFactor == keyman.text.FormFactor.Desktop;
                    }
                    else {
                        return true;
                    }
                };
                /**
                 * @param       {number}    _PCommand     event code (16,17,18) or 0
                 * @param       {Object}    _PTarget      target element
                 * @param       {number}    _PData        1 or 0
                 * Notifies keyboard of keystroke or other event
                 */
                Keyboard.prototype.notify = function (_PCommand, _PTarget, _PData) {
                    // Good example use case - the Japanese CJK-picker keyboard
                    if (typeof (this.scriptObject['KNS']) == 'function') {
                        this.scriptObject['KNS'](_PCommand, _PTarget, _PData);
                    }
                };
                Keyboard.prototype.findOrConstructLayout = function (formFactor) {
                    if (this._layouts) {
                        // Search for viable layouts.  `null` is allowed for desktop form factors when help text is available,
                        // so we check explicitly against `undefined`.
                        if (this._layouts[formFactor] !== undefined) {
                            return this._layouts[formFactor];
                        }
                        else if (formFactor == keyman.text.FormFactor.Phone && this._layouts[keyman.text.FormFactor.Tablet]) {
                            return this._layouts[keyman.text.FormFactor.Phone] = this._layouts[keyman.text.FormFactor.Tablet];
                        }
                        else if (formFactor == keyman.text.FormFactor.Tablet && this._layouts[keyman.text.FormFactor.Phone]) {
                            return this._layouts[keyman.text.FormFactor.Tablet] = this._layouts[keyman.text.FormFactor.Phone];
                        }
                    }
                    // No pre-built layout available; time to start constructing it via defaults.
                    // First, if we have non-default keys specified by the ['BK'] array, we've got
                    // enough to work with to build a default layout.
                    var rawSpecifications = null; // TODO:  better typing, same type as this._legacyLayoutSpec.
                    if (this._legacyLayoutSpec != null && this._legacyLayoutSpec['KLS']) { // KLS is only specified whenever there are non-default keys.
                        rawSpecifications = this._legacyLayoutSpec;
                    }
                    else if (this._legacyLayoutSpec != null && this._legacyLayoutSpec['BK'] != null) {
                        var keyCaps = this._legacyLayoutSpec['BK'];
                        for (var i = 0; i < keyCaps.length; i++) {
                            if (keyCaps[i].length > 0) {
                                rawSpecifications = this._legacyLayoutSpec;
                                break;
                            }
                        }
                    }
                    // If we don't have key definitions to use for a layout but also lack help text or are a touch-based layout,
                    // we make a default layout anyway.  We have to show display something usable.
                    if (!rawSpecifications && (this.helpText == '' || formFactor != keyman.text.FormFactor.Desktop)) {
                        rawSpecifications = { 'F': 'Tahoma', 'BK': keyboards.Layouts.dfltText };
                    }
                    // Regardless of success, we'll want to initialize the field that backs the property; 
                    // may as well cache the default layout we just built, or a 'null' if it shouldn't exist..
                    if (!this._layouts) {
                        this._layouts = {};
                    }
                    // Final check - do we construct a layout, or is this a case where helpText / insertHelpHTML should take over?
                    if (rawSpecifications) {
                        // Now to generate a layout from our raw specifications.
                        var layout = this._layouts[formFactor] = keyboards.Layouts.buildDefaultLayout(rawSpecifications, this, formFactor);
                        layout.isDefault = true;
                        return layout;
                    }
                    else {
                        // The fact that it doesn't exist will indicate that help text/HTML should be inserted instead.
                        this._layouts[formFactor] = null; // provides a cached value for the check at the top of this method.
                        return null;
                    }
                };
                /**
                 * Returns an ActiveLayout object representing the keyboard's layout for this form factor.  May return null if a custom desktop "help" OSK is defined, as with sil_euro_latin.
                 *
                 * In such cases, please use either `helpText` or `insertHelpHTML` instead.
                 * @param formFactor {string} The desired form factor for the layout.
                 */
                Keyboard.prototype.layout = function (formFactor) {
                    var rawLayout = this.findOrConstructLayout(formFactor);
                    if (rawLayout) {
                        // Prevents accidentally reprocessing layouts; it's a simple enough check.
                        if (this.layoutStates[formFactor] == LayoutState.NOT_LOADED) {
                            rawLayout = keyboards.ActiveLayout.polyfill(rawLayout, this, formFactor);
                            this.layoutStates[formFactor] = LayoutState.POLYFILLED;
                        }
                        return rawLayout;
                    }
                    else {
                        return null;
                    }
                };
                Keyboard.prototype.markLayoutCalibrated = function (formFactor) {
                    if (this.layoutStates[formFactor] != LayoutState.NOT_LOADED) {
                        this.layoutStates[formFactor] = LayoutState.CALIBRATED;
                    }
                };
                Keyboard.prototype.getLayoutState = function (formFactor) {
                    return this.layoutStates[formFactor];
                };
                Keyboard.DEFAULT_SCRIPT_OBJECT = {
                    'gs': function (outputTarget, keystroke) { return false; },
                    'KI': '',
                    'KN': '',
                    'KV': keyboards.Layouts.DEFAULT_RAW_SPEC,
                    'KM': 0 // May not be the best default, but this matches current behavior when there is no activeKeyboard.
                };
                return Keyboard;
            }());
            keyboards.Keyboard = Keyboard;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var KeyMap = /** @class */ (function () {
            function KeyMap() {
            }
            return KeyMap;
        }());
        var BrowserKeyMaps = /** @class */ (function () {
            function BrowserKeyMaps() {
                this.FF = new KeyMap();
                this.Safari = new KeyMap();
                this.Opera = new KeyMap();
                //ffie['k109'] = 189; // -    // These two number-pad VK rules are *not* correct for more recent FF! JMD 8/11/12
                //ffie['k107'] = 187; // =    // FF 3.0 // I2062
                this.FF['k61'] = 187; // =   // FF 2.0
                this.FF['k59'] = 186; // ;
            }
            return BrowserKeyMaps;
        }());
        var LanguageKeyMaps = /** @class */ (function () {
            // // Here are some old legacy definitions that were no longer referenced but are likely related:
            // static _BaseLayoutEuro: {[code: string]: string} = {
            //   'se': '\u00a71234567890+´~~~QWERTYUIOP\u00c5\u00a8\'~~~ASDFGHJKL\u00d6\u00c4~~~~~<ZXCVBNM,.-~~~~~ ',  // Swedish
            //   'uk': '`1234567890-=~~~QWERTYUIOP[]#~~~ASDFGHJKL;\'~~~~~\\ZXCVBNM,./~~~~~ ' // UK
            function LanguageKeyMaps() {
                /* I732 START - 13/03/2007 MCD: Swedish: Start mapping of keystroke to US keyboard #2 */
                // Swedish key map
                this['se'] = new KeyMap();
                this['se']['k220'] = 192; // `
                this['se']['k187'] = 189; // -
                this['se']['k219'] = 187; // =
                this['se']['k221'] = 219; // [
                this['se']['k186'] = 221; // ]
                this['se']['k191'] = 220; // \
                this['se']['k192'] = 186; // ;
                this['se']['k189'] = 191; // /
                this['uk'] = new KeyMap(); // I1299
                this['uk']['k223'] = 192; // // ` U+00AC (logical not) =>  ` ~
                this['uk']['k192'] = 222; // ' @  =>  ' "
                this['uk']['k222'] = 226; // # ~  => K_oE2     // I1504 - UK keyboard mixup #, \
                this['uk']['k220'] = 220; // \ |  => \ |       // I1504 - UK keyboard mixup #, \
            }
            return LanguageKeyMaps;
        }());
        var KeyMapping = /** @class */ (function () {
            function KeyMapping() {
                // Do not construct this class.
            }
            KeyMapping._usCodeInit = function () {
                var s0 = new KeyMap(), s1 = new KeyMap();
                s0['k192'] = 96;
                s0['k49'] = 49;
                s0['k50'] = 50;
                s0['k51'] = 51;
                s0['k52'] = 52;
                s0['k53'] = 53;
                s0['k54'] = 54;
                s0['k55'] = 55;
                s0['k56'] = 56;
                s0['k57'] = 57;
                s0['k48'] = 48;
                s0['k189'] = 45;
                s0['k187'] = 61;
                s0['k81'] = 113;
                s0['k87'] = 119;
                s0['k69'] = 101;
                s0['k82'] = 114;
                s0['k84'] = 116;
                s0['k89'] = 121;
                s0['k85'] = 117;
                s0['k73'] = 105;
                s0['k79'] = 111;
                s0['k80'] = 112;
                s0['k219'] = 91;
                s0['k221'] = 93;
                s0['k220'] = 92;
                s0['k65'] = 97;
                s0['k83'] = 115;
                s0['k68'] = 100;
                s0['k70'] = 102;
                s0['k71'] = 103;
                s0['k72'] = 104;
                s0['k74'] = 106;
                s0['k75'] = 107;
                s0['k76'] = 108;
                s0['k186'] = 59;
                s0['k222'] = 39;
                s0['k90'] = 122;
                s0['k88'] = 120;
                s0['k67'] = 99;
                s0['k86'] = 118;
                s0['k66'] = 98;
                s0['k78'] = 110;
                s0['k77'] = 109;
                s0['k188'] = 44;
                s0['k190'] = 46;
                s0['k191'] = 47;
                s1['k192'] = 126;
                s1['k49'] = 33;
                s1['k50'] = 64;
                s1['k51'] = 35;
                s1['k52'] = 36;
                s1['k53'] = 37;
                s1['k54'] = 94;
                s1['k55'] = 38;
                s1['k56'] = 42;
                s1['k57'] = 40;
                s1['k48'] = 41;
                s1['k189'] = 95;
                s1['k187'] = 43;
                s1['k81'] = 81;
                s1['k87'] = 87;
                s1['k69'] = 69;
                s1['k82'] = 82;
                s1['k84'] = 84;
                s1['k89'] = 89;
                s1['k85'] = 85;
                s1['k73'] = 73;
                s1['k79'] = 79;
                s1['k80'] = 80;
                s1['k219'] = 123;
                s1['k221'] = 125;
                s1['k220'] = 124;
                s1['k65'] = 65;
                s1['k83'] = 83;
                s1['k68'] = 68;
                s1['k70'] = 70;
                s1['k71'] = 71;
                s1['k72'] = 72;
                s1['k74'] = 74;
                s1['k75'] = 75;
                s1['k76'] = 76;
                s1['k186'] = 58;
                s1['k222'] = 34;
                s1['k90'] = 90;
                s1['k88'] = 88;
                s1['k67'] = 67;
                s1['k86'] = 86;
                s1['k66'] = 66;
                s1['k78'] = 78;
                s1['k77'] = 77;
                s1['k188'] = 60;
                s1['k190'] = 62;
                s1['k191'] = 63;
                KeyMapping._usCharCodes = [s0, s1];
            };
            /**
             * Function     _USKeyCodeToCharCode
             * Scope        Private
             * @param       {Event}     Levent      KMW event object
             * @return      {number}                Character code
             * Description Translate keyboard codes to standard US layout codes
             */
            KeyMapping._USKeyCodeToCharCode = function (Levent) {
                return KeyMapping.usCharCodes[Levent.Lmodifiers & 0x10 ? 1 : 0]['k' + Levent.Lcode];
            };
            ;
            Object.defineProperty(KeyMapping, "usCharCodes", {
                get: function () {
                    if (!KeyMapping._usCharCodes) {
                        KeyMapping._usCodeInit();
                    }
                    return KeyMapping._usCharCodes;
                },
                enumerable: true,
                configurable: true
            });
            KeyMapping.browserMap = new BrowserKeyMaps();
            KeyMapping.languageMap = new LanguageKeyMaps();
            return KeyMapping;
        }());
        keyman.KeyMapping = KeyMapping;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Returns the base global object available to the current JS platform.
             * - In browsers, returns `window`.
             * - In WebWorkers, returns `self`.
             * - In Node, returns `global`.
             */
            function getGlobalObject() {
                // Evergreen browsers have started defining 'globalThis'.  
                // Refer to https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#type-checking-for-globalthis
                // and its referenced polyfill.  Said polyfill is very complex, so we opt for this far leaner variant.
                if (typeof globalThis != 'undefined') {
                    return globalThis; // Not available in IE or older Edge versions
                    // @ts-ignore (TS will throw errors for whatever platform we're not compiling for.)
                }
                else if (typeof window != 'undefined') {
                    // @ts-ignore
                    return window; // The browser-based classic
                    // @ts-ignore
                }
                else if (typeof self != 'undefined') {
                    // @ts-ignore
                    return self; // WebWorker global
                }
                else {
                    // Assumption - if neither of the above exist, we're in Node, for unit-testing.
                    // Node doesn't have as many methods and properties as the other two, but what 
                    // matters for us is that it's the base global.
                    //
                    // Some other headless JS solutions use 'this' instead, but Node's enough for our needs.
                    // @ts-ignore
                    return global;
                }
            }
            utils.getGlobalObject = getGlobalObject;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Includes KMW string extension declarations.
/// <reference path="kmwstring.ts" />
// Establishes key-code definitions.
/// <reference path="codes.ts" />
// Defines our generalized "KeyEvent" class.
/// <reference path="keyEvent.ts" />
// Defines the RuleBehavior keyboard-processing return object.
/// <reference path="ruleBehavior.ts" />
// Defines default key handling behaviors.
/// <reference path="defaultOutput.ts" />
// Defines the keyboard wrapper object.
/// <reference path="../keyboards/keyboard.ts" />
// Defines built-in keymapping.
/// <reference path="keyMapping.ts" />
// Defines a core-compatible 'Device' analogue for use in keyEvent processing
/// <reference path="engineDeviceSpec.ts" />
// Defines the getGlobalObject() utility method.
/// <reference path="../utils/globalObject.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var KeyboardProcessor = /** @class */ (function () {
                function KeyboardProcessor(options) {
                    // Tracks the simulated value for supported state keys, allowing the OSK to mirror a physical keyboard for them.
                    // Using the exact keyCode name from the Codes definitions will allow for certain optimizations elsewhere in the code.
                    this.stateKeys = {
                        "K_CAPS": false,
                        "K_NUMLOCK": false,
                        "K_SCROLL": false
                    };
                    // Tracks the most recent modifier state information in order to quickly detect changes
                    // in keyboard state not otherwise captured by the hosting page in the browser.
                    // Needed for AltGr simulation.
                    this.modStateFlags = 0;
                    if (!options) {
                        options = KeyboardProcessor.DEFAULT_OPTIONS;
                    }
                    this.baseLayout = options.baseLayout || KeyboardProcessor.DEFAULT_OPTIONS.baseLayout;
                    this.keyboardInterface = new text.KeyboardInterface(options.variableStoreSerializer);
                    this.installInterface();
                }
                KeyboardProcessor.prototype.installInterface = function () {
                    // TODO:  replace 'window' with a (currently-unwritten) utility call that retrieves 
                    //        the global object (whether browser, Node, WebWorker).
                    //
                    //        We must ensure that the keyboard can find the API functions at the expected place.
                    var globalThis = keyman.utils.getGlobalObject();
                    globalThis[text.KeyboardInterface.GLOBAL_NAME] = this.keyboardInterface;
                    // Ensure that the active keyboard is set on the keyboard interface object.
                    if (this.activeKeyboard) {
                        this.keyboardInterface.activeKeyboard = this.activeKeyboard;
                    }
                };
                Object.defineProperty(KeyboardProcessor.prototype, "activeKeyboard", {
                    get: function () {
                        return this.keyboardInterface.activeKeyboard;
                    },
                    set: function (keyboard) {
                        this.keyboardInterface.activeKeyboard = keyboard;
                        // All old deadkeys and keyboard-specific cache should immediately be invalidated
                        // on a keyboard change.
                        this.resetContext();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardProcessor.prototype, "layerStore", {
                    get: function () {
                        return this.keyboardInterface.systemStores[text.KeyboardInterface.TSS_LAYER];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardProcessor.prototype, "layerId", {
                    get: function () {
                        return this.layerStore.value;
                    },
                    // Note:  will trigger an 'event' callback designed to notify the OSK of layer changes.
                    set: function (value) {
                        this.layerStore.set(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Get the default RuleBehavior for the specified key, attempting to mimic standard browser defaults
                 * where and when appropriate.
                 *
                 * @param   {object}  Lkc  The pre-analyzed key event object
                 * @param   {boolean} usingOSK
                 * @return  {string}
                 */
                KeyboardProcessor.prototype.defaultRuleBehavior = function (Lkc) {
                    var outputTarget = Lkc.Ltarg;
                    var preInput = text.Mock.from(outputTarget);
                    var ruleBehavior = new text.RuleBehavior();
                    var matched = false;
                    var char = '';
                    var special;
                    if (Lkc.isSynthetic || outputTarget.isSynthetic) {
                        matched = true; // All the conditions below result in matches until the final else, which restores the expected default
                        // if no match occurs.
                        if (text.DefaultOutput.isCommand(Lkc)) {
                            // Note this in the rule behavior, return successfully.  We'll consider applying it later.
                            ruleBehavior.triggersDefaultCommand = true;
                            // We'd rather let the browser handle these keys, but we're using emulated keystrokes, forcing KMW
                            // to emulate default behavior here.
                        }
                        else if ((special = text.DefaultOutput.forSpecialEmulation(Lkc)) != null) {
                            switch (special) {
                                case text.EmulationKeystrokes.Backspace:
                                    this.keyboardInterface.defaultBackspace(outputTarget);
                                    break;
                                case text.EmulationKeystrokes.Enter:
                                    outputTarget.handleNewlineAtCaret();
                                    break;
                                case text.EmulationKeystrokes.Space:
                                    this.keyboardInterface.output(0, outputTarget, ' ');
                                    break;
                                // case '\u007f': // K_DEL
                                // // For (possible) future implementation.
                                // // Would recommend (conceptually) equaling K_RIGHT + K_BKSP, the former of which would technically be a 'command'.
                                default:
                                    // In case we extend the allowed set, but forget to implement its handling case above.
                                    ruleBehavior.errorLog = "Unexpected 'special emulation' character (\\u" + special.kmwCharCodeAt(0).toString(16) + ") went unhandled!";
                            }
                        }
                        else {
                            // Back to the standard default, pending normal matching.
                            matched = false;
                        }
                    }
                    var isMnemonic = this.activeKeyboard && this.activeKeyboard.isMnemonic;
                    if (!matched) {
                        if ((char = text.DefaultOutput.forAny(Lkc, isMnemonic)) != null) {
                            special = text.DefaultOutput.forSpecialEmulation(Lkc);
                            if (special == text.EmulationKeystrokes.Backspace) {
                                // A browser's default backspace may fail to delete both parts of an SMP character.
                                this.keyboardInterface.defaultBackspace(Lkc.Ltarg);
                            }
                            else if (special || text.DefaultOutput.isCommand(Lkc)) { // Filters out 'commands' like TAB.
                                // We only do the "for special emulation" cases under the condition above... aside from backspace
                                // Let the browser handle those.
                                return null;
                            }
                            else {
                                this.keyboardInterface.output(0, outputTarget, char);
                            }
                        }
                        else {
                            // No match, no default RuleBehavior.
                            return null;
                        }
                    }
                    // Shortcut things immediately if there were issues generating this rule behavior.
                    if (ruleBehavior.errorLog) {
                        return ruleBehavior;
                    }
                    var transcription = outputTarget.buildTranscriptionFrom(preInput, Lkc);
                    ruleBehavior.transcription = transcription;
                    return ruleBehavior;
                };
                KeyboardProcessor.prototype.setSyntheticEventDefaults = function (Lkc) {
                    // Set the flags for the state keys.
                    Lkc.Lstates |= this.stateKeys['K_CAPS'] ? text.Codes.modifierCodes['CAPS'] : text.Codes.modifierCodes['NO_CAPS'];
                    Lkc.Lstates |= this.stateKeys['K_NUMLOCK'] ? text.Codes.modifierCodes['NUM_LOCK'] : text.Codes.modifierCodes['NO_NUM_LOCK'];
                    Lkc.Lstates |= this.stateKeys['K_SCROLL'] ? text.Codes.modifierCodes['SCROLL_LOCK'] : text.Codes.modifierCodes['NO_SCROLL_LOCK'];
                    // Set LisVirtualKey to false to ensure that nomatch rule does fire for U_xxxx keys
                    if (Lkc.kName.substr(0, 2) == 'U_') {
                        Lkc.LisVirtualKey = false;
                    }
                    // Get code for non-physical keys (T_KOKAI, U_05AB etc)
                    if (typeof Lkc.Lcode == 'undefined') {
                        Lkc.Lcode = this.getVKDictionaryCode(Lkc.kName); // Updated for Build 347
                        if (!Lkc.Lcode) {
                            // Special case for U_xxxx keys. This vk code will never be used
                            // in a keyboard, so we use this to ensure that keystroke processing
                            // occurs for the key.
                            Lkc.Lcode = 1;
                        }
                    }
                    // Handles modifier states when the OSK is emulating rightalt through the leftctrl-leftalt layer.
                    if ((Lkc.Lmodifiers & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM'] && this.activeKeyboard.emulatesAltGr) {
                        Lkc.Lmodifiers &= ~text.Codes.modifierBitmasks['ALT_GR_SIM'];
                        Lkc.Lmodifiers |= text.Codes.modifierCodes['RALT'];
                    }
                };
                KeyboardProcessor.prototype.processKeystroke = function (keyEvent, outputTarget) {
                    var matchBehavior;
                    // Pass this key code and state to the keyboard program
                    if (this.activeKeyboard && keyEvent.Lcode != 0) {
                        /*
                         * The `this.installInterface()` call is insurance against something I've seen in unit tests when things break a bit.
                         *
                         * Currently, when a KMW shutdown doesn't go through properly or completely, sometimes we end up with parallel
                         * versions of KMW running, and an old, partially-shutdown one will "snipe" a command meant for the most-recent
                         * one's test. So, installing here ensures that the active Processor has its matching KeyboardInterface ready,
                         * even should that occur.
                         */
                        this.installInterface();
                        matchBehavior = this.keyboardInterface.processKeystroke(outputTarget, keyEvent);
                    }
                    if (!matchBehavior) {
                        // Restore the virtual key code if a mnemonic keyboard is being used
                        // If no vkCode value was stored, maintain the original Lcode value.
                        keyEvent.Lcode = keyEvent.vkCode || keyEvent.Lcode;
                        // Handle unmapped keys, including special keys
                        // The following is physical layout dependent, so should be avoided if possible.  All keys should be mapped.
                        this.keyboardInterface.activeTargetOutput = outputTarget;
                        // Match against the 'default keyboard' - rules to mimic the default string output when typing in a browser.
                        // Many keyboards rely upon these 'implied rules'.
                        matchBehavior = this.defaultRuleBehavior(keyEvent);
                        this.keyboardInterface.activeTargetOutput = null;
                    }
                    return matchBehavior;
                };
                // FIXME:  makes some bad assumptions.
                KeyboardProcessor.setMnemonicCode = function (Lkc, shifted, capsActive) {
                    // K_SPACE is not handled by defaultKeyOutput for physical keystrokes unless using touch-aliased elements.
                    // It's also a "exception required, March 2013" for clickKey, so at least they both have this requirement.
                    if (Lkc.Lcode != text.Codes.keyCodes['K_SPACE']) {
                        // So long as the key name isn't prefixed with 'U_', we'll get a default mapping based on the Lcode value.
                        // We need to determine the mnemonic base character - for example, SHIFT + K_PERIOD needs to map to '>'.
                        var mappingEvent = new text.KeyEvent();
                        for (var key in Lkc) {
                            mappingEvent[key] = Lkc[key];
                        }
                        // To facilitate storing relevant commands, we should probably reverse-lookup
                        // the actual keyname instead.
                        mappingEvent.kName = 'K_xxxx';
                        mappingEvent.Ltarg = new text.Mock(); // helps prevent breakage for mnemonics.
                        mappingEvent.Lmodifiers = (shifted ? 0x10 : 0); // mnemonic lookups only exist for default & shift layers.
                        var mappedChar = text.DefaultOutput.forAny(mappingEvent, true);
                        /* First, save a backup of the original code.  This one won't needlessly trigger keyboard
                         * rules, but allows us to replicate/emulate commands after rule processing if needed.
                         * (Like backspaces)
                         */
                        Lkc.vkCode = Lkc.Lcode;
                        if (mappedChar) {
                            // Will return 96 for 'a', which is a keycode corresponding to Codes.keyCodes('K_NP1') - a numpad key.
                            // That stated, we're in mnemonic mode - this keyboard's rules are based on the char codes.
                            Lkc.Lcode = mappedChar.charCodeAt(0);
                        }
                        else {
                            // Don't let command-type keys (like K_DEL, which will output '.' otherwise!)
                            // trigger keyboard rules.
                            delete Lkc.Lcode;
                        }
                    }
                    if (capsActive) {
                        // TODO:  Needs fixing - does not properly mirror physical keystrokes, as Lcode range 96-111 corresponds
                        // to numpad keys!  (Physical keyboard section has its own issues here.)
                        if ((Lkc.Lcode >= 65 && Lkc.Lcode <= 90) /* 'A' - 'Z' */ || (Lkc.Lcode >= 97 && Lkc.Lcode <= 122) /* 'a' - 'z' */) {
                            Lkc.Lmodifiers ^= 0x10; // Flip the 'shifted' bit, so it'll act as the opposite key.
                            Lkc.Lcode ^= 0x20; // Flips the 'upper' vs 'lower' bit for the base 'a'-'z' ASCII alphabetics.
                        }
                    }
                };
                /**
                 * Get modifier key state from layer id
                 *
                 * @param       {string}      layerId       layer id (e.g. ctrlshift)
                 * @return      {number}                    modifier key state (desktop keyboards)
                 */
                KeyboardProcessor.getModifierState = function (layerId) {
                    var modifier = 0;
                    if (layerId.indexOf('shift') >= 0) {
                        modifier |= text.Codes.modifierCodes['SHIFT'];
                    }
                    // The chiral checks must not be directly exclusive due each other to visual OSK feedback.
                    var ctrlMatched = false;
                    if (layerId.indexOf('leftctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['LCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('rightctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['RCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('ctrl') >= 0 && !ctrlMatched) {
                        modifier |= text.Codes.modifierCodes['CTRL'];
                    }
                    var altMatched = false;
                    if (layerId.indexOf('leftalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['LALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('rightalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['RALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('alt') >= 0 && !altMatched) {
                        modifier |= text.Codes.modifierCodes['ALT'];
                    }
                    return modifier;
                };
                /**
                 * @summary Look up a custom virtual key code in the virtual key code dictionary KVKD.  On first run, will build the dictionary.
                 *
                 * `VKDictionary` is constructed from the keyboard's `KVKD` member. This list is constructed
                 * at compile-time and is a list of 'additional' virtual key codes, starting at 256 (i.e.
                 * outside the range of standard virtual key codes). These additional codes are both
                 * `[T_xxx]` and `[U_xxxx]` custom key codes from the Keyman keyboard language. However,
                 * `[U_xxxx]` keys only generate an entry in `KVKD` if there is a corresponding rule that
                 * is associated with them in the keyboard rules. If the `[U_xxxx]` key code is only
                 * referenced as the id of a key in the touch layout, then it does not get an entry in
                 * the `KVKD` property.
                 *
                 * @private
                 * @param       {string}      keyName   custom virtual key code to lookup in the dictionary
                 * @return      {number}                key code > 255 on success, or 0 if not found
                 */
                KeyboardProcessor.prototype.getVKDictionaryCode = function (keyName) {
                    var activeKeyboard = this.activeKeyboard;
                    if (!activeKeyboard.scriptObject['VKDictionary']) {
                        var a = [];
                        if (typeof activeKeyboard.scriptObject['KVKD'] == 'string') {
                            // Build the VK dictionary
                            // TODO: Move the dictionary build into the compiler -- so compiler generates code such as following.  
                            // Makes the VKDictionary member unnecessary.
                            //       this.KVKD={"K_ABC":256,"K_DEF":257,...};
                            var s = activeKeyboard.scriptObject['KVKD'].split(' ');
                            for (var i = 0; i < s.length; i++) {
                                a[s[i].toUpperCase()] = i + 256; // We force upper-case since virtual keys should be case-insensitive.
                            }
                        }
                        activeKeyboard.scriptObject['VKDictionary'] = a;
                    }
                    var res = activeKeyboard.scriptObject['VKDictionary'][keyName.toUpperCase()];
                    return res ? res : 0;
                };
                /**
                 * Function     _UpdateVKShift
                 * Scope        Private
                 * @param       {Object}            e     OSK event
                 * @param       {number}            v     keyboard shift state
                 * @param       {(boolean|number)}  d     set (1) or clear(0) shift state bits
                 * @return      {boolean}                 Always true
                 * Description  Updates the current shift state within KMW, updating the OSK's visualization thereof.
                 */
                KeyboardProcessor.prototype._UpdateVKShift = function (e, v, d) {
                    var keyShiftState = 0, lockStates = 0, i;
                    var lockNames = ['CAPS', 'NUM_LOCK', 'SCROLL_LOCK'];
                    var lockKeys = ['K_CAPS', 'K_NUMLOCK', 'K_SCROLL'];
                    if (!this.activeKeyboard) {
                        return true;
                    }
                    if (e) {
                        // read shift states from Pevent
                        keyShiftState = e.Lmodifiers;
                        lockStates = e.Lstates;
                        // Are we simulating AltGr?  If it's a simulation and not real, time to un-simulate for the OSK.
                        if (this.activeKeyboard.isChiral && (this.activeKeyboard.emulatesAltGr) &&
                            (this.modStateFlags & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM']) {
                            keyShiftState |= text.Codes.modifierBitmasks['ALT_GR_SIM'];
                            keyShiftState &= ~text.Codes.modifierCodes['RALT'];
                        }
                        for (i = 0; i < lockNames.length; i++) {
                            if (lockStates & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = lockStates & text.Codes.modifierCodes[lockNames[i]];
                            }
                        }
                    }
                    else if (d) {
                        keyShiftState |= v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = true;
                            }
                        }
                    }
                    else {
                        keyShiftState &= ~v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = false;
                            }
                        }
                    }
                    this.layerId = this.getLayerId(keyShiftState);
                    return true;
                };
                KeyboardProcessor.prototype.getLayerId = function (modifier) {
                    return keyman.keyboards.Layouts.getLayerId(modifier);
                };
                /**
                 * Select the OSK's next keyboard layer based upon layer switching keys as a default
                 * The next layer will be determined from the key name unless otherwise specifed
                 *
                 *  @param  {string}                    keyName     key identifier
                 *  @param  {number|string|undefined}   nextLayerIn optional next layer identifier
                 *  @return {boolean}                               return true if keyboard layer changed
                 */
                KeyboardProcessor.prototype.selectLayer = function (keyEvent, fromNameOnly) {
                    if (fromNameOnly === void 0) { fromNameOnly = false; }
                    var keyName = keyEvent.kName;
                    var nextLayer = fromNameOnly ? null : keyEvent.kNextLayer;
                    var isChiral = this.activeKeyboard && this.activeKeyboard.isChiral;
                    // Layer must be identified by name, not number (27/08/2015)
                    if (typeof nextLayer == 'number') {
                        nextLayer = this.getLayerId(nextLayer * 0x10);
                    }
                    // Identify next layer, if required by key
                    if (!nextLayer) {
                        switch (keyName) {
                            case 'K_LSHIFT':
                            case 'K_RSHIFT':
                            case 'K_SHIFT':
                                nextLayer = 'shift';
                                break;
                            case 'K_LCONTROL':
                            case 'K_LCTRL':
                                if (isChiral) {
                                    nextLayer = 'leftctrl';
                                    break;
                                }
                            case 'K_RCONTROL':
                            case 'K_RCTRL':
                                if (isChiral) {
                                    nextLayer = 'rightctrl';
                                    break;
                                }
                            case 'K_CTRL':
                                nextLayer = 'ctrl';
                                break;
                            case 'K_LMENU':
                            case 'K_LALT':
                                if (isChiral) {
                                    nextLayer = 'leftalt';
                                    break;
                                }
                            case 'K_RMENU':
                            case 'K_RALT':
                                if (isChiral) {
                                    nextLayer = 'rightalt';
                                    break;
                                }
                            case 'K_ALT':
                                nextLayer = 'alt';
                                break;
                            case 'K_ALTGR':
                                if (isChiral) {
                                    nextLayer = 'leftctrl-rightalt';
                                }
                                else {
                                    nextLayer = 'ctrl-alt';
                                }
                                break;
                            case 'K_CURRENCIES':
                            case 'K_NUMERALS':
                            case 'K_SHIFTED':
                            case 'K_UPPER':
                            case 'K_LOWER':
                            case 'K_SYMBOLS':
                                nextLayer = 'default';
                                break;
                        }
                    }
                    // If no key corresponding to a layer transition is pressed, maintain the current layer.
                    if (!nextLayer) {
                        return false;
                    }
                    // Change layer and refresh OSK
                    this.updateLayer(keyEvent, nextLayer);
                    return true;
                };
                /**
                 * Sets the new layer id, allowing for toggling shift/ctrl/alt while preserving the remainder
                 * of the modifiers represented by the current layer id (where applicable)
                 *
                 * @param       {string}      id      layer id (e.g. ctrlshift)
                 */
                KeyboardProcessor.prototype.updateLayer = function (keyEvent, id) {
                    var activeLayer = this.layerId;
                    var s = activeLayer;
                    // Do not change layer unless needed (27/08/2015)
                    if (id == activeLayer && keyEvent.device.formFactor != text.FormFactor.Desktop) {
                        return false;
                    }
                    var idx = id;
                    var i;
                    if (keyEvent.device.formFactor == text.FormFactor.Desktop) {
                        // Need to test if target layer is a standard layer (based on the plain 'default')
                        var replacements = ['leftctrl', 'rightctrl', 'ctrl', 'leftalt', 'rightalt', 'alt', 'shift'];
                        for (i = 0; i < replacements.length; i++) {
                            // Don't forget to remove the kebab-case hyphens!
                            idx = idx.replace(replacements[i] + '-', '');
                            idx = idx.replace(replacements[i], '');
                        }
                        // If we are presently on the default layer, drop the 'default' and go straight to the shifted mode.
                        // If on a common symbolic layer, drop out of symbolic mode and go straight to the shifted mode.
                        if (activeLayer == 'default' || activeLayer == 'numeric' || activeLayer == 'symbol' || activeLayer == 'currency' || idx != '') {
                            s = id;
                        }
                        // Otherwise, we are based upon a layer that accepts modifier variations.
                        // Modify the layer according to the current state and key pressed.
                        //
                        // TODO:  Consider:  should this ever be allowed for a base layer other than 'default'?  If not,
                        // if(idx == '') with accompanying if-else structural shift would be a far better test here.
                        else {
                            // Save our current modifier state.
                            var modifier = KeyboardProcessor.getModifierState(s);
                            // Strip down to the base modifiable layer.
                            for (i = 0; i < replacements.length; i++) {
                                // Don't forget to remove the kebab-case hyphens!
                                s = s.replace(replacements[i] + '-', '');
                                s = s.replace(replacements[i], '');
                            }
                            // Toggle the modifier represented by our input argument.
                            switch (id) {
                                case 'shift':
                                    modifier ^= text.Codes.modifierCodes['SHIFT'];
                                    break;
                                case 'leftctrl':
                                    modifier ^= text.Codes.modifierCodes['LCTRL'];
                                    break;
                                case 'rightctrl':
                                    modifier ^= text.Codes.modifierCodes['RCTRL'];
                                    break;
                                case 'ctrl':
                                    modifier ^= text.Codes.modifierCodes['CTRL'];
                                    break;
                                case 'leftalt':
                                    modifier ^= text.Codes.modifierCodes['LALT'];
                                    break;
                                case 'rightalt':
                                    modifier ^= text.Codes.modifierCodes['RALT'];
                                    break;
                                case 'alt':
                                    modifier ^= text.Codes.modifierCodes['ALT'];
                                    break;
                                default:
                                    s = id;
                            }
                            // Combine our base modifiable layer and attach the new modifier variation info to obtain our destination layer.
                            if (s != 'default') {
                                if (s == '') {
                                    s = this.getLayerId(modifier);
                                }
                                else {
                                    s = this.getLayerId(modifier) + '-' + s;
                                }
                            }
                        }
                        if (s == '') {
                            s = 'default';
                        }
                    }
                    else {
                        // Mobile form-factor.  Either the layout is specified by a keyboard developer with direct layer name references
                        // or all layers are accessed via subkey of a single layer-shifting key - no need for modifier-combining logic.
                        s = id;
                    }
                    var layout = this.activeKeyboard.layout(keyEvent.device.formFactor);
                    if (layout.getLayer(s)) {
                        this.layerId = s;
                    }
                    else {
                        this.layerId = 'default';
                    }
                };
                // Returns true if the key event is a modifier press, allowing keyPress to return selectively
                // in those cases.
                KeyboardProcessor.prototype.doModifierPress = function (Levent, isKeyDown) {
                    var outputTarget = Levent.Ltarg;
                    if (!this.activeKeyboard) {
                        return false;
                    }
                    switch (Levent.Lcode) {
                        case 8:
                            outputTarget.deadkeys().clear();
                            break; // I3318 (always clear deadkeys after backspace) 
                        case 16: //"K_SHIFT":16,"K_CONTROL":17,"K_ALT":18
                        case 17:
                        case 18:
                        case 20: //"K_CAPS":20, "K_NUMLOCK":144,"K_SCROLL":145
                        case 144:
                        case 145:
                            // For eventual integration - we bypass an OSK update for physical keystrokes when in touch mode.
                            this.activeKeyboard.notify(Levent.Lcode, outputTarget, isKeyDown ? 1 : 0);
                            if (!Levent.device.touchable) {
                                return this._UpdateVKShift(Levent, Levent.Lcode - 15, 1); // I2187
                            }
                            else {
                                return true;
                            }
                    }
                    if (Levent.LmodifierChange) {
                        this.activeKeyboard.notify(0, outputTarget, 1);
                        this._UpdateVKShift(Levent, 0, 1);
                    }
                    // No modifier keypresses detected.
                    return false;
                };
                KeyboardProcessor.prototype.resetContext = function () {
                    this.layerId = 'default';
                    this.keyboardInterface.resetContextCache();
                    this._UpdateVKShift(null, 15, 0);
                };
                ;
                KeyboardProcessor.prototype.setNumericLayer = function (device) {
                    var layout = this.activeKeyboard.layout(device.formFactor);
                    if (layout.getLayer('numeric')) {
                        this.layerId = 'numeric';
                    }
                };
                ;
                KeyboardProcessor.DEFAULT_OPTIONS = {
                    baseLayout: 'us'
                };
                return KeyboardProcessor;
            }());
            text.KeyboardProcessor = KeyboardProcessor;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
(function () {
    var ns = com.keyman.text;
    // Let LMLayer be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ns.KeyboardProcessor;
        //@ts-ignore
        ns.KeyboardProcessor.com = com; // Export the root namespace, while we're at it - just in case.
    }
}());
/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
(function (e, t) { if (typeof define === "function" && define.amd) {
    define(t);
}
else if (typeof exports === "object") {
    module.exports = t();
}
else {
    e.returnExports = t();
} })(this, function () {
    "use strict";
    var e = Function.call.bind(Function.apply);
    var t = Function.call.bind(Function.call);
    var r = Array.isArray;
    var n = Object.keys;
    var o = function notThunker(t) { return function notThunk() { return !e(t, this, arguments); }; };
    var i = function (e) { try {
        e();
        return false;
    }
    catch (t) {
        return true;
    } };
    var a = function valueOrFalseIfThrows(e) { try {
        return e();
    }
    catch (t) {
        return false;
    } };
    var u = o(i);
    var f = function () { return !i(function () { return Object.defineProperty({}, "x", { get: function () { } }); }); };
    var s = !!Object.defineProperty && f();
    var c = function foo() { }.name === "foo";
    var l = Function.call.bind(Array.prototype.forEach);
    var p = Function.call.bind(Array.prototype.reduce);
    var v = Function.call.bind(Array.prototype.filter);
    var y = Function.call.bind(Array.prototype.some);
    var h = function (e, t, r, n) { if (!n && t in e) {
        return;
    } if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: false, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var b = function (e, t, r) { l(n(t), function (n) { var o = t[n]; h(e, n, o, !!r); }); };
    var g = Function.call.bind(Object.prototype.toString);
    var d = typeof /abc/ === "function" ? function IsCallableSlow(e) { return typeof e === "function" && g(e) === "[object Function]"; } : function IsCallableFast(e) { return typeof e === "function"; };
    var m = { getter: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } Object.defineProperty(e, t, { configurable: true, enumerable: false, get: r }); }, proxy: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } var n = Object.getOwnPropertyDescriptor(e, t); Object.defineProperty(r, t, { configurable: n.configurable, enumerable: n.enumerable, get: function getKey() { return e[t]; }, set: function setKey(r) { e[t] = r; } }); }, redefine: function (e, t, r) { if (s) {
            var n = Object.getOwnPropertyDescriptor(e, t);
            n.value = r;
            Object.defineProperty(e, t, n);
        }
        else {
            e[t] = r;
        } }, defineByDescriptor: function (e, t, r) { if (s) {
            Object.defineProperty(e, t, r);
        }
        else if ("value" in r) {
            e[t] = r.value;
        } }, preserveToString: function (e, t) { if (t && d(t.toString)) {
            h(e, "toString", t.toString.bind(t), true);
        } } };
    var O = Object.create || function (e, t) { var r = function Prototype() { }; r.prototype = e; var o = new r; if (typeof t !== "undefined") {
        n(t).forEach(function (e) { m.defineByDescriptor(o, e, t[e]); });
    } return o; };
    var w = function (e, t) { if (!Object.setPrototypeOf) {
        return false;
    } return a(function () { var r = function Subclass(t) { var r = new e(t); Object.setPrototypeOf(r, Subclass.prototype); return r; }; Object.setPrototypeOf(r, e); r.prototype = O(e.prototype, { constructor: { value: r } }); return t(r); }); };
    var j = function () { if (typeof self !== "undefined") {
        return self;
    } if (typeof window !== "undefined") {
        return window;
    } if (typeof global !== "undefined") {
        return global;
    } throw new Error("unable to locate global object"); };
    var S = j();
    var T = S.isFinite;
    var I = Function.call.bind(String.prototype.indexOf);
    var E = Function.apply.bind(Array.prototype.indexOf);
    var P = Function.call.bind(Array.prototype.concat);
    var C = Function.call.bind(String.prototype.slice);
    var M = Function.call.bind(Array.prototype.push);
    var x = Function.apply.bind(Array.prototype.push);
    var N = Function.call.bind(Array.prototype.shift);
    var A = Math.max;
    var R = Math.min;
    var _ = Math.floor;
    var k = Math.abs;
    var L = Math.exp;
    var F = Math.log;
    var D = Math.sqrt;
    var z = Function.call.bind(Object.prototype.hasOwnProperty);
    var q;
    var W = function () { };
    var G = S.Map;
    var H = G && G.prototype["delete"];
    var V = G && G.prototype.get;
    var B = G && G.prototype.has;
    var U = G && G.prototype.set;
    var $ = S.Symbol || {};
    var J = $.species || "@@species";
    var X = Number.isNaN || function isNaN(e) { return e !== e; };
    var K = Number.isFinite || function isFinite(e) { return typeof e === "number" && T(e); };
    var Z = d(Math.sign) ? Math.sign : function sign(e) { var t = Number(e); if (t === 0) {
        return t;
    } if (X(t)) {
        return t;
    } return t < 0 ? -1 : 1; };
    var Y = function log1p(e) { var t = Number(e); if (t < -1 || X(t)) {
        return NaN;
    } if (t === 0 || t === Infinity) {
        return t;
    } if (t === -1) {
        return -Infinity;
    } return 1 + t - 1 === 0 ? t : t * (F(1 + t) / (1 + t - 1)); };
    var Q = function isArguments(e) { return g(e) === "[object Arguments]"; };
    var ee = function isArguments(e) { return e !== null && typeof e === "object" && typeof e.length === "number" && e.length >= 0 && g(e) !== "[object Array]" && g(e.callee) === "[object Function]"; };
    var te = Q(arguments) ? Q : ee;
    var re = { primitive: function (e) { return e === null || typeof e !== "function" && typeof e !== "object"; }, string: function (e) { return g(e) === "[object String]"; }, regex: function (e) { return g(e) === "[object RegExp]"; }, symbol: function (e) { return typeof S.Symbol === "function" && typeof e === "symbol"; } };
    var ne = function overrideNative(e, t, r) { var n = e[t]; h(e, t, r, true); m.preserveToString(e[t], n); };
    var oe = typeof $ === "function" && typeof $["for"] === "function" && re.symbol($());
    var ie = re.symbol($.iterator) ? $.iterator : "_es6-shim iterator_";
    if (S.Set && typeof (new S.Set)["@@iterator"] === "function") {
        ie = "@@iterator";
    }
    if (!S.Reflect) {
        h(S, "Reflect", {}, true);
    }
    var ae = S.Reflect;
    var ue = String;
    var fe = typeof document === "undefined" || !document ? null : document.all;
    var se = fe == null ? function isNullOrUndefined(e) { return e == null; } : function isNullOrUndefinedAndNotDocumentAll(e) { return e == null && e !== fe; };
    var ce = { Call: function Call(t, r) { var n = arguments.length > 2 ? arguments[2] : []; if (!ce.IsCallable(t)) {
            throw new TypeError(t + " is not a function");
        } return e(t, r, n); }, RequireObjectCoercible: function (e, t) { if (se(e)) {
            throw new TypeError(t || "Cannot call method on " + e);
        } return e; }, TypeIsObject: function (e) { if (e === void 0 || e === null || e === true || e === false) {
            return false;
        } return typeof e === "function" || typeof e === "object" || e === fe; }, ToObject: function (e, t) { return Object(ce.RequireObjectCoercible(e, t)); }, IsCallable: d, IsConstructor: function (e) { return ce.IsCallable(e); }, ToInt32: function (e) { return ce.ToNumber(e) >> 0; }, ToUint32: function (e) { return ce.ToNumber(e) >>> 0; }, ToNumber: function (e) { if (g(e) === "[object Symbol]") {
            throw new TypeError("Cannot convert a Symbol value to a number");
        } return +e; }, ToInteger: function (e) { var t = ce.ToNumber(e); if (X(t)) {
            return 0;
        } if (t === 0 || !K(t)) {
            return t;
        } return (t > 0 ? 1 : -1) * _(k(t)); }, ToLength: function (e) { var t = ce.ToInteger(e); if (t <= 0) {
            return 0;
        } if (t > Number.MAX_SAFE_INTEGER) {
            return Number.MAX_SAFE_INTEGER;
        } return t; }, SameValue: function (e, t) { if (e === t) {
            if (e === 0) {
                return 1 / e === 1 / t;
            }
            return true;
        } return X(e) && X(t); }, SameValueZero: function (e, t) { return e === t || X(e) && X(t); }, IsIterable: function (e) { return ce.TypeIsObject(e) && (typeof e[ie] !== "undefined" || te(e)); }, GetIterator: function (e) { if (te(e)) {
            return new q(e, "value");
        } var t = ce.GetMethod(e, ie); if (!ce.IsCallable(t)) {
            throw new TypeError("value is not an iterable");
        } var r = ce.Call(t, e); if (!ce.TypeIsObject(r)) {
            throw new TypeError("bad iterator");
        } return r; }, GetMethod: function (e, t) { var r = ce.ToObject(e)[t]; if (se(r)) {
            return void 0;
        } if (!ce.IsCallable(r)) {
            throw new TypeError("Method not callable: " + t);
        } return r; }, IteratorComplete: function (e) { return !!e.done; }, IteratorClose: function (e, t) { var r = ce.GetMethod(e, "return"); if (r === void 0) {
            return;
        } var n, o; try {
            n = ce.Call(r, e);
        }
        catch (i) {
            o = i;
        } if (t) {
            return;
        } if (o) {
            throw o;
        } if (!ce.TypeIsObject(n)) {
            throw new TypeError("Iterator's return method returned a non-object.");
        } }, IteratorNext: function (e) { var t = arguments.length > 1 ? e.next(arguments[1]) : e.next(); if (!ce.TypeIsObject(t)) {
            throw new TypeError("bad iterator");
        } return t; }, IteratorStep: function (e) { var t = ce.IteratorNext(e); var r = ce.IteratorComplete(t); return r ? false : t; }, Construct: function (e, t, r, n) { var o = typeof r === "undefined" ? e : r; if (!n && ae.construct) {
            return ae.construct(e, t, o);
        } var i = o.prototype; if (!ce.TypeIsObject(i)) {
            i = Object.prototype;
        } var a = O(i); var u = ce.Call(e, a, t); return ce.TypeIsObject(u) ? u : a; }, SpeciesConstructor: function (e, t) { var r = e.constructor; if (r === void 0) {
            return t;
        } if (!ce.TypeIsObject(r)) {
            throw new TypeError("Bad constructor");
        } var n = r[J]; if (se(n)) {
            return t;
        } if (!ce.IsConstructor(n)) {
            throw new TypeError("Bad @@species");
        } return n; }, CreateHTML: function (e, t, r, n) { var o = ce.ToString(e); var i = "<" + t; if (r !== "") {
            var a = ce.ToString(n);
            var u = a.replace(/"/g, "&quot;");
            i += " " + r + '="' + u + '"';
        } var f = i + ">"; var s = f + o; return s + "</" + t + ">"; }, IsRegExp: function IsRegExp(e) { if (!ce.TypeIsObject(e)) {
            return false;
        } var t = e[$.match]; if (typeof t !== "undefined") {
            return !!t;
        } return re.regex(e); }, ToString: function ToString(e) { return ue(e); } };
    if (s && oe) {
        var le = function defineWellKnownSymbol(e) { if (re.symbol($[e])) {
            return $[e];
        } var t = $["for"]("Symbol." + e); Object.defineProperty($, e, { configurable: false, enumerable: false, writable: false, value: t }); return t; };
        if (!re.symbol($.search)) {
            var pe = le("search");
            var ve = String.prototype.search;
            h(RegExp.prototype, pe, function search(e) { return ce.Call(ve, e, [this]); });
            var ye = function search(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, pe);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(ve, t, [ce.ToString(e)]); };
            ne(String.prototype, "search", ye);
        }
        if (!re.symbol($.replace)) {
            var he = le("replace");
            var be = String.prototype.replace;
            h(RegExp.prototype, he, function replace(e, t) { return ce.Call(be, e, [this, t]); });
            var ge = function replace(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, he);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(be, r, [ce.ToString(e), t]); };
            ne(String.prototype, "replace", ge);
        }
        if (!re.symbol($.split)) {
            var de = le("split");
            var me = String.prototype.split;
            h(RegExp.prototype, de, function split(e, t) { return ce.Call(me, e, [this, t]); });
            var Oe = function split(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, de);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(me, r, [ce.ToString(e), t]); };
            ne(String.prototype, "split", Oe);
        }
        var we = re.symbol($.match);
        var je = we && function () { var e = {}; e[$.match] = function () { return 42; }; return "a".match(e) !== 42; }();
        if (!we || je) {
            var Se = le("match");
            var Te = String.prototype.match;
            h(RegExp.prototype, Se, function match(e) { return ce.Call(Te, e, [this]); });
            var Ie = function match(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, Se);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(Te, t, [ce.ToString(e)]); };
            ne(String.prototype, "match", Ie);
        }
    }
    var Ee = function wrapConstructor(e, t, r) { m.preserveToString(t, e); if (Object.setPrototypeOf) {
        Object.setPrototypeOf(e, t);
    } if (s) {
        l(Object.getOwnPropertyNames(e), function (n) { if (n in W || r[n]) {
            return;
        } m.proxy(e, n, t); });
    }
    else {
        l(Object.keys(e), function (n) { if (n in W || r[n]) {
            return;
        } t[n] = e[n]; });
    } t.prototype = e.prototype; m.redefine(e.prototype, "constructor", t); };
    var Pe = function () { return this; };
    var Ce = function (e) { if (s && !z(e, J)) {
        m.getter(e, J, Pe);
    } };
    var Me = function (e, t) { var r = t || function iterator() { return this; }; h(e, ie, r); if (!e[ie] && re.symbol(ie)) {
        e[ie] = r;
    } };
    var xe = function createDataProperty(e, t, r) { if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: true, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var Ne = function createDataPropertyOrThrow(e, t, r) { xe(e, t, r); if (!ce.SameValue(e[t], r)) {
        throw new TypeError("property is nonconfigurable");
    } };
    var Ae = function (e, t, r, n) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("Constructor requires `new`: " + t.name);
    } var o = t.prototype; if (!ce.TypeIsObject(o)) {
        o = r;
    } var i = O(o); for (var a in n) {
        if (z(n, a)) {
            var u = n[a];
            h(i, a, u, true);
        }
    } return i; };
    if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
        var Re = String.fromCodePoint;
        ne(String, "fromCodePoint", function fromCodePoint(e) { return ce.Call(Re, this, arguments); });
    }
    var _e = { fromCodePoint: function fromCodePoint(e) { var t = []; var r; for (var n = 0, o = arguments.length; n < o; n++) {
            r = Number(arguments[n]);
            if (!ce.SameValue(r, ce.ToInteger(r)) || r < 0 || r > 1114111) {
                throw new RangeError("Invalid code point " + r);
            }
            if (r < 65536) {
                M(t, String.fromCharCode(r));
            }
            else {
                r -= 65536;
                M(t, String.fromCharCode((r >> 10) + 55296));
                M(t, String.fromCharCode(r % 1024 + 56320));
            }
        } return t.join(""); }, raw: function raw(e) { var t = ce.ToObject(e, "bad callSite"); var r = ce.ToObject(t.raw, "bad raw value"); var n = r.length; var o = ce.ToLength(n); if (o <= 0) {
            return "";
        } var i = []; var a = 0; var u, f, s, c; while (a < o) {
            u = ce.ToString(a);
            s = ce.ToString(r[u]);
            M(i, s);
            if (a + 1 >= o) {
                break;
            }
            f = a + 1 < arguments.length ? arguments[a + 1] : "";
            c = ce.ToString(f);
            M(i, c);
            a += 1;
        } return i.join(""); } };
    if (String.raw && String.raw({ raw: { 0: "x", 1: "y", length: 2 } }) !== "xy") {
        ne(String, "raw", _e.raw);
    }
    b(String, _e);
    var ke = function repeat(e, t) { if (t < 1) {
        return "";
    } if (t % 2) {
        return repeat(e, t - 1) + e;
    } var r = repeat(e, t / 2); return r + r; };
    var Le = Infinity;
    var Fe = { repeat: function repeat(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); if (r < 0 || r >= Le) {
            throw new RangeError("repeat count must be less than infinity and not overflow maximum string size");
        } return ke(t, r); }, startsWith: function startsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "startsWith" with a regex');
        } var r = ce.ToString(e); var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = A(ce.ToInteger(n), 0); return C(t, o, o + r.length) === r; }, endsWith: function endsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "endsWith" with a regex');
        } var r = ce.ToString(e); var n = t.length; var o; if (arguments.length > 1) {
            o = arguments[1];
        } var i = typeof o === "undefined" ? n : ce.ToInteger(o); var a = R(A(i, 0), n); return C(t, a - r.length, a) === r; }, includes: function includes(e) { if (ce.IsRegExp(e)) {
            throw new TypeError('"includes" does not accept a RegExp');
        } var t = ce.ToString(e); var r; if (arguments.length > 1) {
            r = arguments[1];
        } return I(this, t, r) !== -1; }, codePointAt: function codePointAt(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); var n = t.length; if (r >= 0 && r < n) {
            var o = t.charCodeAt(r);
            var i = r + 1 === n;
            if (o < 55296 || o > 56319 || i) {
                return o;
            }
            var a = t.charCodeAt(r + 1);
            if (a < 56320 || a > 57343) {
                return o;
            }
            return (o - 55296) * 1024 + (a - 56320) + 65536;
        } } };
    if (String.prototype.includes && "a".includes("a", Infinity) !== false) {
        ne(String.prototype, "includes", Fe.includes);
    }
    if (String.prototype.startsWith && String.prototype.endsWith) {
        var De = i(function () { return "/a/".startsWith(/a/); });
        var ze = a(function () { return "abc".startsWith("a", Infinity) === false; });
        if (!De || !ze) {
            ne(String.prototype, "startsWith", Fe.startsWith);
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
    }
    if (oe) {
        var qe = a(function () { var e = /a/; e[$.match] = false; return "/a/".startsWith(e); });
        if (!qe) {
            ne(String.prototype, "startsWith", Fe.startsWith);
        }
        var We = a(function () { var e = /a/; e[$.match] = false; return "/a/".endsWith(e); });
        if (!We) {
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
        var Ge = a(function () { var e = /a/; e[$.match] = false; return "/a/".includes(e); });
        if (!Ge) {
            ne(String.prototype, "includes", Fe.includes);
        }
    }
    b(String.prototype, Fe);
    var He = ["\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003", "\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028", "\u2029\ufeff"].join("");
    var Ve = new RegExp("(^[" + He + "]+)|([" + He + "]+$)", "g");
    var Be = function trim() { return ce.ToString(ce.RequireObjectCoercible(this)).replace(Ve, ""); };
    var Ue = ["\x85", "\u200b", "\ufffe"].join("");
    var $e = new RegExp("[" + Ue + "]", "g");
    var Je = /^[-+]0x[0-9a-f]+$/i;
    var Xe = Ue.trim().length !== Ue.length;
    h(String.prototype, "trim", Be, Xe);
    var Ke = function (e) { return { value: e, done: arguments.length === 0 }; };
    var Ze = function (e) { ce.RequireObjectCoercible(e); this._s = ce.ToString(e); this._i = 0; };
    Ze.prototype.next = function () { var e = this._s; var t = this._i; if (typeof e === "undefined" || t >= e.length) {
        this._s = void 0;
        return Ke();
    } var r = e.charCodeAt(t); var n, o; if (r < 55296 || r > 56319 || t + 1 === e.length) {
        o = 1;
    }
    else {
        n = e.charCodeAt(t + 1);
        o = n < 56320 || n > 57343 ? 1 : 2;
    } this._i = t + o; return Ke(e.substr(t, o)); };
    Me(Ze.prototype);
    Me(String.prototype, function () { return new Ze(this); });
    var Ye = { from: function from(e) { var r = this; var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o, i; if (typeof n === "undefined") {
            o = false;
        }
        else {
            if (!ce.IsCallable(n)) {
                throw new TypeError("Array.from: when provided, the second argument must be a function");
            }
            if (arguments.length > 2) {
                i = arguments[2];
            }
            o = true;
        } var a = typeof (te(e) || ce.GetMethod(e, ie)) !== "undefined"; var u, f, s; if (a) {
            f = ce.IsConstructor(r) ? Object(new r) : [];
            var c = ce.GetIterator(e);
            var l, p;
            s = 0;
            while (true) {
                l = ce.IteratorStep(c);
                if (l === false) {
                    break;
                }
                p = l.value;
                try {
                    if (o) {
                        p = typeof i === "undefined" ? n(p, s) : t(n, i, p, s);
                    }
                    f[s] = p;
                }
                catch (v) {
                    ce.IteratorClose(c, true);
                    throw v;
                }
                s += 1;
            }
            u = s;
        }
        else {
            var y = ce.ToObject(e);
            u = ce.ToLength(y.length);
            f = ce.IsConstructor(r) ? Object(new r(u)) : new Array(u);
            var h;
            for (s = 0; s < u; ++s) {
                h = y[s];
                if (o) {
                    h = typeof i === "undefined" ? n(h, s) : t(n, i, h, s);
                }
                Ne(f, s, h);
            }
        } f.length = u; return f; }, of: function of() { var e = arguments.length; var t = this; var n = r(t) || !ce.IsCallable(t) ? new Array(e) : ce.Construct(t, [e]); for (var o = 0; o < e; ++o) {
            Ne(n, o, arguments[o]);
        } n.length = e; return n; } };
    b(Array, Ye);
    Ce(Array);
    q = function (e, t) { this.i = 0; this.array = e; this.kind = t; };
    b(q.prototype, { next: function () { var e = this.i; var t = this.array; if (!(this instanceof q)) {
            throw new TypeError("Not an ArrayIterator");
        } if (typeof t !== "undefined") {
            var r = ce.ToLength(t.length);
            for (; e < r; e++) {
                var n = this.kind;
                var o;
                if (n === "key") {
                    o = e;
                }
                else if (n === "value") {
                    o = t[e];
                }
                else if (n === "entry") {
                    o = [e, t[e]];
                }
                this.i = e + 1;
                return Ke(o);
            }
        } this.array = void 0; return Ke(); } });
    Me(q.prototype);
    var Qe = Array.of === Ye.of || function () { var e = function Foo(e) { this.length = e; }; e.prototype = []; var t = Array.of.apply(e, [1, 2]); return t instanceof e && t.length === 2; }();
    if (!Qe) {
        ne(Array, "of", Ye.of);
    }
    var et = { copyWithin: function copyWithin(e, t) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); var o = ce.ToInteger(e); var i = ce.ToInteger(t); var a = o < 0 ? A(n + o, 0) : R(o, n); var u = i < 0 ? A(n + i, 0) : R(i, n); var f; if (arguments.length > 2) {
            f = arguments[2];
        } var s = typeof f === "undefined" ? n : ce.ToInteger(f); var c = s < 0 ? A(n + s, 0) : R(s, n); var l = R(c - u, n - a); var p = 1; if (u < a && a < u + l) {
            p = -1;
            u += l - 1;
            a += l - 1;
        } while (l > 0) {
            if (u in r) {
                r[a] = r[u];
            }
            else {
                delete r[a];
            }
            u += p;
            a += p;
            l -= 1;
        } return r; }, fill: function fill(e) { var t; if (arguments.length > 1) {
            t = arguments[1];
        } var r; if (arguments.length > 2) {
            r = arguments[2];
        } var n = ce.ToObject(this); var o = ce.ToLength(n.length); t = ce.ToInteger(typeof t === "undefined" ? 0 : t); r = ce.ToInteger(typeof r === "undefined" ? o : r); var i = t < 0 ? A(o + t, 0) : R(t, o); var a = r < 0 ? o + r : r; for (var u = i; u < o && u < a; ++u) {
            n[u] = e;
        } return n; }, find: function find(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#find: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0, a; i < n; i++) {
            a = r[i];
            if (o) {
                if (t(e, o, a, i, r)) {
                    return a;
                }
            }
            else if (e(a, i, r)) {
                return a;
            }
        } }, findIndex: function findIndex(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#findIndex: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0; i < n; i++) {
            if (o) {
                if (t(e, o, r[i], i, r)) {
                    return i;
                }
            }
            else if (e(r[i], i, r)) {
                return i;
            }
        } return -1; }, keys: function keys() { return new q(this, "key"); }, values: function values() { return new q(this, "value"); }, entries: function entries() { return new q(this, "entry"); } };
    if (Array.prototype.keys && !ce.IsCallable([1].keys().next)) {
        delete Array.prototype.keys;
    }
    if (Array.prototype.entries && !ce.IsCallable([1].entries().next)) {
        delete Array.prototype.entries;
    }
    if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[ie]) {
        b(Array.prototype, { values: Array.prototype[ie] });
        if (re.symbol($.unscopables)) {
            Array.prototype[$.unscopables].values = true;
        }
    }
    if (c && Array.prototype.values && Array.prototype.values.name !== "values") {
        var tt = Array.prototype.values;
        ne(Array.prototype, "values", function values() { return ce.Call(tt, this, arguments); });
        h(Array.prototype, ie, Array.prototype.values, true);
    }
    b(Array.prototype, et);
    if (1 / [true].indexOf(true, -0) < 0) {
        h(Array.prototype, "indexOf", function indexOf(e) { var t = E(this, arguments); if (t === 0 && 1 / t < 0) {
            return 0;
        } return t; }, true);
    }
    Me(Array.prototype, function () { return this.values(); });
    if (Object.getPrototypeOf) {
        Me(Object.getPrototypeOf([].values()));
    }
    var rt = function () { return a(function () { return Array.from({ length: -1 }).length === 0; }); }();
    var nt = function () { var e = Array.from([0].entries()); return e.length === 1 && r(e[0]) && e[0][0] === 0 && e[0][1] === 0; }();
    if (!rt || !nt) {
        ne(Array, "from", Ye.from);
    }
    var ot = function () { return a(function () { return Array.from([0], void 0); }); }();
    if (!ot) {
        var it = Array.from;
        ne(Array, "from", function from(e) { if (arguments.length > 1 && typeof arguments[1] !== "undefined") {
            return ce.Call(it, this, arguments);
        }
        else {
            return t(it, this, e);
        } });
    }
    var at = -(Math.pow(2, 32) - 1);
    var ut = function (e, r) { var n = { length: at }; n[r ? (n.length >>> 0) - 1 : 0] = true; return a(function () { t(e, n, function () { throw new RangeError("should not reach here"); }, []); return true; }); };
    if (!ut(Array.prototype.forEach)) {
        var ft = Array.prototype.forEach;
        ne(Array.prototype, "forEach", function forEach(e) { return ce.Call(ft, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.map)) {
        var st = Array.prototype.map;
        ne(Array.prototype, "map", function map(e) { return ce.Call(st, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.filter)) {
        var ct = Array.prototype.filter;
        ne(Array.prototype, "filter", function filter(e) { return ce.Call(ct, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.some)) {
        var lt = Array.prototype.some;
        ne(Array.prototype, "some", function some(e) { return ce.Call(lt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.every)) {
        var pt = Array.prototype.every;
        ne(Array.prototype, "every", function every(e) { return ce.Call(pt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduce)) {
        var vt = Array.prototype.reduce;
        ne(Array.prototype, "reduce", function reduce(e) { return ce.Call(vt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduceRight, true)) {
        var yt = Array.prototype.reduceRight;
        ne(Array.prototype, "reduceRight", function reduceRight(e) { return ce.Call(yt, this.length >= 0 ? this : [], arguments); }, true);
    }
    var ht = Number("0o10") !== 8;
    var bt = Number("0b10") !== 2;
    var gt = y(Ue, function (e) { return Number(e + 0 + e) === 0; });
    if (ht || bt || gt) {
        var dt = Number;
        var mt = /^0b[01]+$/i;
        var Ot = /^0o[0-7]+$/i;
        var wt = mt.test.bind(mt);
        var jt = Ot.test.bind(Ot);
        var St = function (e) { var t; if (typeof e.valueOf === "function") {
            t = e.valueOf();
            if (re.primitive(t)) {
                return t;
            }
        } if (typeof e.toString === "function") {
            t = e.toString();
            if (re.primitive(t)) {
                return t;
            }
        } throw new TypeError("No default value"); };
        var Tt = $e.test.bind($e);
        var It = Je.test.bind(Je);
        var Et = function () { var e = function Number(t) { var r; if (arguments.length > 0) {
            r = re.primitive(t) ? t : St(t, "number");
        }
        else {
            r = 0;
        } if (typeof r === "string") {
            r = ce.Call(Be, r);
            if (wt(r)) {
                r = parseInt(C(r, 2), 2);
            }
            else if (jt(r)) {
                r = parseInt(C(r, 2), 8);
            }
            else if (Tt(r) || It(r)) {
                r = NaN;
            }
        } var n = this; var o = a(function () { dt.prototype.valueOf.call(n); return true; }); if (n instanceof e && !o) {
            return new dt(r);
        } return dt(r); }; return e; }();
        Ee(dt, Et, {});
        b(Et, { NaN: dt.NaN, MAX_VALUE: dt.MAX_VALUE, MIN_VALUE: dt.MIN_VALUE, NEGATIVE_INFINITY: dt.NEGATIVE_INFINITY, POSITIVE_INFINITY: dt.POSITIVE_INFINITY });
        Number = Et;
        m.redefine(S, "Number", Et);
    }
    var Pt = Math.pow(2, 53) - 1;
    b(Number, { MAX_SAFE_INTEGER: Pt, MIN_SAFE_INTEGER: -Pt, EPSILON: 2.220446049250313e-16, parseInt: S.parseInt, parseFloat: S.parseFloat, isFinite: K, isInteger: function isInteger(e) { return K(e) && ce.ToInteger(e) === e; }, isSafeInteger: function isSafeInteger(e) { return Number.isInteger(e) && k(e) <= Number.MAX_SAFE_INTEGER; }, isNaN: X });
    h(Number, "parseInt", S.parseInt, Number.parseInt !== S.parseInt);
    if ([, 1].find(function () { return true; }) === 1) {
        ne(Array.prototype, "find", et.find);
    }
    if ([, 1].findIndex(function () { return true; }) !== 0) {
        ne(Array.prototype, "findIndex", et.findIndex);
    }
    var Ct = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
    var Mt = function ensureEnumerable(e, t) { if (s && Ct(e, t)) {
        Object.defineProperty(e, t, { enumerable: false });
    } };
    var xt = function sliceArgs() { var e = Number(this); var t = arguments.length; var r = t - e; var n = new Array(r < 0 ? 0 : r); for (var o = e; o < t; ++o) {
        n[o - e] = arguments[o];
    } return n; };
    var Nt = function assignTo(e) { return function assignToSource(t, r) { t[r] = e[r]; return t; }; };
    var At = function (e, t) { var r = n(Object(t)); var o; if (ce.IsCallable(Object.getOwnPropertySymbols)) {
        o = v(Object.getOwnPropertySymbols(Object(t)), Ct(t));
    } return p(P(r, o || []), Nt(t), e); };
    var Rt = { assign: function (e, t) { var r = ce.ToObject(e, "Cannot convert undefined or null to object"); return p(ce.Call(xt, 1, arguments), At, r); }, is: function is(e, t) { return ce.SameValue(e, t); } };
    var _t = Object.assign && Object.preventExtensions && function () { var e = Object.preventExtensions({ 1: 2 }); try {
        Object.assign(e, "xy");
    }
    catch (t) {
        return e[1] === "y";
    } }();
    if (_t) {
        ne(Object, "assign", Rt.assign);
    }
    b(Object, Rt);
    if (s) {
        var kt = { setPrototypeOf: function (e, r) { var n; var o = function (e, t) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("cannot set prototype on a non-object");
            } if (!(t === null || ce.TypeIsObject(t))) {
                throw new TypeError("can only set prototype to an object or null" + t);
            } }; var i = function (e, r) { o(e, r); t(n, e, r); return e; }; try {
                n = e.getOwnPropertyDescriptor(e.prototype, r).set;
                t(n, {}, null);
            }
            catch (a) {
                if (e.prototype !== {}[r]) {
                    return;
                }
                n = function (e) { this[r] = e; };
                i.polyfill = i(i({}, null), e.prototype) instanceof e;
            } return i; }(Object, "__proto__") };
        b(Object, kt);
    }
    if (Object.setPrototypeOf && Object.getPrototypeOf && Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null && Object.getPrototypeOf(Object.create(null)) === null) {
        (function () { var e = Object.create(null); var t = Object.getPrototypeOf; var r = Object.setPrototypeOf; Object.getPrototypeOf = function (r) { var n = t(r); return n === e ? null : n; }; Object.setPrototypeOf = function (t, n) { var o = n === null ? e : n; return r(t, o); }; Object.setPrototypeOf.polyfill = false; })();
    }
    var Lt = !i(function () { return Object.keys("foo"); });
    if (!Lt) {
        var Ft = Object.keys;
        ne(Object, "keys", function keys(e) { return Ft(ce.ToObject(e)); });
        n = Object.keys;
    }
    var Dt = i(function () { return Object.keys(/a/g); });
    if (Dt) {
        var zt = Object.keys;
        ne(Object, "keys", function keys(e) { if (re.regex(e)) {
            var t = [];
            for (var r in e) {
                if (z(e, r)) {
                    M(t, r);
                }
            }
            return t;
        } return zt(e); });
        n = Object.keys;
    }
    if (Object.getOwnPropertyNames) {
        var qt = !i(function () { return Object.getOwnPropertyNames("foo"); });
        if (!qt) {
            var Wt = typeof window === "object" ? Object.getOwnPropertyNames(window) : [];
            var Gt = Object.getOwnPropertyNames;
            ne(Object, "getOwnPropertyNames", function getOwnPropertyNames(e) { var t = ce.ToObject(e); if (g(t) === "[object Window]") {
                try {
                    return Gt(t);
                }
                catch (r) {
                    return P([], Wt);
                }
            } return Gt(t); });
        }
    }
    if (Object.getOwnPropertyDescriptor) {
        var Ht = !i(function () { return Object.getOwnPropertyDescriptor("foo", "bar"); });
        if (!Ht) {
            var Vt = Object.getOwnPropertyDescriptor;
            ne(Object, "getOwnPropertyDescriptor", function getOwnPropertyDescriptor(e, t) { return Vt(ce.ToObject(e), t); });
        }
    }
    if (Object.seal) {
        var Bt = !i(function () { return Object.seal("foo"); });
        if (!Bt) {
            var Ut = Object.seal;
            ne(Object, "seal", function seal(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Ut(e); });
        }
    }
    if (Object.isSealed) {
        var $t = !i(function () { return Object.isSealed("foo"); });
        if (!$t) {
            var Jt = Object.isSealed;
            ne(Object, "isSealed", function isSealed(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Jt(e); });
        }
    }
    if (Object.freeze) {
        var Xt = !i(function () { return Object.freeze("foo"); });
        if (!Xt) {
            var Kt = Object.freeze;
            ne(Object, "freeze", function freeze(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Kt(e); });
        }
    }
    if (Object.isFrozen) {
        var Zt = !i(function () { return Object.isFrozen("foo"); });
        if (!Zt) {
            var Yt = Object.isFrozen;
            ne(Object, "isFrozen", function isFrozen(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Yt(e); });
        }
    }
    if (Object.preventExtensions) {
        var Qt = !i(function () { return Object.preventExtensions("foo"); });
        if (!Qt) {
            var er = Object.preventExtensions;
            ne(Object, "preventExtensions", function preventExtensions(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return er(e); });
        }
    }
    if (Object.isExtensible) {
        var tr = !i(function () { return Object.isExtensible("foo"); });
        if (!tr) {
            var rr = Object.isExtensible;
            ne(Object, "isExtensible", function isExtensible(e) { if (!ce.TypeIsObject(e)) {
                return false;
            } return rr(e); });
        }
    }
    if (Object.getPrototypeOf) {
        var nr = !i(function () { return Object.getPrototypeOf("foo"); });
        if (!nr) {
            var or = Object.getPrototypeOf;
            ne(Object, "getPrototypeOf", function getPrototypeOf(e) { return or(ce.ToObject(e)); });
        }
    }
    var ir = s && function () { var e = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags"); return e && ce.IsCallable(e.get); }();
    if (s && !ir) {
        var ar = function flags() { if (!ce.TypeIsObject(this)) {
            throw new TypeError("Method called on incompatible type: must be an object.");
        } var e = ""; if (this.global) {
            e += "g";
        } if (this.ignoreCase) {
            e += "i";
        } if (this.multiline) {
            e += "m";
        } if (this.unicode) {
            e += "u";
        } if (this.sticky) {
            e += "y";
        } return e; };
        m.getter(RegExp.prototype, "flags", ar);
    }
    var ur = s && a(function () { return String(new RegExp(/a/g, "i")) === "/a/i"; });
    var fr = oe && s && function () { var e = /./; e[$.match] = false; return RegExp(e) === e; }();
    var sr = a(function () { return RegExp.prototype.toString.call({ source: "abc" }) === "/abc/"; });
    var cr = sr && a(function () { return RegExp.prototype.toString.call({ source: "a", flags: "b" }) === "/a/b"; });
    if (!sr || !cr) {
        var lr = RegExp.prototype.toString;
        h(RegExp.prototype, "toString", function toString() { var e = ce.RequireObjectCoercible(this); if (re.regex(e)) {
            return t(lr, e);
        } var r = ue(e.source); var n = ue(e.flags); return "/" + r + "/" + n; }, true);
        m.preserveToString(RegExp.prototype.toString, lr);
    }
    if (s && (!ur || fr)) {
        var pr = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags").get;
        var vr = Object.getOwnPropertyDescriptor(RegExp.prototype, "source") || {};
        var yr = function () { return this.source; };
        var hr = ce.IsCallable(vr.get) ? vr.get : yr;
        var br = RegExp;
        var gr = function () { return function RegExp(e, t) { var r = ce.IsRegExp(e); var n = this instanceof RegExp; if (!n && r && typeof t === "undefined" && e.constructor === RegExp) {
            return e;
        } var o = e; var i = t; if (re.regex(e)) {
            o = ce.Call(hr, e);
            i = typeof t === "undefined" ? ce.Call(pr, e) : t;
            return new RegExp(o, i);
        }
        else if (r) {
            o = e.source;
            i = typeof t === "undefined" ? e.flags : t;
        } return new br(e, t); }; }();
        Ee(br, gr, { $input: true });
        RegExp = gr;
        m.redefine(S, "RegExp", gr);
    }
    if (s) {
        var dr = { input: "$_", lastMatch: "$&", lastParen: "$+", leftContext: "$`", rightContext: "$'" };
        l(n(dr), function (e) { if (e in RegExp && !(dr[e] in RegExp)) {
            m.getter(RegExp, dr[e], function get() { return RegExp[e]; });
        } });
    }
    Ce(RegExp);
    var mr = 1 / Number.EPSILON;
    var Or = function roundTiesToEven(e) { return e + mr - mr; };
    var wr = Math.pow(2, -23);
    var jr = Math.pow(2, 127) * (2 - wr);
    var Sr = Math.pow(2, -126);
    var Tr = Math.E;
    var Ir = Math.LOG2E;
    var Er = Math.LOG10E;
    var Pr = Number.prototype.clz;
    delete Number.prototype.clz;
    var Cr = { acosh: function acosh(e) { var t = Number(e); if (X(t) || e < 1) {
            return NaN;
        } if (t === 1) {
            return 0;
        } if (t === Infinity) {
            return t;
        } var r = 1 / (t * t); if (t < 2) {
            return Y(t - 1 + D(1 - r) * t);
        } var n = t / 2; return Y(n + D(1 - r) * n - 1) + 1 / Ir; }, asinh: function asinh(e) { var t = Number(e); if (t === 0 || !T(t)) {
            return t;
        } var r = k(t); var n = r * r; var o = Z(t); if (r < 1) {
            return o * Y(r + n / (D(n + 1) + 1));
        } return o * (Y(r / 2 + D(1 + 1 / n) * r / 2 - 1) + 1 / Ir); }, atanh: function atanh(e) { var t = Number(e); if (t === 0) {
            return t;
        } if (t === -1) {
            return -Infinity;
        } if (t === 1) {
            return Infinity;
        } if (X(t) || t < -1 || t > 1) {
            return NaN;
        } var r = k(t); return Z(t) * Y(2 * r / (1 - r)) / 2; }, cbrt: function cbrt(e) { var t = Number(e); if (t === 0) {
            return t;
        } var r = t < 0; var n; if (r) {
            t = -t;
        } if (t === Infinity) {
            n = Infinity;
        }
        else {
            n = L(F(t) / 3);
            n = (t / (n * n) + 2 * n) / 3;
        } return r ? -n : n; }, clz32: function clz32(e) { var t = Number(e); var r = ce.ToUint32(t); if (r === 0) {
            return 32;
        } return Pr ? ce.Call(Pr, r) : 31 - _(F(r + .5) * Ir); }, cosh: function cosh(e) { var t = Number(e); if (t === 0) {
            return 1;
        } if (X(t)) {
            return NaN;
        } if (!T(t)) {
            return Infinity;
        } var r = L(k(t) - 1); return (r + 1 / (r * Tr * Tr)) * (Tr / 2); }, expm1: function expm1(e) { var t = Number(e); if (t === -Infinity) {
            return -1;
        } if (!T(t) || t === 0) {
            return t;
        } if (k(t) > .5) {
            return L(t) - 1;
        } var r = t; var n = 0; var o = 1; while (n + r !== n) {
            n += r;
            o += 1;
            r *= t / o;
        } return n; }, hypot: function hypot(e, t) { var r = 0; var n = 0; for (var o = 0; o < arguments.length; ++o) {
            var i = k(Number(arguments[o]));
            if (n < i) {
                r *= n / i * (n / i);
                r += 1;
                n = i;
            }
            else {
                r += i > 0 ? i / n * (i / n) : i;
            }
        } return n === Infinity ? Infinity : n * D(r); }, log2: function log2(e) { return F(e) * Ir; }, log10: function log10(e) { return F(e) * Er; }, log1p: Y, sign: Z, sinh: function sinh(e) { var t = Number(e); if (!T(t) || t === 0) {
            return t;
        } var r = k(t); if (r < 1) {
            var n = Math.expm1(r);
            return Z(t) * n * (1 + 1 / (n + 1)) / 2;
        } var o = L(r - 1); return Z(t) * (o - 1 / (o * Tr * Tr)) * (Tr / 2); }, tanh: function tanh(e) { var t = Number(e); if (X(t) || t === 0) {
            return t;
        } if (t >= 20) {
            return 1;
        } if (t <= -20) {
            return -1;
        } return (Math.expm1(t) - Math.expm1(-t)) / (L(t) + L(-t)); }, trunc: function trunc(e) { var t = Number(e); return t < 0 ? -_(-t) : _(t); }, imul: function imul(e, t) { var r = ce.ToUint32(e); var n = ce.ToUint32(t); var o = r >>> 16 & 65535; var i = r & 65535; var a = n >>> 16 & 65535; var u = n & 65535; return i * u + (o * u + i * a << 16 >>> 0) | 0; }, fround: function fround(e) { var t = Number(e); if (t === 0 || t === Infinity || t === -Infinity || X(t)) {
            return t;
        } var r = Z(t); var n = k(t); if (n < Sr) {
            return r * Or(n / Sr / wr) * Sr * wr;
        } var o = (1 + wr / Number.EPSILON) * n; var i = o - (o - n); if (i > jr || X(i)) {
            return r * Infinity;
        } return r * i; } };
    var Mr = function withinULPDistance(e, t, r) { return k(1 - e / t) / Number.EPSILON < (r || 8); };
    b(Math, Cr);
    h(Math, "sinh", Cr.sinh, Math.sinh(710) === Infinity);
    h(Math, "cosh", Cr.cosh, Math.cosh(710) === Infinity);
    h(Math, "log1p", Cr.log1p, Math.log1p(-1e-17) !== -1e-17);
    h(Math, "asinh", Cr.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
    h(Math, "asinh", Cr.asinh, Math.asinh(1e300) === Infinity);
    h(Math, "atanh", Cr.atanh, Math.atanh(1e-300) === 0);
    h(Math, "tanh", Cr.tanh, Math.tanh(-2e-17) !== -2e-17);
    h(Math, "acosh", Cr.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
    h(Math, "acosh", Cr.acosh, !Mr(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
    h(Math, "cbrt", Cr.cbrt, !Mr(Math.cbrt(1e-300), 1e-100));
    h(Math, "sinh", Cr.sinh, Math.sinh(-2e-17) !== -2e-17);
    var xr = Math.expm1(10);
    h(Math, "expm1", Cr.expm1, xr > 22025.465794806718 || xr < 22025.465794806718);
    var Nr = Math.round;
    var Ar = Math.round(.5 - Number.EPSILON / 4) === 0 && Math.round(-.5 + Number.EPSILON / 3.99) === 1;
    var Rr = mr + 1;
    var _r = 2 * mr - 1;
    var kr = [Rr, _r].every(function (e) { return Math.round(e) === e; });
    h(Math, "round", function round(e) { var t = _(e); var r = t === -1 ? -0 : t + 1; return e - t < .5 ? t : r; }, !Ar || !kr);
    m.preserveToString(Math.round, Nr);
    var Lr = Math.imul;
    if (Math.imul(4294967295, 5) !== -5) {
        Math.imul = Cr.imul;
        m.preserveToString(Math.imul, Lr);
    }
    if (Math.imul.length !== 2) {
        ne(Math, "imul", function imul(e, t) { return ce.Call(Lr, Math, arguments); });
    }
    var Fr = function () { var e = S.setTimeout; if (typeof e !== "function" && typeof e !== "object") {
        return;
    } ce.IsPromise = function (e) { if (!ce.TypeIsObject(e)) {
        return false;
    } if (typeof e._promise === "undefined") {
        return false;
    } return true; }; var r = function (e) { if (!ce.IsConstructor(e)) {
        throw new TypeError("Bad promise constructor");
    } var t = this; var r = function (e, r) { if (t.resolve !== void 0 || t.reject !== void 0) {
        throw new TypeError("Bad Promise implementation!");
    } t.resolve = e; t.reject = r; }; t.resolve = void 0; t.reject = void 0; t.promise = new e(r); if (!(ce.IsCallable(t.resolve) && ce.IsCallable(t.reject))) {
        throw new TypeError("Bad promise constructor");
    } }; var n; if (typeof window !== "undefined" && ce.IsCallable(window.postMessage)) {
        n = function () { var e = []; var t = "zero-timeout-message"; var r = function (r) { M(e, r); window.postMessage(t, "*"); }; var n = function (r) { if (r.source === window && r.data === t) {
            r.stopPropagation();
            if (e.length === 0) {
                return;
            }
            var n = N(e);
            n();
        } }; window.addEventListener("message", n, true); return r; };
    } var o = function () { var e = S.Promise; var t = e && e.resolve && e.resolve(); return t && function (e) { return t.then(e); }; }; var i = ce.IsCallable(S.setImmediate) ? S.setImmediate : typeof process === "object" && process.nextTick ? process.nextTick : o() || (ce.IsCallable(n) ? n() : function (t) { e(t, 0); }); var a = function (e) { return e; }; var u = function (e) { throw e; }; var f = 0; var s = 1; var c = 2; var l = 0; var p = 1; var v = 2; var y = {}; var h = function (e, t, r) { i(function () { g(e, t, r); }); }; var g = function (e, t, r) { var n, o; if (t === y) {
        return e(r);
    } try {
        n = e(r);
        o = t.resolve;
    }
    catch (i) {
        n = i;
        o = t.reject;
    } o(n); }; var d = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.fulfillReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + l], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = s; r.reactionLength = 0; }; var m = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.rejectReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + p], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = c; r.reactionLength = 0; }; var O = function (e) { var t = false; var r = function (r) { var n; if (t) {
        return;
    } t = true; if (r === e) {
        return m(e, new TypeError("Self resolution"));
    } if (!ce.TypeIsObject(r)) {
        return d(e, r);
    } try {
        n = r.then;
    }
    catch (o) {
        return m(e, o);
    } if (!ce.IsCallable(n)) {
        return d(e, r);
    } i(function () { j(e, r, n); }); }; var n = function (r) { if (t) {
        return;
    } t = true; return m(e, r); }; return { resolve: r, reject: n }; }; var w = function (e, r, n, o) { if (e === I) {
        t(e, r, n, o, y);
    }
    else {
        t(e, r, n, o);
    } }; var j = function (e, t, r) { var n = O(e); var o = n.resolve; var i = n.reject; try {
        w(r, t, o, i);
    }
    catch (a) {
        i(a);
    } }; var T, I; var E = function () { var e = function Promise(t) { if (!(this instanceof e)) {
        throw new TypeError('Constructor Promise requires "new"');
    } if (this && this._promise) {
        throw new TypeError("Bad construction");
    } if (!ce.IsCallable(t)) {
        throw new TypeError("not a valid resolver");
    } var r = Ae(this, e, T, { _promise: { result: void 0, state: f, reactionLength: 0, fulfillReactionHandler0: void 0, rejectReactionHandler0: void 0, reactionCapability0: void 0 } }); var n = O(r); var o = n.reject; try {
        t(n.resolve, o);
    }
    catch (i) {
        o(i);
    } return r; }; return e; }(); T = E.prototype; var P = function (e, t, r, n) { var o = false; return function (i) { if (o) {
        return;
    } o = true; t[e] = i; if (--n.count === 0) {
        var a = r.resolve;
        a(t);
    } }; }; var C = function (e, t, r) { var n = e.iterator; var o = []; var i = { count: 1 }; var a, u; var f = 0; while (true) {
        try {
            a = ce.IteratorStep(n);
            if (a === false) {
                e.done = true;
                break;
            }
            u = a.value;
        }
        catch (s) {
            e.done = true;
            throw s;
        }
        o[f] = void 0;
        var c = t.resolve(u);
        var l = P(f, o, r, i);
        i.count += 1;
        w(c.then, c, l, r.reject);
        f += 1;
    } if (--i.count === 0) {
        var p = r.resolve;
        p(o);
    } return r.promise; }; var x = function (e, t, r) { var n = e.iterator; var o, i, a; while (true) {
        try {
            o = ce.IteratorStep(n);
            if (o === false) {
                e.done = true;
                break;
            }
            i = o.value;
        }
        catch (u) {
            e.done = true;
            throw u;
        }
        a = t.resolve(i);
        w(a.then, a, r.resolve, r.reject);
    } return r.promise; }; b(E, { all: function all(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return C(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, race: function race(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return x(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, reject: function reject(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } var n = new r(t); var o = n.reject; o(e); return n.promise; }, resolve: function resolve(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } if (ce.IsPromise(e)) {
            var n = e.constructor;
            if (n === t) {
                return e;
            }
        } var o = new r(t); var i = o.resolve; i(e); return o.promise; } }); b(T, { "catch": function (e) { return this.then(null, e); }, then: function then(e, t) { var n = this; if (!ce.IsPromise(n)) {
            throw new TypeError("not a promise");
        } var o = ce.SpeciesConstructor(n, E); var i; var b = arguments.length > 2 && arguments[2] === y; if (b && o === E) {
            i = y;
        }
        else {
            i = new r(o);
        } var g = ce.IsCallable(e) ? e : a; var d = ce.IsCallable(t) ? t : u; var m = n._promise; var O; if (m.state === f) {
            if (m.reactionLength === 0) {
                m.fulfillReactionHandler0 = g;
                m.rejectReactionHandler0 = d;
                m.reactionCapability0 = i;
            }
            else {
                var w = 3 * (m.reactionLength - 1);
                m[w + l] = g;
                m[w + p] = d;
                m[w + v] = i;
            }
            m.reactionLength += 1;
        }
        else if (m.state === s) {
            O = m.result;
            h(g, i, O);
        }
        else if (m.state === c) {
            O = m.result;
            h(d, i, O);
        }
        else {
            throw new TypeError("unexpected Promise state");
        } return i.promise; } }); y = new r(E); I = T.then; return E; }();
    if (S.Promise) {
        delete S.Promise.accept;
        delete S.Promise.defer;
        delete S.Promise.prototype.chain;
    }
    if (typeof Fr === "function") {
        b(S, { Promise: Fr });
        var Dr = w(S.Promise, function (e) { return e.resolve(42).then(function () { }) instanceof e; });
        var zr = !i(function () { return S.Promise.reject(42).then(null, 5).then(null, W); });
        var qr = i(function () { return S.Promise.call(3, W); });
        var Wr = function (e) { var t = e.resolve(5); t.constructor = {}; var r = e.resolve(t); try {
            r.then(null, W).then(null, W);
        }
        catch (n) {
            return true;
        } return t === r; }(S.Promise);
        var Gr = s && function () { var e = 0; var t = Object.defineProperty({}, "then", { get: function () { e += 1; } }); Promise.resolve(t); return e === 1; }();
        var Hr = function BadResolverPromise(e) { var t = new Promise(e); e(3, function () { }); this.then = t.then; this.constructor = BadResolverPromise_1; };
        Hr.prototype = Promise.prototype;
        Hr.all = Promise.all;
        var Vr = a(function () { return !!Hr.all([1, 2]); });
        if (!Dr || !zr || !qr || Wr || !Gr || Vr) {
            Promise = Fr;
            ne(S, "Promise", Fr);
        }
        if (Promise.all.length !== 1) {
            var Br = Promise.all;
            ne(Promise, "all", function all(e) { return ce.Call(Br, this, arguments); });
        }
        if (Promise.race.length !== 1) {
            var Ur = Promise.race;
            ne(Promise, "race", function race(e) { return ce.Call(Ur, this, arguments); });
        }
        if (Promise.resolve.length !== 1) {
            var $r = Promise.resolve;
            ne(Promise, "resolve", function resolve(e) { return ce.Call($r, this, arguments); });
        }
        if (Promise.reject.length !== 1) {
            var Jr = Promise.reject;
            ne(Promise, "reject", function reject(e) { return ce.Call(Jr, this, arguments); });
        }
        Mt(Promise, "all");
        Mt(Promise, "race");
        Mt(Promise, "resolve");
        Mt(Promise, "reject");
        Ce(Promise);
    }
    var Xr = function (e) { var t = n(p(e, function (e, t) { e[t] = true; return e; }, {})); return e.join(":") === t.join(":"); };
    var Kr = Xr(["z", "a", "bb"]);
    var Zr = Xr(["z", 1, "a", "3", 2]);
    if (s) {
        var Yr = function fastkey(e, t) { if (!t && !Kr) {
            return null;
        } if (se(e)) {
            return "^" + ce.ToString(e);
        }
        else if (typeof e === "string") {
            return "$" + e;
        }
        else if (typeof e === "number") {
            if (!Zr) {
                return "n" + e;
            }
            return e;
        }
        else if (typeof e === "boolean") {
            return "b" + e;
        } return null; };
        var Qr = function emptyObject() { return Object.create ? Object.create(null) : {}; };
        var en = function addIterableToMap(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("Iterator value " + e + " is not an entry object");
            } n.set(e[0], e[1]); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e, t) { n.set(t, e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.set;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad map");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        if (!ce.TypeIsObject(f)) {
                            throw new TypeError("Iterator value " + f + " is not an entry object");
                        }
                        t(a, n, f[0], f[1]);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var tn = function addIterableToSet(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { n.add(e); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e) { n.add(e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.add;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad set");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        t(a, n, f);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var rn = { Map: function () { var e = {}; var r = function MapEntry(e, t) { this.key = e; this.value = t; this.next = null; this.prev = null; }; r.prototype.isRemoved = function isRemoved() { return this.key === e; }; var n = function isMap(e) { return !!e._es6map; }; var o = function requireMapSlot(e, t) { if (!ce.TypeIsObject(e) || !n(e)) {
                throw new TypeError("Method Map.prototype." + t + " called on incompatible receiver " + ce.ToString(e));
            } }; var i = function MapIterator(e, t) { o(e, "[[MapIterator]]"); this.head = e._head; this.i = this.head; this.kind = t; }; i.prototype = { isMapIterator: true, next: function next() { if (!this.isMapIterator) {
                    throw new TypeError("Not a MapIterator");
                } var e = this.i; var t = this.kind; var r = this.head; if (typeof this.i === "undefined") {
                    return Ke();
                } while (e.isRemoved() && e !== r) {
                    e = e.prev;
                } var n; while (e.next !== r) {
                    e = e.next;
                    if (!e.isRemoved()) {
                        if (t === "key") {
                            n = e.key;
                        }
                        else if (t === "value") {
                            n = e.value;
                        }
                        else {
                            n = [e.key, e.value];
                        }
                        this.i = e;
                        return Ke(n);
                    }
                } this.i = void 0; return Ke(); } }; Me(i.prototype); var a; var u = function Map() { if (!(this instanceof Map)) {
                throw new TypeError('Constructor Map requires "new"');
            } if (this && this._es6map) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Map, a, { _es6map: true, _head: null, _map: G ? new G : null, _size: 0, _storage: Qr() }); var t = new r(null, null); t.next = t.prev = t; e._head = t; if (arguments.length > 0) {
                en(Map, e, arguments[0]);
            } return e; }; a = u.prototype; m.getter(a, "size", function () { if (typeof this._size === "undefined") {
                throw new TypeError("size method called on incompatible Map");
            } return this._size; }); b(a, { get: function get(e) { o(this, "get"); var t; var r = Yr(e, true); if (r !== null) {
                    t = this._storage[r];
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } if (this._map) {
                    t = V.call(this._map, e);
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } var n = this._head; var i = n; while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        return i.value;
                    }
                } }, has: function has(e) { o(this, "has"); var t = Yr(e, true); if (t !== null) {
                    return typeof this._storage[t] !== "undefined";
                } if (this._map) {
                    return B.call(this._map, e);
                } var r = this._head; var n = r; while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, e)) {
                        return true;
                    }
                } return false; }, set: function set(e, t) { o(this, "set"); var n = this._head; var i = n; var a; var u = Yr(e, true); if (u !== null) {
                    if (typeof this._storage[u] !== "undefined") {
                        this._storage[u].value = t;
                        return this;
                    }
                    else {
                        a = this._storage[u] = new r(e, t);
                        i = n.prev;
                    }
                }
                else if (this._map) {
                    if (B.call(this._map, e)) {
                        V.call(this._map, e).value = t;
                    }
                    else {
                        a = new r(e, t);
                        U.call(this._map, e, a);
                        i = n.prev;
                    }
                } while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        i.value = t;
                        return this;
                    }
                } a = a || new r(e, t); if (ce.SameValue(-0, e)) {
                    a.key = +0;
                } a.next = this._head; a.prev = this._head.prev; a.prev.next = a; a.next.prev = a; this._size += 1; return this; }, "delete": function (t) { o(this, "delete"); var r = this._head; var n = r; var i = Yr(t, true); if (i !== null) {
                    if (typeof this._storage[i] === "undefined") {
                        return false;
                    }
                    n = this._storage[i].prev;
                    delete this._storage[i];
                }
                else if (this._map) {
                    if (!B.call(this._map, t)) {
                        return false;
                    }
                    n = V.call(this._map, t).prev;
                    H.call(this._map, t);
                } while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, t)) {
                        n.key = e;
                        n.value = e;
                        n.prev.next = n.next;
                        n.next.prev = n.prev;
                        this._size -= 1;
                        return true;
                    }
                } return false; }, clear: function clear() { o(this, "clear"); this._map = G ? new G : null; this._size = 0; this._storage = Qr(); var t = this._head; var r = t; var n = r.next; while ((r = n) !== t) {
                    r.key = e;
                    r.value = e;
                    n = r.next;
                    r.next = r.prev = t;
                } t.next = t.prev = t; }, keys: function keys() { o(this, "keys"); return new i(this, "key"); }, values: function values() { o(this, "values"); return new i(this, "value"); }, entries: function entries() { o(this, "entries"); return new i(this, "key+value"); }, forEach: function forEach(e) { o(this, "forEach"); var r = arguments.length > 1 ? arguments[1] : null; var n = this.entries(); for (var i = n.next(); !i.done; i = n.next()) {
                    if (r) {
                        t(e, r, i.value[1], i.value[0], this);
                    }
                    else {
                        e(i.value[1], i.value[0], this);
                    }
                } } }); Me(a, a.entries); return u; }(), Set: function () { var e = function isSet(e) { return e._es6set && typeof e._storage !== "undefined"; }; var r = function requireSetSlot(t, r) { if (!ce.TypeIsObject(t) || !e(t)) {
                throw new TypeError("Set.prototype." + r + " called on incompatible receiver " + ce.ToString(t));
            } }; var o; var i = function Set() { if (!(this instanceof Set)) {
                throw new TypeError('Constructor Set requires "new"');
            } if (this && this._es6set) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Set, o, { _es6set: true, "[[SetData]]": null, _storage: Qr() }); if (!e._es6set) {
                throw new TypeError("bad set");
            } if (arguments.length > 0) {
                tn(Set, e, arguments[0]);
            } return e; }; o = i.prototype; var a = function (e) { var t = e; if (t === "^null") {
                return null;
            }
            else if (t === "^undefined") {
                return void 0;
            }
            else {
                var r = t.charAt(0);
                if (r === "$") {
                    return C(t, 1);
                }
                else if (r === "n") {
                    return +C(t, 1);
                }
                else if (r === "b") {
                    return t === "btrue";
                }
            } return +t; }; var u = function ensureMap(e) { if (!e["[[SetData]]"]) {
                var t = new rn.Map;
                e["[[SetData]]"] = t;
                l(n(e._storage), function (e) { var r = a(e); t.set(r, r); });
                e["[[SetData]]"] = t;
            } e._storage = null; }; m.getter(i.prototype, "size", function () { r(this, "size"); if (this._storage) {
                return n(this._storage).length;
            } u(this); return this["[[SetData]]"].size; }); b(i.prototype, { has: function has(e) { r(this, "has"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    return !!this._storage[t];
                } u(this); return this["[[SetData]]"].has(e); }, add: function add(e) { r(this, "add"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    this._storage[t] = true;
                    return this;
                } u(this); this["[[SetData]]"].set(e, e); return this; }, "delete": function (e) { r(this, "delete"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    var n = z(this._storage, t);
                    return delete this._storage[t] && n;
                } u(this); return this["[[SetData]]"]["delete"](e); }, clear: function clear() { r(this, "clear"); if (this._storage) {
                    this._storage = Qr();
                } if (this["[[SetData]]"]) {
                    this["[[SetData]]"].clear();
                } }, values: function values() { r(this, "values"); u(this); return new f(this["[[SetData]]"].values()); }, entries: function entries() { r(this, "entries"); u(this); return new f(this["[[SetData]]"].entries()); }, forEach: function forEach(e) { r(this, "forEach"); var n = arguments.length > 1 ? arguments[1] : null; var o = this; u(o); this["[[SetData]]"].forEach(function (r, i) { if (n) {
                    t(e, n, i, i, o);
                }
                else {
                    e(i, i, o);
                } }); } }); h(i.prototype, "keys", i.prototype.values, true); Me(i.prototype, i.prototype.values); var f = function SetIterator(e) { this.it = e; }; f.prototype = { isSetIterator: true, next: function next() { if (!this.isSetIterator) {
                    throw new TypeError("Not a SetIterator");
                } return this.it.next(); } }; Me(f.prototype); return i; }() };
        var nn = S.Set && !Set.prototype["delete"] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray((new Set).keys);
        if (nn) {
            S.Set = rn.Set;
        }
        if (S.Map || S.Set) {
            var on = a(function () { return new Map([[1, 2]]).get(1) === 2; });
            if (!on) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, S.Map.prototype); return e; };
                S.Map.prototype = O(G.prototype);
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var an = new Map;
            var un = function () { var e = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]); e.set(-0, e); return e.get(0) === e && e.get(-0) === e && e.has(0) && e.has(-0); }();
            var fn = an.set(1, 2) === an;
            if (!un || !fn) {
                ne(Map.prototype, "set", function set(e, r) { t(U, this, e === 0 ? 0 : e, r); return this; });
            }
            if (!un) {
                b(Map.prototype, { get: function get(e) { return t(V, this, e === 0 ? 0 : e); }, has: function has(e) { return t(B, this, e === 0 ? 0 : e); } }, true);
                m.preserveToString(Map.prototype.get, V);
                m.preserveToString(Map.prototype.has, B);
            }
            var sn = new Set;
            var cn = Set.prototype["delete"] && Set.prototype.add && Set.prototype.has && function (e) { e["delete"](0); e.add(-0); return !e.has(0); }(sn);
            var ln = sn.add(1) === sn;
            if (!cn || !ln) {
                var pn = Set.prototype.add;
                Set.prototype.add = function add(e) { t(pn, this, e === 0 ? 0 : e); return this; };
                m.preserveToString(Set.prototype.add, pn);
            }
            if (!cn) {
                var vn = Set.prototype.has;
                Set.prototype.has = function has(e) { return t(vn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype.has, vn);
                var yn = Set.prototype["delete"];
                Set.prototype["delete"] = function SetDelete(e) { return t(yn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype["delete"], yn);
            }
            var hn = w(S.Map, function (e) { var t = new e([]); t.set(42, 42); return t instanceof e; });
            var bn = Object.setPrototypeOf && !hn;
            var gn = function () { try {
                return !(S.Map() instanceof S.Map);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Map.length !== 0 || bn || !gn) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Map.prototype); return e; };
                S.Map.prototype = G.prototype;
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var dn = w(S.Set, function (e) { var t = new e([]); t.add(42, 42); return t instanceof e; });
            var mn = Object.setPrototypeOf && !dn;
            var On = function () { try {
                return !(S.Set() instanceof S.Set);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Set.length !== 0 || mn || !On) {
                var wn = S.Set;
                S.Set = function Set() { if (!(this instanceof Set)) {
                    throw new TypeError('Constructor Set requires "new"');
                } var e = new wn; if (arguments.length > 0) {
                    tn(Set, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Set.prototype); return e; };
                S.Set.prototype = wn.prototype;
                h(S.Set.prototype, "constructor", S.Set, true);
                m.preserveToString(S.Set, wn);
            }
            var jn = new S.Map;
            var Sn = !a(function () { return jn.keys().next().done; });
            if (typeof S.Map.prototype.clear !== "function" || (new S.Set).size !== 0 || jn.size !== 0 || typeof S.Map.prototype.keys !== "function" || typeof S.Set.prototype.keys !== "function" || typeof S.Map.prototype.forEach !== "function" || typeof S.Set.prototype.forEach !== "function" || u(S.Map) || u(S.Set) || typeof jn.keys().next !== "function" || Sn || !hn) {
                b(S, { Map: rn.Map, Set: rn.Set }, true);
            }
            if (S.Set.prototype.keys !== S.Set.prototype.values) {
                h(S.Set.prototype, "keys", S.Set.prototype.values, true);
            }
            Me(Object.getPrototypeOf((new S.Map).keys()));
            Me(Object.getPrototypeOf((new S.Set).keys()));
            if (c && S.Set.prototype.has.name !== "has") {
                var Tn = S.Set.prototype.has;
                ne(S.Set.prototype, "has", function has(e) { return t(Tn, this, e); });
            }
        }
        b(S, rn);
        Ce(S.Map);
        Ce(S.Set);
    }
    var In = function throwUnlessTargetIsObject(e) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("target must be an object");
    } };
    var En = { apply: function apply() { return ce.Call(ce.Call, null, arguments); }, construct: function construct(e, t) { if (!ce.IsConstructor(e)) {
            throw new TypeError("First argument must be a constructor.");
        } var r = arguments.length > 2 ? arguments[2] : e; if (!ce.IsConstructor(r)) {
            throw new TypeError("new.target must be a constructor.");
        } return ce.Construct(e, t, r, "internal"); }, deleteProperty: function deleteProperty(e, t) { In(e); if (s) {
            var r = Object.getOwnPropertyDescriptor(e, t);
            if (r && !r.configurable) {
                return false;
            }
        } return delete e[t]; }, has: function has(e, t) { In(e); return t in e; } };
    if (Object.getOwnPropertyNames) {
        Object.assign(En, { ownKeys: function ownKeys(e) { In(e); var t = Object.getOwnPropertyNames(e); if (ce.IsCallable(Object.getOwnPropertySymbols)) {
                x(t, Object.getOwnPropertySymbols(e));
            } return t; } });
    }
    var Pn = function ConvertExceptionToBoolean(e) { return !i(e); };
    if (Object.preventExtensions) {
        Object.assign(En, { isExtensible: function isExtensible(e) { In(e); return Object.isExtensible(e); }, preventExtensions: function preventExtensions(e) { In(e); return Pn(function () { return Object.preventExtensions(e); }); } });
    }
    if (s) {
        var Cn = function get(e, t, r) { var n = Object.getOwnPropertyDescriptor(e, t); if (!n) {
            var o = Object.getPrototypeOf(e);
            if (o === null) {
                return void 0;
            }
            return Cn(o, t, r);
        } if ("value" in n) {
            return n.value;
        } if (n.get) {
            return ce.Call(n.get, r);
        } return void 0; };
        var Mn = function set(e, r, n, o) { var i = Object.getOwnPropertyDescriptor(e, r); if (!i) {
            var a = Object.getPrototypeOf(e);
            if (a !== null) {
                return Mn(a, r, n, o);
            }
            i = { value: void 0, writable: true, enumerable: true, configurable: true };
        } if ("value" in i) {
            if (!i.writable) {
                return false;
            }
            if (!ce.TypeIsObject(o)) {
                return false;
            }
            var u = Object.getOwnPropertyDescriptor(o, r);
            if (u) {
                return ae.defineProperty(o, r, { value: n });
            }
            else {
                return ae.defineProperty(o, r, { value: n, writable: true, enumerable: true, configurable: true });
            }
        } if (i.set) {
            t(i.set, o, n);
            return true;
        } return false; };
        Object.assign(En, { defineProperty: function defineProperty(e, t, r) { In(e); return Pn(function () { return Object.defineProperty(e, t, r); }); }, getOwnPropertyDescriptor: function getOwnPropertyDescriptor(e, t) { In(e); return Object.getOwnPropertyDescriptor(e, t); }, get: function get(e, t) { In(e); var r = arguments.length > 2 ? arguments[2] : e; return Cn(e, t, r); }, set: function set(e, t, r) { In(e); var n = arguments.length > 3 ? arguments[3] : e; return Mn(e, t, r, n); } });
    }
    if (Object.getPrototypeOf) {
        var xn = Object.getPrototypeOf;
        En.getPrototypeOf = function getPrototypeOf(e) { In(e); return xn(e); };
    }
    if (Object.setPrototypeOf && En.getPrototypeOf) {
        var Nn = function (e, t) { var r = t; while (r) {
            if (e === r) {
                return true;
            }
            r = En.getPrototypeOf(r);
        } return false; };
        Object.assign(En, { setPrototypeOf: function setPrototypeOf(e, t) { In(e); if (t !== null && !ce.TypeIsObject(t)) {
                throw new TypeError("proto must be an object or null");
            } if (t === ae.getPrototypeOf(e)) {
                return true;
            } if (ae.isExtensible && !ae.isExtensible(e)) {
                return false;
            } if (Nn(e, t)) {
                return false;
            } Object.setPrototypeOf(e, t); return true; } });
    }
    var An = function (e, t) { if (!ce.IsCallable(S.Reflect[e])) {
        h(S.Reflect, e, t);
    }
    else {
        var r = a(function () { S.Reflect[e](1); S.Reflect[e](NaN); S.Reflect[e](true); return true; });
        if (r) {
            ne(S.Reflect, e, t);
        }
    } };
    Object.keys(En).forEach(function (e) { An(e, En[e]); });
    var Rn = S.Reflect.getPrototypeOf;
    if (c && Rn && Rn.name !== "getPrototypeOf") {
        ne(S.Reflect, "getPrototypeOf", function getPrototypeOf(e) { return t(Rn, S.Reflect, e); });
    }
    if (S.Reflect.setPrototypeOf) {
        if (a(function () { S.Reflect.setPrototypeOf(1, {}); return true; })) {
            ne(S.Reflect, "setPrototypeOf", En.setPrototypeOf);
        }
    }
    if (S.Reflect.defineProperty) {
        if (!a(function () { var e = !S.Reflect.defineProperty(1, "test", { value: 1 }); var t = typeof Object.preventExtensions !== "function" || !S.Reflect.defineProperty(Object.preventExtensions({}), "test", {}); return e && t; })) {
            ne(S.Reflect, "defineProperty", En.defineProperty);
        }
    }
    if (S.Reflect.construct) {
        if (!a(function () { var e = function F() { }; return S.Reflect.construct(function () { }, [], e) instanceof e; })) {
            ne(S.Reflect, "construct", En.construct);
        }
    }
    if (String(new Date(NaN)) !== "Invalid Date") {
        var _n = Date.prototype.toString;
        var kn = function toString() { var e = +this; if (e !== e) {
            return "Invalid Date";
        } return ce.Call(_n, this); };
        ne(Date.prototype, "toString", kn);
    }
    var Ln = { anchor: function anchor(e) { return ce.CreateHTML(this, "a", "name", e); }, big: function big() { return ce.CreateHTML(this, "big", "", ""); }, blink: function blink() { return ce.CreateHTML(this, "blink", "", ""); }, bold: function bold() { return ce.CreateHTML(this, "b", "", ""); }, fixed: function fixed() { return ce.CreateHTML(this, "tt", "", ""); }, fontcolor: function fontcolor(e) { return ce.CreateHTML(this, "font", "color", e); }, fontsize: function fontsize(e) { return ce.CreateHTML(this, "font", "size", e); }, italics: function italics() { return ce.CreateHTML(this, "i", "", ""); }, link: function link(e) { return ce.CreateHTML(this, "a", "href", e); }, small: function small() { return ce.CreateHTML(this, "small", "", ""); }, strike: function strike() { return ce.CreateHTML(this, "strike", "", ""); }, sub: function sub() { return ce.CreateHTML(this, "sub", "", ""); }, sup: function sub() { return ce.CreateHTML(this, "sup", "", ""); } };
    l(Object.keys(Ln), function (e) { var r = String.prototype[e]; var n = false; if (ce.IsCallable(r)) {
        var o = t(r, "", ' " ');
        var i = P([], o.match(/"/g)).length;
        n = o !== o.toLowerCase() || i > 2;
    }
    else {
        n = true;
    } if (n) {
        ne(String.prototype, e, Ln[e]);
    } });
    var Fn = function () { if (!oe) {
        return false;
    } var e = typeof JSON === "object" && typeof JSON.stringify === "function" ? JSON.stringify : null; if (!e) {
        return false;
    } if (typeof e($()) !== "undefined") {
        return true;
    } if (e([$()]) !== "[null]") {
        return true;
    } var t = { a: $() }; t[$()] = true; if (e(t) !== "{}") {
        return true;
    } return false; }();
    var Dn = a(function () { if (!oe) {
        return true;
    } return JSON.stringify(Object($())) === "{}" && JSON.stringify([Object($())]) === "[{}]"; });
    if (Fn || !Dn) {
        var zn = JSON.stringify;
        ne(JSON, "stringify", function stringify(e) { if (typeof e === "symbol") {
            return;
        } var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = [e]; if (!r(n)) {
            var i = ce.IsCallable(n) ? n : null;
            var a = function (e, r) { var n = i ? t(i, this, e, r) : r; if (typeof n !== "symbol") {
                if (re.symbol(n)) {
                    return Nt({})(n);
                }
                else {
                    return n;
                }
            } };
            o.push(a);
        }
        else {
            o.push(n);
        } if (arguments.length > 2) {
            o.push(arguments[2]);
        } return zn.apply(this, o); });
    }
    return S;
});
//# sourceMappingURL=es6-shim.map
/// <reference path="node_modules/es6-shim/es6-shim.min.js" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                /**
                 * Associate tokens with promises.
                 *
                 * First, .make() a promise -- associate a token with resolve/reject callbacks.
                 *
                 * You can either .keep() a promise -- resolve() and forget it;
                 * Or you may also .break() a promise -- reject() and forget it.
                 *
                 * <T> is the type of resolved value (value yielded successfully by promise).
                 */
                var PromiseStore = /** @class */ (function () {
                    function PromiseStore() {
                        this._promises = new Map();
                    }
                    Object.defineProperty(PromiseStore.prototype, "length", {
                        /**
                         * How many promises are currently being tracked?
                         */
                        get: function () {
                            return this._promises.size;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Associate a token with its respective resolve and reject callbacks.
                     */
                    PromiseStore.prototype.make = function (token, resolve, reject) {
                        if (this._promises.has(token)) {
                            return reject("Existing request with token " + token);
                        }
                        this._promises.set(token, { reject: reject, resolve: resolve });
                    };
                    /**
                     * Resolve the promise associated with a token (with a value!).
                     * Once the promise is resolved, the token is removed..
                     */
                    PromiseStore.prototype.keep = function (token, value) {
                        var callbacks = this._promises.get(token);
                        if (!callbacks) {
                            throw new Error("No promise associated with token: " + token);
                        }
                        var accept = callbacks.resolve;
                        this._promises.delete(token);
                        return accept(value);
                    };
                    /**
                     * Instantly reject and forget a promise associated with the token.
                     */
                    PromiseStore.prototype.break = function (token, reason) {
                        var callbacks = this._promises.get(token);
                        if (!callbacks) {
                            throw new Error("No promise associated with token: " + token);
                        }
                        this._promises.delete(token);
                        callbacks.reject(reason);
                    };
                    return PromiseStore;
                }());
                prediction.PromiseStore = PromiseStore;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/*
 * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
 * Copyright (c) 2018 SIL International
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/// <reference path="node_modules/es6-shim/es6-shim.min.js" />
/// <reference path="promise-store.ts" />
/**
 * Top-level interface to the Language Modelling layer, or "LMLayer" for short.
 *
 * The Language Modelling layer provides a way for keyboards to offer prediction and
 * correction functionalities. The LMLayer proper runs within a Web Worker, however,
 * this class is intended to run in the main thread, and automatically spawn a Web
 * Worker, capable of offering predictions.
 *
 * Since the Worker runs in a different thread, the public methods of this class are
 * asynchronous. Methods of note include:
 *
 *  - #loadModel() -- loads a specified model file
 *  - #predict() -- ask the LMLayer to offer suggestions (predictions or corrections) for
 *                  the input event
 *  - #unloadModel() -- unloads the LMLayer's currently loaded model, preparing it to
 *                          receive (load) a new model
 *
 * The top-level LMLayer will automatically starts up its own Web Worker.
 */
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                var LMLayer = /** @class */ (function () {
                    /**
                     * Construct the top-level LMLayer interface. This also starts the underlying Worker.
                     *
                     * @param uri URI of the underlying LMLayer worker code. This will usually be a blob:
                     *            or file: URI. If uri is not provided, this will start the default Worker.
                     */
                    function LMLayer(capabilities, worker) {
                        // Either use the given worker, or instantiate the default worker.
                        this._worker = worker || prediction.DefaultWorker.constructInstance();
                        this._worker.onmessage = this.onMessage.bind(this);
                        this._declareLMLayerReady = null;
                        this._predictPromises = new prediction.PromiseStore;
                        this._wordbreakPromises = new prediction.PromiseStore();
                        this._nextToken = Number.MIN_SAFE_INTEGER;
                        this.sendConfig(capabilities);
                    }
                    /**
                     * Initializes the LMLayer worker with the host platform's capability set.
                     *
                     * @param capabilities The host platform's capability spec - a model cannot assume access to more context
                     *                     than specified by this parameter.
                     */
                    LMLayer.prototype.sendConfig = function (capabilities) {
                        this._worker.postMessage({
                            message: 'config',
                            capabilities: capabilities
                        });
                    };
                    /**
                     * Initializes the LMLayer worker with a path to the desired model file.
                     */
                    LMLayer.prototype.loadModel = function (modelFilePath) {
                        var _this = this;
                        return new Promise(function (resolve, _reject) {
                            // Sets up so the promise is resolved in the onMessage() callback, when it receives
                            // the 'ready' message.
                            _this._declareLMLayerReady = resolve;
                            _this._worker.postMessage({
                                message: 'load',
                                model: modelFilePath
                            });
                        });
                    };
                    /**
                     * Unloads the previously-active model from memory, resetting the LMLayer to prep
                     * for transition to use of a new model.
                     */
                    LMLayer.prototype.unloadModel = function () {
                        this._worker.postMessage({
                            message: 'unload'
                        });
                    };
                    LMLayer.prototype.predict = function (transform, context) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._predictPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'predict',
                                token: token,
                                transform: transform,
                                context: context,
                            });
                        });
                    };
                    LMLayer.prototype.wordbreak = function (context) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._wordbreakPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'wordbreak',
                                token: token,
                                context: context
                            });
                        });
                    };
                    // TODO: asynchronous close() method.
                    //       Worker code must recognize message and call self.close().
                    LMLayer.prototype.onMessage = function (event) {
                        var payload = event.data;
                        if (payload.message === 'error') {
                            console.error(payload.log);
                            if (payload.error) {
                                console.error(payload.error);
                            }
                        }
                        else if (payload.message === 'ready') {
                            this._declareLMLayerReady(event.data.configuration);
                        }
                        else if (payload.message === 'suggestions') {
                            this._predictPromises.keep(payload.token, payload.suggestions);
                        }
                        else if (payload.message === 'currentword') {
                            this._wordbreakPromises.keep(payload.token, payload.word);
                        }
                        else {
                            // This branch should never execute, but just in case...
                            //@ts-ignore
                            throw new Error("Message not implemented: " + payload.message);
                        }
                    };
                    /**
                     * Clears out any computational resources in use by the LMLayer, including shutting
                     * down any internal WebWorkers.
                     */
                    LMLayer.prototype.shutdown = function () {
                        this._worker.terminate();
                    };
                    /**
                     * Given a function, this utility returns the source code within it, as a string.
                     * This is intended to unwrap the "wrapped" source code created in the LMLayerWorker
                     * build process.
                     *
                     * @param fn The function whose body will be returned.
                     */
                    LMLayer.unwrap = function (fn) {
                        var wrapper = fn.toString();
                        var match = wrapper.match(/function[^{]+{((?:.|\r|\n)+)}[^}]*$/);
                        return match[1];
                    };
                    return LMLayer;
                }());
                prediction.LMLayer = LMLayer;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
(function () {
    var ns = com.keyman.text.prediction;
    // Let LMLayer be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ns.LMLayer;
        //@ts-ignore
        ns.LMLayer.PromiseStore = ns.PromiseStore;
    }
    else {
        //@ts-ignore
        window.LMLayer = ns.LMLayer;
    }
}());
///<reference path="../../../node_modules/@keymanapp/lexical-model-layer/embedded_worker.d.ts" />
///<reference path="../../../node_modules/@keymanapp/lexical-model-layer/message.d.ts" />
///<reference path="../../../node_modules/@keymanapp/lexical-model-layer/index.ts" />
///<reference path="../../includes/events.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction_1) {
                var TranscriptionContext = /** @class */ (function () {
                    function TranscriptionContext(mock, config) {
                        this.left = mock.getTextBeforeCaret();
                        this.startOfBuffer = this.left._kmwLength() > config.leftContextCodePoints;
                        if (!this.startOfBuffer) {
                            // Our custom substring version will return the last n characters if param #1 is given -n.
                            this.left = this.left._kmwSubstr(-config.leftContextCodePoints);
                        }
                        this.right = mock.getTextAfterCaret();
                        this.endOfBuffer = this.right._kmwLength() > config.leftContextCodePoints;
                        if (!this.endOfBuffer) {
                            this.right = this.right._kmwSubstr(0, config.leftContextCodePoints);
                        }
                    }
                    return TranscriptionContext;
                }());
                prediction_1.TranscriptionContext = TranscriptionContext;
                var ReadySuggestions = /** @class */ (function () {
                    function ReadySuggestions(suggestions, id) {
                        this.suggestions = suggestions;
                        this.transcriptionID = id;
                    }
                    return ReadySuggestions;
                }());
                prediction_1.ReadySuggestions = ReadySuggestions;
                var LanguageProcessor = /** @class */ (function (_super) {
                    __extends(LanguageProcessor, _super);
                    function LanguageProcessor() {
                        var _this = _super !== null && _super.apply(this, arguments) || this;
                        _this.recentTranscriptions = [];
                        _this._mayPredict = true;
                        _this._mayCorrect = true;
                        return _this;
                    }
                    LanguageProcessor.prototype.init = function (supportsRightDeletions) {
                        if (supportsRightDeletions === void 0) { supportsRightDeletions = false; }
                        // Establishes KMW's platform 'capabilities', which limit the range of context a LMLayer
                        // model may expect.
                        var capabilities = {
                            maxLeftContextCodePoints: 64,
                            // Since the apps don't yet support right-deletions.
                            maxRightContextCodePoints: supportsRightDeletions ? 0 : 64
                        };
                        if (!this.canEnable()) {
                            return;
                        }
                        this.lmEngine = new prediction_1.LMLayer(capabilities);
                    };
                    Object.defineProperty(LanguageProcessor.prototype, "activeModel", {
                        get: function () {
                            return this.currentModel;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    LanguageProcessor.prototype.unloadModel = function () {
                        this.lmEngine.unloadModel();
                        delete this.currentModel;
                        delete this.configuration;
                        this.emit('statechange', 'inactive');
                    };
                    LanguageProcessor.prototype.loadModel = function (model) {
                        if (!model) {
                            throw new Error("Null reference not allowed.");
                        }
                        var file = model.path;
                        var lp = this;
                        // We should wait until the model is successfully loaded before setting our state values.
                        return this.lmEngine.loadModel(file).then(function (config) {
                            lp.currentModel = model;
                            lp.configuration = config;
                            try {
                                lp.emit('statechange', 'active');
                            }
                            catch (err) {
                                // Does this provide enough logging information?
                                console.error("Could not load model '" + model.id + "': " + err.message);
                            }
                        });
                    };
                    LanguageProcessor.prototype.invalidateContext = function (outputTarget) {
                        // Signal to any predictive text UI that the context has changed, invalidating recent predictions.
                        this.emit('invalidatesuggestions', 'context');
                        // If there's no active model, there can be no predictions.
                        // We'll also be missing important data needed to even properly REQUEST the predictions.
                        if (!this.currentModel || !this.configuration) {
                            return;
                        }
                        if (outputTarget) {
                            this.predict_internal(outputTarget.buildTranscriptionFrom(outputTarget, null));
                        }
                    };
                    LanguageProcessor.prototype.wordbreak = function (target) {
                        if (!this.isActive) {
                            return null;
                        }
                        var context = new TranscriptionContext(text.Mock.from(target), this.configuration);
                        return this.lmEngine.wordbreak(context);
                    };
                    LanguageProcessor.prototype.predict = function (transcription) {
                        if (!this.isActive) {
                            return null;
                        }
                        // If there's no active model, there can be no predictions.
                        // We'll also be missing important data needed to even properly REQUEST the predictions.
                        if (!this.currentModel || !this.configuration) {
                            return null;
                        }
                        // We've already invalidated any suggestions resulting from any previously-existing Promise -
                        // may as well officially invalidate them via event.
                        this.emit("invalidatesuggestions", 'new');
                        return this.predict_internal(transcription);
                    };
                    LanguageProcessor.prototype.predictFromTarget = function (outputTarget) {
                        if (!outputTarget) {
                            return null;
                        }
                        var transcription = outputTarget.buildTranscriptionFrom(outputTarget, null);
                        return this.predict(transcription);
                    };
                    /**
                     * Called internally to do actual predictions after any relevant "invalidatesuggestions" events
                     * have been raised.
                     * @param transcription The triggering transcription (if it exists)
                     */
                    LanguageProcessor.prototype.predict_internal = function (transcription) {
                        if (!transcription) {
                            return null;
                        }
                        var context = new TranscriptionContext(transcription.preInput, this.configuration);
                        this.recordTranscription(transcription);
                        var transform = transcription.transform;
                        var promise = this.currentPromise = this.lmEngine.predict(transcription.alternates || transcription.transform, context);
                        var lp = this;
                        return promise.then(function (suggestions) {
                            if (promise == lp.currentPromise) {
                                var result = new ReadySuggestions(suggestions, transform.id);
                                lp.emit("suggestionsready", result);
                                lp.currentPromise = null;
                            }
                            return suggestions;
                        });
                    };
                    LanguageProcessor.prototype.recordTranscription = function (transcription) {
                        this.recentTranscriptions.push(transcription);
                        if (this.recentTranscriptions.length > LanguageProcessor.TRANSCRIPTION_BUFFER) {
                            this.recentTranscriptions.splice(0, 1);
                        }
                    };
                    /**
                     * Retrieves the context and output state of KMW immediately before the prediction with
                     * token `id` was generated.  Must correspond to a 'recent' one, as only so many are stored
                     * in `ModelManager`'s history buffer.
                     * @param id A unique identifier corresponding to a recent `Transcription`.
                     * @returns The matching `Transcription`, or `null` none is found.
                     */
                    LanguageProcessor.prototype.getPredictionState = function (id) {
                        var match = this.recentTranscriptions.filter(function (t) {
                            return t.token == id;
                        });
                        return match.length == 0 ? null : match[0];
                    };
                    LanguageProcessor.prototype.shutdown = function () {
                        this.lmEngine.shutdown();
                    };
                    Object.defineProperty(LanguageProcessor.prototype, "isActive", {
                        get: function () {
                            if (!this.canEnable()) {
                                this._mayPredict = false;
                                return false;
                            }
                            return this.activeModel && this._mayPredict;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    LanguageProcessor.prototype.canEnable = function () {
                        // Is overridden for dom-aware KMW in case of old IE versions.
                        return true;
                    };
                    Object.defineProperty(LanguageProcessor.prototype, "mayPredict", {
                        get: function () {
                            return this._mayPredict;
                        },
                        set: function (flag) {
                            if (!this.canEnable()) {
                                return;
                            }
                            var oldVal = this._mayPredict;
                            this._mayPredict = flag;
                            if (oldVal != flag) {
                                this.emit('statechange', flag ? 'active' : 'inactive');
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(LanguageProcessor.prototype, "mayCorrect", {
                        get: function () {
                            return this._mayCorrect;
                        },
                        set: function (flag) {
                            this._mayCorrect = flag;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    LanguageProcessor.prototype.tryAcceptSuggestion = function (source) {
                        // Handlers of this event should return 'false' when the 'try' is successful.
                        return !this.emit('tryaccept', source);
                    };
                    LanguageProcessor.prototype.tryRevertSuggestion = function () {
                        // Handlers of this event should return 'false' when the 'try' is successful.
                        return !this.emit('tryrevert', null);
                    };
                    return LanguageProcessor;
                }(EventEmitter));
                prediction_1.LanguageProcessor = LanguageProcessor;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines a 'polyfill' of sorts for NPM's events module
/// <reference path="../includes/events.ts" />
/// <reference path="../../node_modules/@keymanapp/keyboard-processor/src/text/keyboardProcessor.ts" />
/// <reference path="prediction/languageProcessor.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var InputProcessor = /** @class */ (function () {
                function InputProcessor(options) {
                    if (!options) {
                        options = InputProcessor.DEFAULT_OPTIONS;
                    }
                    this.kbdProcessor = new text.KeyboardProcessor(options);
                    this.lngProcessor = new text.prediction.LanguageProcessor();
                }
                Object.defineProperty(InputProcessor.prototype, "languageProcessor", {
                    get: function () {
                        return this.lngProcessor;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "keyboardProcessor", {
                    get: function () {
                        return this.kbdProcessor;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "keyboardInterface", {
                    get: function () {
                        return this.keyboardProcessor.keyboardInterface;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "activeKeyboard", {
                    get: function () {
                        return this.keyboardInterface.activeKeyboard;
                    },
                    set: function (keyboard) {
                        this.keyboardInterface.activeKeyboard = keyboard;
                        // All old deadkeys and keyboard-specific cache should immediately be invalidated
                        // on a keyboard change.
                        this.resetContext();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "activeModel", {
                    get: function () {
                        return this.languageProcessor.activeModel;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
             * Simulate a keystroke according to the touched keyboard button element
             *
             * Handles default output and keyboard processing for both OSK and physical keystrokes.
             *
             * @param       {Object}      e      The abstracted KeyEvent to use for keystroke processing
             */
                InputProcessor.prototype.processKeyEvent = function (keyEvent) {
                    var formFactor = keyEvent.device.formFactor;
                    // Determine the current target for text output and create a "mock" backup
                    // of its current, pre-input state.  Current, long-existing assumption - it's DOM-backed.
                    var outputTarget = keyEvent.Ltarg;
                    var fromOSK = keyEvent.isSynthetic;
                    // The default OSK layout for desktop devices does not include nextlayer info, relying on modifier detection here.
                    // It's the OSK equivalent to doModifierPress on 'desktop' form factors.
                    if ((formFactor == text.FormFactor.Desktop || !this.activeKeyboard || this.activeKeyboard.usesDesktopLayoutOnDevice(keyEvent.device)) && fromOSK) {
                        // If it's a desktop OSK style and this triggers a layer change,
                        // a modifier key was clicked.  No output expected, so it's safe to instantly exit.
                        if (this.keyboardProcessor.selectLayer(keyEvent)) {
                            return true;
                        }
                    }
                    // Will handle keystroke-based non-layer change modifier & state keys, mapping them through the physical keyboard's version
                    // of state management.
                    if (!fromOSK && this.keyboardProcessor.doModifierPress(keyEvent, !fromOSK)) {
                        return true;
                    }
                    // If suggestions exist AND space is pressed, accept the suggestion and do not process the keystroke.
                    // If a suggestion was just accepted AND backspace is pressed, revert the change and do not process the backspace.
                    // We check the first condition here, while the prediction UI handles the second through the try__() methods below.
                    if (this.languageProcessor.isActive) {
                        // The following code relies on JS's logical operator "short-circuit" properties to prevent unwanted triggering of the second condition.
                        // Can the suggestion UI revert a recent suggestion?  If so, do that and swallow the backspace.
                        if ((keyEvent.kName == "K_BKSP" || keyEvent.Lcode == text.Codes.keyCodes["K_BKSP"]) && this.languageProcessor.tryRevertSuggestion()) {
                            return;
                            // Can the suggestion UI accept an existing suggestion?  If so, do that and swallow the space character.
                        }
                        else if ((keyEvent.kName == "K_SPACE" || keyEvent.Lcode == text.Codes.keyCodes["K_SPACE"]) && this.languageProcessor.tryAcceptSuggestion('space')) {
                            return;
                        }
                    }
                    // // ...end I3363 (Build 301)
                    var preInputMock = text.Mock.from(outputTarget);
                    var ruleBehavior = this.keyboardProcessor.processKeystroke(keyEvent, outputTarget);
                    // Swap layer as appropriate.
                    if (keyEvent.kNextLayer) {
                        this.keyboardProcessor.selectLayer(keyEvent);
                    }
                    // Should we swallow any further processing of keystroke events for this keydown-keypress sequence?
                    if (ruleBehavior != null) {
                        var alternates = void 0;
                        // If we're performing a 'default command', it's not a standard 'typing' event - don't do fat-finger stuff.
                        // Also, don't do fat-finger stuff if predictive text isn't enabled.
                        if (this.languageProcessor.isActive && !ruleBehavior.triggersDefaultCommand) {
                            // Note - we don't yet do fat-fingering with longpress keys.
                            if (keyEvent.keyDistribution && keyEvent.kbdLayer) {
                                var activeLayout = this.activeKeyboard.layout(keyEvent.device.formFactor);
                                alternates = [];
                                for (var _i = 0, _a = keyEvent.keyDistribution; _i < _a.length; _i++) {
                                    var pair = _a[_i];
                                    var mock = text.Mock.from(preInputMock);
                                    var altKey = activeLayout.getLayer(keyEvent.kbdLayer).getKey(pair.keyId);
                                    if (!altKey) {
                                        console.warn("Potential fat-finger key could not be found in layer!");
                                        continue;
                                    }
                                    var altEvent = altKey.constructKeyEvent(this.keyboardProcessor, mock, keyEvent.device);
                                    var alternateBehavior = this.keyboardProcessor.processKeystroke(altEvent, mock);
                                    if (alternateBehavior) {
                                        // TODO: if alternateBehavior.beep == true, set 'p' to 0.  It's a disallowed key sequence,
                                        //       so a user should never have intended to type it.  Should probably renormalize 
                                        //       the distribution afterward, though...
                                        var transform = alternateBehavior.transcription.transform;
                                        // Ensure that the alternate's token id matches that of the current keystroke, as we only
                                        // record the matched rule's context (since they match)
                                        transform.id = ruleBehavior.transcription.token;
                                        alternates.push({ sample: transform, 'p': pair.p });
                                    }
                                }
                            }
                        }
                        // Now that we've done all the keystroke processing needed, ensure any extra effects triggered
                        // by the actual keystroke occur.
                        ruleBehavior.finalize(this.keyboardProcessor);
                        // -- All keystroke (and 'alternate') processing is now complete.  Time to finalize everything! --
                        // Notify the ModelManager of new input - it's predictive text time!
                        ruleBehavior.transcription.alternates = alternates;
                        // Yes, even for ruleBehavior.triggersDefaultCommand.  Those tend to change the context.
                        ruleBehavior.predictionPromise = this.languageProcessor.predict(ruleBehavior.transcription);
                        // Text did not change (thus, no text "input") if we tabbed or merely moved the caret.
                        if (!ruleBehavior.triggersDefaultCommand) {
                            // For DOM-aware targets, this will trigger a DOM event page designers may listen for.
                            outputTarget.doInputEvent();
                        }
                    }
                    /* I732 END - 13/03/2007 MCD: End Positional Layout support in OSK */
                    // TODO:  rework the return value to be `ruleBehavior` instead.  Functions that call this one are
                    //        the ones that should worry about event handler returns, etc.  Not this one.
                    //
                    //        They should also be the ones to handle the TODOs seen earlier in this function -
                    //        once THOSE are properly relocated.  (They're too DOM-heavy to remain in web-core.)
                    // Only return true (for the eventual event handler's return value) if we didn't match a rule.
                    return ruleBehavior;
                };
                InputProcessor.prototype.resetContext = function () {
                    this.keyboardProcessor.resetContext();
                    this.languageProcessor.invalidateContext();
                };
                InputProcessor.DEFAULT_OPTIONS = {
                    baseLayout: 'us'
                };
                return InputProcessor;
            }());
            text.InputProcessor = InputProcessor;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
//# sourceMappingURL=index.js.map