'use strict';
//Autogenerated file - do not modify!
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var environment;
        (function (environment) {
            environment.VERSION = "15.0";
            environment.BUILD = 163;
            environment.ENVIRONMENT = "local";
            environment.SENTRY_RELEASE = "release-15.0.163-alpha-local";
        })(environment = keyman.environment || (keyman.environment = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Function     deepCopy
             * Scope        Private
             * @param       {Object}      p           object to copy
             * @param       {Array=}      c0          array member being copied
             * @return      {Object}                  clone ('deep copy') of object
             * Description  Makes an actual copy (not a reference) of an object, copying simple members,
             *              arrays and member objects but not functions, so use with care!
             */
            function deepCopy(p, c0) {
                var c = c0 || {};
                for (var i in p) {
                    if (typeof p[i] === 'object' && p[i] != null) {
                        c[i] = (p[i].constructor === Array) ? [] : {};
                        deepCopy(p[i], c[i]);
                    }
                    else {
                        c[i] = p[i];
                    }
                }
                return c;
            }
            utils.deepCopy = deepCopy;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            /**
             * Returns the base global object available to the current JS platform.
             * - In browsers, returns `window`.
             * - In WebWorkers, returns `self`.
             * - In Node, returns `global`.
             */
            function getGlobalObject() {
                // Evergreen browsers have started defining 'globalThis'.  
                // Refer to https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#type-checking-for-globalthis
                // and its referenced polyfill.  Said polyfill is very complex, so we opt for this far leaner variant.
                if (typeof globalThis != 'undefined') {
                    return globalThis; // Not available in IE or older Edge versions
                    // @ts-ignore (TS will throw errors for whatever platform we're not compiling for.)
                }
                else if (typeof window != 'undefined') {
                    // @ts-ignore
                    return window; // The browser-based classic
                    // @ts-ignore
                }
                else if (typeof self != 'undefined') {
                    // @ts-ignore
                    return self; // WebWorker global
                }
                else {
                    // Assumption - if neither of the above exist, we're in Node, for unit-testing.
                    // Node doesn't have as many methods and properties as the other two, but what 
                    // matters for us is that it's the base global.
                    //
                    // Some other headless JS solutions use 'this' instead, but Node's enough for our needs.
                    // @ts-ignore
                    return global;
                }
            }
            utils.getGlobalObject = getGlobalObject;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Ensure that this class contains no reference into core KMW code - it is referenced
// by components intended to be modular and possible to separate from core KMW.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            // Dotted-decimal version
            var Version = /** @class */ (function () {
                /**
                 * Parses version information, preparing it for use in comparisons.
                 * @param text Either a string representing a version number (ex: "9.0.0") or an array representing
                 *             its components (ex: [9, 0, 0]).
                 */
                function Version(text) {
                    // If a keyboard doesn't specify a version, use the DEVELOPER_VERSION_FALLBACK values.
                    if (text === undefined || text === null) {
                        this.components = [].concat(Version.DEVELOPER_VERSION_FALLBACK.components);
                        return;
                    }
                    if (Array.isArray(text)) {
                        var components = text;
                        if (components.length < 2) {
                            throw new Error("Version string must have at least a major and minor component!");
                        }
                        else {
                            this.components = [].concat(components);
                            return;
                        }
                    }
                    // else, standard constructor path.
                    var parts = text.split('.');
                    var componentArray = [];
                    if (parts.length < 2) {
                        throw new Error("Version string must have at least a major and minor component!");
                    }
                    for (var i = 0; i < parts.length; i++) {
                        var value = parseInt(parts[i], 10);
                        if (isNaN(value)) {
                            throw new Error("Version string components must be numerical!");
                        }
                        componentArray.push(value);
                    }
                    this.components = componentArray;
                }
                Object.defineProperty(Version.prototype, "major", {
                    get: function () {
                        return this.components[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Version.prototype, "minor", {
                    get: function () {
                        return this.components[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Version.prototype.toString = function () {
                    return this.components.join('.');
                };
                Version.prototype.toJSON = function () {
                    return this.toString();
                };
                Version.prototype.equals = function (other) {
                    return this.compareTo(other) == 0;
                };
                Version.prototype.precedes = function (other) {
                    return this.compareTo(other) < 0;
                };
                Version.prototype.compareTo = function (other) {
                    // If the version info depth differs, we need a flag to indicate which instance is shorter.
                    var isShorter = this.components.length < other.components.length;
                    var maxDepth = (this.components.length < other.components.length) ? this.components.length : other.components.length;
                    var i;
                    for (i = 0; i < maxDepth; i++) {
                        var delta = this.components[i] - other.components[i];
                        if (delta != 0) {
                            return delta;
                        }
                    }
                    var longList = isShorter ? other.components : this.components;
                    do {
                        if (longList[i] > 0) {
                            return isShorter ? -1 : 1;
                        }
                        i++;
                    } while (i < longList.length);
                    // Equal.
                    return 0;
                };
                Version.CURRENT = new Version(com.keyman.environment.VERSION);
                // Represents a default version value for keyboards compiled before this was compiled into keyboards.
                // The exact version is unknown at this point, but the value is "good enough" for what we need.
                Version.DEVELOPER_VERSION_FALLBACK = new Version([9, 0, 0]);
                // For 12.0, the old default behavior of adding missing keycaps to the default layers was removed,
                // as it results in unexpected, bug-like behavior for keyboard designers when it is unwanted.
                Version.NO_DEFAULT_KEYCAPS = new Version([12, 0]);
                Version.MAC_POSSIBLE_IPAD_ALIAS = new Version([10, 15]);
                return Version;
            }());
            utils.Version = Version;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 14.0
   Copyright 2020 SIL International
***/
/**
 * Constructs a string from one or more Unicode character codepoint values
 * passed as integer parameters.
 *
 * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
 * @return {string|null}      The new String object.
 */
String.kmwFromCharCode = function (cp0) {
    var chars = [], i;
    for (i = 0; i < arguments.length; i++) {
        var c = Number(arguments[i]);
        if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
            throw new RangeError("Invalid code point " + c);
        }
        if (c < 0x10000) {
            chars.push(c);
        }
        else {
            c -= 0x10000;
            chars.push((c >> 10) + 0xD800);
            chars.push((c % 0x400) + 0xDC00);
        }
    }
    return String.fromCharCode.apply(undefined, chars);
};
/**
 * Returns a number indicating the Unicode value of the character at the given
 * code point index, with support for supplementary plane characters.
 *
 * @param  {number}  codePointIndex  The code point index into the string (not
                                     the code unit index) to return
 * @return {number}                  The Unicode character value
 */
String.prototype.kmwCharCodeAt = function (codePointIndex) {
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0 || codePointIndex >= str.length) {
        return NaN;
    }
    for (var i = 0; i < codePointIndex; i++) {
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        if (codeUnitIndex === null)
            return NaN;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
        }
    }
    return first;
};
/**
 * Returns the code point index within the calling String object of the first occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  [fromIndex]    Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.indexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the code point index within the calling String object of the last occurrence
 * of the specified value, or -1 if not found.
 *
 * @param  {string}  searchValue    The value to search for
 * @param  {number}  fromIndex      Optional code point index to start searching from
 * @return {number}                 The code point index of the specified search value
 */
String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
    var str = String(this);
    var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
    if (codeUnitIndex < 0) {
        return codeUnitIndex;
    }
    var codePointIndex = 0;
    for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
        codePointIndex++;
    return codePointIndex;
};
/**
 * Returns the length of the string in code points, as opposed to code units.
 *
 * @return {number}                 The length of the string in code points
 */
String.prototype.kmwLength = function () {
    var str = String(this);
    if (str.length == 0)
        return 0;
    for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return i;
};
/**
 * Extracts a section of a string and returns a new string.
 *
 * @param  {number}  beginSlice    The start code point index in the string to
 *                                 extract from
 * @param  {number}  endSlice      Optional end code point index in the string
 *                                 to extract to
 * @return {string}                The substring as selected by beginSlice and
 *                                 endSlice
 */
String.prototype.kmwSlice = function (beginSlice, endSlice) {
    var str = String(this);
    var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
    var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
    if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
        return '';
    else
        return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
};
/**
 * Returns the characters in a string beginning at the specified location through
 * the specified number of characters.
 *
 * @param  {number}  start         The start code point index in the string to
 *                                 extract from
 * @param  {number=}  length        Optional length to extract
 * @return {string}                The substring as selected by start and length
 */
String.prototype.kmwSubstr = function (start, length) {
    var str = String(this);
    if (start < 0) {
        start = str.kmwLength() + start;
    }
    if (start < 0)
        start = 0;
    var startCodeUnit = str.kmwCodePointToCodeUnit(start);
    var endCodeUnit = startCodeUnit;
    if (startCodeUnit === null)
        return '';
    if (arguments.length < 2) {
        endCodeUnit = str.length;
    }
    else {
        for (var i = 0; i < length; i++)
            endCodeUnit = str.kmwNextChar(endCodeUnit);
    }
    if (endCodeUnit === null)
        return str.substring(startCodeUnit);
    else
        return str.substring(startCodeUnit, endCodeUnit);
};
/**
 * Returns the characters in a string between two indexes into the string.
 *
 * @param  {number}  indexA        The start code point index in the string to
 *                                 extract from
 * @param  {number}  indexB        The end code point index in the string to
 *                                 extract to
 * @return {string}                The substring as selected by indexA and indexB
 */
String.prototype.kmwSubstring = function (indexA, indexB) {
    var str = String(this), indexACodeUnit, indexBCodeUnit;
    if (typeof (indexB) == 'undefined') {
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.length;
    }
    else {
        if (indexA > indexB) {
            var c = indexA;
            indexA = indexB;
            indexB = c;
        }
        indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
        indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
    }
    if (isNaN(indexACodeUnit) || indexACodeUnit === null)
        indexACodeUnit = 0;
    if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
        indexBCodeUnit = str.length;
    return str.substring(indexACodeUnit, indexBCodeUnit);
};
/*
  Helper functions
*/
/**
 * Returns the code unit index for the next code point in the string, accounting for
 * supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to increment
 * @return {number|null}                 The index of the next code point in the string,
 *                                       in code units
 */
String.prototype.kmwNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    var first = str.charCodeAt(codeUnitIndex);
    if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
        var second = str.charCodeAt(codeUnitIndex + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) {
            if (codeUnitIndex == str.length - 2) {
                return null;
            }
            return codeUnitIndex + 2;
        }
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string, accounting
 * for supplementary pairs
 *
 * @param  {number|null}  codeUnitIndex  The code unit position to decrement
 * @return {number|null}                 The index of the previous code point in the
 *                                       string, in code units
*/
String.prototype.kmwPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    var second = str.charCodeAt(codeUnitIndex - 1);
    if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
        var first = str.charCodeAt(codeUnitIndex - 2);
        if (first >= 0xD800 && first <= 0xDBFF) {
            return codeUnitIndex - 2;
        }
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the corresponding code unit index to the code point index passed
 *
 * @param  {number|null} codePointIndex  A code point index in the string
 * @return {number|null}                 The corresponding code unit index
 */
String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
    if (codePointIndex === null)
        return null;
    var str = String(this);
    var codeUnitIndex = 0;
    if (codePointIndex < 0) {
        codeUnitIndex = str.length;
        for (var i = 0; i > codePointIndex; i--)
            codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
        return codeUnitIndex;
    }
    if (codePointIndex == str.kmwLength())
        return str.length;
    for (var i = 0; i < codePointIndex; i++)
        codeUnitIndex = str.kmwNextChar(codeUnitIndex);
    return codeUnitIndex;
};
/**
 * Returns the corresponding code point index to the code unit index passed
 *
 * @param  {number|null}  codeUnitIndex  A code unit index in the string
 * @return {number|null}                 The corresponding code point index
 */
String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex === null)
        return null;
    else if (codeUnitIndex == 0)
        return 0;
    else if (codeUnitIndex < 0)
        return str.substr(codeUnitIndex).kmwLength();
    else
        return str.substr(0, codeUnitIndex).kmwLength();
};
/**
 * Returns the character at a the code point index passed
 *
 * @param  {number}  codePointIndex  A code point index in the string
 * @return {string}                  The corresponding character
 */
String.prototype.kmwCharAt = function (codePointIndex) {
    var str = String(this);
    if (codePointIndex >= 0)
        return str.kmwSubstr(codePointIndex, 1);
    else
        return '';
};
/**
 * String prototype library extensions for basic plane characters,
 * to simplify enabling or disabling supplementary plane functionality (I3319)
 */
/**
 * Returns the code unit index for the next code point in the string
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
        return null;
    }
    return codeUnitIndex + 1;
};
/**
 * Returns the code unit index for the previous code point in the string
 *
 * @param  {number}  codeUnitIndex    A code unit index in the string
 * @return {number|null}                   The corresponding character
 */
String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
    var str = String(this);
    if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
        return null;
    }
    return codeUnitIndex - 1;
};
/**
 * Returns the code unit index for a code point index
 *
 * @param  {number}  codePointIndex   A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
    return codePointIndex;
};
/**
 * Returns the code point index for a code unit index
 *
 * @param  {number}  codeUnitIndex    A code point index in the string
 * @return {number}                   The corresponding character
 */
String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
    return codeUnitIndex;
};
/**
 * Returns the length of a BMP string
 *
 * @return {number}                   The length in code points
 */
String.prototype.kmwBMPLength = function () {
    var str = String(this);
    return str.length;
};
/**
 * Returns a substring
 *
 * @param  {number}  n
 * @param  {number=}  ln
 * @return {string}
 */
String.prototype.kmwBMPSubstr = function (n, ln) {
    var str = String(this);
    if (n > -1)
        return str.substr(n, ln);
    else
        return str.substr(str.length + n, -n);
};
/**
 * Enable or disable supplementary plane string handling
 *
 * @param  {boolean}  bEnable
 */
String.kmwEnableSupplementaryPlane = function (bEnable) {
    var p = String.prototype;
    String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
    p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
    p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
    p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
    p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
    p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
    p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
    p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
    p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
    p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
    p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
    p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
    p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
};
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var utils;
        (function (utils) {
            var Browser;
            (function (Browser) {
                Browser["Chrome"] = "chrome";
                Browser["Edge"] = "edge";
                Browser["Firefox"] = "firefox";
                Browser["Native"] = "native";
                Browser["Opera"] = "opera";
                Browser["Safari"] = "safari";
                Browser["Other"] = "other";
            })(Browser = utils.Browser || (utils.Browser = {}));
            var OperatingSystem;
            (function (OperatingSystem) {
                OperatingSystem["Windows"] = "windows";
                OperatingSystem["macOS"] = "macosx";
                OperatingSystem["Linux"] = "linux";
                OperatingSystem["Android"] = "android";
                OperatingSystem["iOS"] = "ios";
                OperatingSystem["Other"] = "other";
            })(OperatingSystem = utils.OperatingSystem || (utils.OperatingSystem = {}));
            var FormFactor;
            (function (FormFactor) {
                FormFactor["Desktop"] = "desktop";
                FormFactor["Phone"] = "phone";
                FormFactor["Tablet"] = "tablet";
            })(FormFactor = utils.FormFactor || (utils.FormFactor = {}));
            /**
             * This class provides an abstract version of com.keyman.Device that is core-friendly,
             * containing only the information needed by web-core for text processing use, devoid
             * of any direct references to the DOM.
             */
            var DeviceSpec = /** @class */ (function () {
                function DeviceSpec(browser, formFactor, OS, touchable) {
                    switch (browser.toLowerCase()) {
                        case Browser.Chrome:
                        case Browser.Edge:
                        case Browser.Firefox:
                        case Browser.Native:
                        case Browser.Opera:
                        case Browser.Safari:
                            this.browser = browser.toLowerCase();
                            break;
                        default:
                            this.browser = Browser.Other;
                    }
                    switch (formFactor.toLowerCase()) {
                        case FormFactor.Desktop:
                        case FormFactor.Phone:
                        case FormFactor.Tablet:
                            this.formFactor = formFactor.toLowerCase();
                            break;
                        default:
                            throw ("Invalid form factor specified for device: " + formFactor);
                    }
                    switch (OS.toLowerCase()) {
                        case OperatingSystem.Windows.toLowerCase():
                        case OperatingSystem.macOS.toLowerCase():
                        case OperatingSystem.Linux.toLowerCase():
                        case OperatingSystem.Android.toLowerCase():
                        case OperatingSystem.iOS.toLowerCase():
                            this.OS = OS.toLowerCase();
                            break;
                        default:
                            this.OS = OperatingSystem.Other;
                    }
                    this.touchable = touchable;
                }
                return DeviceSpec;
            }());
            utils.DeviceSpec = DeviceSpec;
        })(utils = keyman.utils || (keyman.utils = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// References all utility includes from a single file, making import/export simple.
///<reference path="deepCopy.ts" />
///<reference path="globalObject.ts" />
///<reference path="version.ts" />
///<reference path="kmwstring.ts" />
///<reference path="deviceSpec.ts" />
// Autogenerated code. Do not modify!
function LMLayerWorkerCode() {
    /*! https://mths.be/codepointat v0.2.0 by @mathias */
    if (!String.prototype.codePointAt) {
        (function () {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function () {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                }
                catch (error) { }
                return result;
            }());
            var codePointAt = function (position) {
                if (this == null) {
                    throw TypeError();
                }
                var string = String(this);
                var size = string.length;
                // `ToInteger`
                var index = position ? Number(position) : 0;
                if (index != index) { // better `isNaN`
                    index = 0;
                }
                // Account for out-of-bounds indices:
                if (index < 0 || index >= size) {
                    return undefined;
                }
                // Get the first code unit
                var first = string.charCodeAt(index);
                var second;
                if ( // check if it’s the start of a surrogate pair
                first >= 0xD800 && first <= 0xDBFF && // high surrogate
                    size > index + 1 // there is a next code unit
                ) {
                    second = string.charCodeAt(index + 1);
                    if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                    }
                }
                return first;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'codePointAt', {
                    'value': codePointAt,
                    'configurable': true,
                    'writable': true
                });
            }
            else {
                String.prototype.codePointAt = codePointAt;
            }
        }());
    }
    /*! http://mths.be/startswith v0.2.0 by @mathias */
    if (!String.prototype.startsWith) {
        (function () {
            'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
            var defineProperty = (function () {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                }
                catch (error) { }
                return result;
            }());
            var toString = {}.toString;
            var startsWith = function (search) {
                if (this == null) {
                    throw TypeError();
                }
                var string = String(this);
                if (search && toString.call(search) == '[object RegExp]') {
                    throw TypeError();
                }
                var stringLength = string.length;
                var searchString = String(search);
                var searchLength = searchString.length;
                var position = arguments.length > 1 ? arguments[1] : undefined;
                // `ToInteger`
                var pos = position ? Number(position) : 0;
                if (pos != pos) { // better `isNaN`
                    pos = 0;
                }
                var start = Math.min(Math.max(pos, 0), stringLength);
                // Avoid the `indexOf` call if no match is possible
                if (searchLength + start > stringLength) {
                    return false;
                }
                var index = -1;
                while (++index < searchLength) {
                    if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                        return false;
                    }
                }
                return true;
            };
            if (defineProperty) {
                defineProperty(String.prototype, 'startsWith', {
                    'value': startsWith,
                    'configurable': true,
                    'writable': true
                });
            }
            else {
                String.prototype.startsWith = startsWith;
            }
        }());
    }
    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
    if (!Array.prototype.fill) {
        Object.defineProperty(Array.prototype, 'fill', {
            value: function (value) {
                // Steps 1-2.
                if (this == null) {
                    throw new TypeError('this is null or not defined');
                }
                var O = Object(this);
                // Steps 3-5.
                var len = O.length >>> 0;
                // Steps 6-7.
                var start = arguments[1];
                var relativeStart = start >> 0;
                // Step 8.
                var k = relativeStart < 0 ?
                    Math.max(len + relativeStart, 0) :
                    Math.min(relativeStart, len);
                // Steps 9-10.
                var end = arguments[2];
                var relativeEnd = end === undefined ?
                    len : end >> 0;
                // Step 11.
                var finalValue = relativeEnd < 0 ?
                    Math.max(len + relativeEnd, 0) :
                    Math.min(relativeEnd, len);
                // Step 12.
                while (k < finalValue) {
                    O[k] = value;
                    k++;
                }
                // Step 13.
                return O;
            }
        });
    } // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from
    // Any npm-based ones require use of `require`, which won't work for us.
    // Production steps of ECMA-262, Edition 6, 22.1.2.1
    if (!Array.from) {
        Array.from = (function () {
            var toStr = Object.prototype.toString;
            var isCallable = function (fn) {
                return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
            };
            var toInteger = function (value) {
                var number = Number(value);
                if (isNaN(number)) {
                    return 0;
                }
                if (number === 0 || !isFinite(number)) {
                    return number;
                }
                return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
            };
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var toLength = function (value) {
                var len = toInteger(value);
                return Math.min(Math.max(len, 0), maxSafeInteger);
            };
            // The length property of the from method is 1.
            return function from(arrayLike /*, mapFn, thisArg */) {
                // 1. Let C be the this value.
                var C = this;
                // 2. Let items be ToObject(arrayLike).
                var items = Object(arrayLike);
                // 3. ReturnIfAbrupt(items).
                if (arrayLike == null) {
                    throw new TypeError('Array.from requires an array-like object - not null or undefined');
                }
                // 4. If mapfn is undefined, then let mapping be false.
                var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
                var T;
                if (typeof mapFn !== 'undefined') {
                    // 5. else
                    // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
                    if (!isCallable(mapFn)) {
                        throw new TypeError('Array.from: when provided, the second argument must be a function');
                    }
                    // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
                    if (arguments.length > 2) {
                        T = arguments[2];
                    }
                }
                // 10. Let lenValue be Get(items, "length").
                // 11. Let len be ToLength(lenValue).
                var len = toLength(items.length);
                // 13. If IsConstructor(C) is true, then
                // 13. a. Let A be the result of calling the [[Construct]] internal method 
                // of C with an argument list containing the single item len.
                // 14. a. Else, Let A be ArrayCreate(len).
                var A = isCallable(C) ? Object(new C(len)) : new Array(len);
                // 16. Let k be 0.
                var k = 0;
                // 17. Repeat, while k < len… (also steps a - h)
                var kValue;
                while (k < len) {
                    kValue = items[k];
                    if (mapFn) {
                        A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                    }
                    else {
                        A[k] = kValue;
                    }
                    k += 1;
                }
                // 18. Let putStatus be Put(A, "length", len, true).
                A.length = len;
                // 20. Return A.
                return A;
            };
        }());
    }
    // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
    if (!Object.keys) {
        Object.keys = (function () {
            'use strict';
            var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'), dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ], dontEnumsLength = dontEnums.length;
            return function (obj) {
                if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {
                    throw new TypeError('Object.keys called on non-object');
                }
                var result = [], prop, i;
                for (prop in obj) {
                    if (hasOwnProperty.call(obj, prop)) {
                        result.push(prop);
                    }
                }
                if (hasDontEnumBug) {
                    for (i = 0; i < dontEnumsLength; i++) {
                        if (hasOwnProperty.call(obj, dontEnums[i])) {
                            result.push(dontEnums[i]);
                        }
                    }
                }
                return result;
            };
        }());
    }
    // Now for Object.values, from https://github.com/tc39/proposal-object-values-entries/blob/master/polyfill.js
    // Early Android APIs do not support Reflect, hence the need to 'mesh' them like this.
    var reduce = Function.bind.call(Function.call, Array.prototype.reduce);
    var isEnumerable = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable);
    var concat = Function.bind.call(Function.call, Array.prototype.concat);
    //const keys = Reflect.ownKeys;
    var keys = Object.keys;
    if (!Object.values) {
        Object.values = function values(O) {
            return reduce(keys(O), function (v, k) { return concat(v, typeof k === 'string' && isEnumerable(O, k) ? [O[k]] : []); }, []);
        };
    }
    if (!Object.entries) {
        Object.entries = function entries(O) {
            return reduce(keys(O), function (e, k) { return concat(e, typeof k === 'string' && isEnumerable(O, k) ? [[k, O[k]]] : []); }, []);
        };
    } // From https://rousan.io/symbol-es6/, lightly modified to be worker-compatible for Android Lollipop.
    !function (global, factory) {
        "use strict";
        "object" == typeof module && "object" == typeof module.exports ? module.exports = factory(global) : factory(global);
    }("undefined" != typeof window ? window : (self ? self : global), function (global) {
        "use strict";
        var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, symbolHiddenCounter = 0, globalSymbolRegistry = [], slice = Array.prototype.slice, ES6 = "object" == typeof global.ES6 ? global.ES6 : global.ES6 = {}, isArray = Array.isArray, objectToString = Object.prototype.toString, push = Array.prototype.push, emptyFunction = function () { }, simpleFunction = function (arg) { return arg; }, isCallable = function (fn) { return "function" == typeof fn; }, Iterator = function () { }, ArrayIterator = function (array, flag) { this._array = array, this._flag = flag, this._nextIndex = 0; }, StringIterator = function (string, flag) { this._string = string, this._flag = flag, this._nextIndex = 0; }, isObject = function (value) { return null !== value && ("object" == typeof value || "function" == typeof value); }, setupSymbolInternals = function (symbol, desc) { return defineProperties(symbol, { _description: { value: desc }, _isSymbol: { value: !0 }, _id: { value: symbolHiddenCounter++ } }), symbol; }, appendArray = function (array1, array2) { if ("number" == typeof array1.length && array1.length >= 0 && "number" == typeof array2.length && array2.length >= 0) {
            var length1 = Math.floor(array1.length), length2 = Math.floor(array2.length), i = 0;
            for (array1.length = length1 + length2; i < length2; ++i)
                array2.hasOwnProperty(i) && (array1[length1 + i] = array2[i]);
        } }, simpleInheritance = function (child, parent) { if ("function" != typeof child || "function" != typeof parent)
            throw new TypeError("Child and Parent must be function type"); child.prototype = Object.create(parent.prototype), child.prototype.constructor = child; }, Symbol = function Symbol(desc) { if (desc = void 0 === desc ? "" : String(desc), this instanceof Symbol)
            throw new TypeError("Symbol is not a constructor"); return setupSymbolInternals(Object.create(Symbol.prototype), desc); };
        defineProperties(Symbol, { for: { value: function (key) { key = String(key); for (var record, registryLength = globalSymbolRegistry.length, i = 0; i < registryLength; ++i)
                    if ((record = globalSymbolRegistry[i]).key === key)
                        return record.symbol; return record = { key: key, symbol: Symbol(key) }, globalSymbolRegistry.push(record), record.symbol; }, writable: !0, configurable: !0 }, keyFor: { value: function (symbol) { if (!ES6.isSymbol(symbol))
                    throw new TypeError(String(symbol) + " is not a symbol"); for (var record, registryLength = globalSymbolRegistry.length, i = 0; i < registryLength; ++i)
                    if ((record = globalSymbolRegistry[i]).symbol === symbol)
                        return record.key; }, writable: !0, configurable: !0 }, hasInstance: { value: Symbol("Symbol.hasInstance") }, isConcatSpreadable: { value: Symbol("Symbol.isConcatSpreadable") }, iterator: { value: Symbol("Symbol.iterator") }, toStringTag: { value: Symbol("Symbol.toStringTag") } }), Symbol.prototype.toString = function () { return "@@_____" + this._id + "_____"; }, Symbol.prototype.valueOf = function () { return this; }, defineProperty(Iterator.prototype, Symbol.iterator.toString(), { value: function () { return this; }, writable: !0, configurable: !0 }), simpleInheritance(ArrayIterator, Iterator), simpleInheritance(StringIterator, Iterator), defineProperty(ArrayIterator.prototype, Symbol.toStringTag.toString(), { value: "Array Iterator", configurable: !0 }), defineProperty(StringIterator.prototype, Symbol.toStringTag.toString(), { value: "String Iterator", configurable: !0 }), ArrayIterator.prototype.next = function () { if (!(this instanceof ArrayIterator))
            throw new TypeError("Method Array Iterator.prototype.next called on incompatible receiver " + String(this)); var nextValue; return -1 === this._nextIndex ? { done: !0, value: void 0 } : "number" == typeof this._array.length && this._array.length >= 0 && this._nextIndex < Math.floor(this._array.length) ? (1 === this._flag ? nextValue = [this._nextIndex, this._array[this._nextIndex]] : 2 === this._flag ? nextValue = this._array[this._nextIndex] : 3 === this._flag && (nextValue = this._nextIndex), this._nextIndex++, { done: !1, value: nextValue }) : (this._nextIndex = -1, { done: !0, value: void 0 }); }, StringIterator.prototype.next = function () { if (!(this instanceof StringIterator))
            throw new TypeError("Method String Iterator.prototype.next called on incompatible receiver " + String(this)); var nextValue, stringObject = new String(this._string); return -1 === this._nextIndex ? { done: !0, value: void 0 } : this._nextIndex < stringObject.length ? (nextValue = stringObject[this._nextIndex], this._nextIndex++, { done: !1, value: nextValue }) : (this._nextIndex = -1, { done: !0, value: void 0 }); };
        var SpreadOperatorImpl = function (target, thisArg) { this._target = target, this._values = [], this._thisArg = thisArg; };
        SpreadOperatorImpl.prototype.spread = function () { var self = this; return slice.call(arguments).forEach(function (iterable) { ES6.forOf(iterable, function (value) { self._values.push(value); }); }), self; }, SpreadOperatorImpl.prototype.add = function () { var self = this; return slice.call(arguments).forEach(function (value) { self._values.push(value); }), self; }, SpreadOperatorImpl.prototype.call = function (thisArg) { if ("function" != typeof this._target)
            throw new TypeError("Target is not a function"); return thisArg = arguments.length <= 0 ? this._thisArg : thisArg, this._target.apply(thisArg, this._values); }, SpreadOperatorImpl.prototype.new = function () { if ("function" != typeof this._target)
            throw new TypeError("Target is not a constructor"); var temp, returnValue; return temp = Object.create(this._target.prototype), returnValue = this._target.apply(temp, this._values), isObject(returnValue) ? returnValue : temp; }, SpreadOperatorImpl.prototype.array = function () { if (!isArray(this._target))
            throw new TypeError("Target is not a array"); return push.apply(this._target, this._values), this._target; };
        return defineProperties(ES6, { isSymbol: { value: function (symbol) { return symbol instanceof Symbol && function (symbol) { return !0 === symbol._isSymbol && "number" == typeof symbol._id && "string" == typeof symbol._description; }(symbol); }, writable: !0, configurable: !0 }, instanceOf: { value: function (object, constructor) { if (!isObject(constructor))
                    throw new TypeError("Right-hand side of 'instanceof' is not an object"); var hasInstanceSymbolProp = constructor[Symbol.hasInstance]; if (void 0 === hasInstanceSymbolProp)
                    return object instanceof constructor; if ("function" != typeof hasInstanceSymbolProp)
                    throw new TypeError(typeof hasInstanceSymbolProp + " is not a function"); return hasInstanceSymbolProp.call(constructor, object); }, writable: !0, configurable: !0 }, forOf: { value: function (iterable, callback, thisArg) { if (callback = "function" != typeof callback ? emptyFunction : callback, "function" != typeof iterable[Symbol.iterator])
                    throw new TypeError("Iterable[Symbol.iterator] is not a function"); var iterationResult, iterator = iterable[Symbol.iterator](); if ("function" != typeof iterator.next)
                    throw new TypeError(".iterator.next is not a function"); for (;;) {
                    if (iterationResult = iterator.next(), !isObject(iterationResult))
                        throw new TypeError("Iterator result " + iterationResult + " is not an object");
                    if (iterationResult.done)
                        break;
                    callback.call(thisArg, iterationResult.value);
                } }, writable: !0, configurable: !0 }, spreadOperator: { value: function (target, thisArg) { if ("function" != typeof target && !isArray(target))
                    throw new TypeError("Spread operator only supports on array and function objects at this moment"); return new SpreadOperatorImpl(target, thisArg); }, writable: !0, configurable: !0 } }), defineProperty(global, "Symbol", { value: Symbol, writable: !0, configurable: !0 }), defineProperty(Function.prototype, Symbol.hasInstance.toString(), { value: function (instance) { return "function" == typeof this && instance instanceof this; } }), defineProperty(Array.prototype, "concat", { value: function () { if (void 0 === this || null === this)
                throw new TypeError("Array.prototype.concat called on null or undefined"); var self = Object(this), targets = slice.call(arguments), outputs = []; return targets.unshift(self), targets.forEach(function (target) { isObject(target) ? void 0 !== target[Symbol.isConcatSpreadable] ? target[Symbol.isConcatSpreadable] ? appendArray(outputs, target) : outputs.push(target) : isArray(target) ? appendArray(outputs, target) : outputs.push(target) : outputs.push(target); }), outputs; }, writable: !0, configurable: !0 }), defineProperty(Object.prototype, "toString", { value: function () { return void 0 === this || null === this ? objectToString.call(this) : "string" == typeof this[Symbol.toStringTag] ? "[object " + this[Symbol.toStringTag] + "]" : objectToString.call(this); }, writable: !0, configurable: !0 }), defineProperty(Array.prototype, Symbol.iterator.toString(), { value: function () { if (void 0 === this || null === this)
                throw new TypeError("Cannot convert undefined or null to object"); var self = Object(this); return new ArrayIterator(self, 2); }, writable: !0, configurable: !0 }), defineProperty(Array, "from", { value: function (arrayLike, mapFn, thisArg) { var constructor, length, outputs, i = 0; if (constructor = isCallable(this) ? this : Array, void 0 === arrayLike || null === arrayLike)
                throw new TypeError("Cannot convert undefined or null to object"); if (arrayLike = Object(arrayLike), void 0 === mapFn)
                mapFn = simpleFunction;
            else if (!isCallable(mapFn))
                throw new TypeError(mapFn + " is not a function"); if (void 0 === arrayLike[Symbol.iterator]) {
                if (!("number" == typeof arrayLike.length && arrayLike.length >= 0))
                    return (outputs = new constructor(0)).length = 0, outputs;
                for (length = Math.floor(arrayLike.length), (outputs = new constructor(length)).length = length; i < length; ++i)
                    outputs[i] = mapFn.call(thisArg, arrayLike[i]);
            }
            else
                (outputs = new constructor).length = 0, ES6.forOf(arrayLike, function (value) { outputs.length++, outputs[outputs.length - 1] = mapFn.call(thisArg, value); }); return outputs; }, writable: !0, configurable: !0 }), defineProperty(Array.prototype, "entries", { value: function () { if (void 0 === this || null === this)
                throw new TypeError("Cannot convert undefined or null to object"); var self = Object(this); return new ArrayIterator(self, 1); }, writable: !0, configurable: !0 }), defineProperty(Array.prototype, "keys", { value: function () { if (void 0 === this || null === this)
                throw new TypeError("Cannot convert undefined or null to object"); var self = Object(this); return new ArrayIterator(self, 3); }, writable: !0, configurable: !0 }), defineProperty(String.prototype, Symbol.iterator.toString(), { value: function () { if (void 0 === this || null === this)
                throw new TypeError("String.prototype[Symbol.iterator] called on null or undefined"); return new StringIterator(String(this), 0); }, writable: !0, configurable: !0 }), ES6;
    });
    if (!String.prototype.normalize) {
        (function () {
            /* This table is of all characters in the range of U+0100 to U+2200 that
             * have a canonical decomposition in NFD form. For some characters, this
             * translates them into their canonical characters (e.g., K -> K). For
             * characters with combining diacritical marks, this leaves behind the base
             * character, removing its diacritics (e.g., É -> E).
             */
            var PARTIAL_NFD_LOOKUP = { "À": "A", "Á": "A", "Â": "A", "Ã": "A", "Ä": "A", "Å": "A", "Ç": "C",
                "È": "E", "É": "E", "Ê": "E", "Ë": "E", "Ì": "I", "Í": "I", "Î": "I", "Ï": "I",
                "Ñ": "N", "Ò": "O", "Ó": "O", "Ô": "O", "Õ": "O", "Ö": "O",
                "Ù": "U", "Ú": "U", "Û": "U", "Ü": "U", "Ý": "Y",
                "à": "a", "á": "a", "â": "a", "ã": "a", "ä": "a", "å": "a", "ç": "c",
                "è": "e", "é": "e", "ê": "e", "ë": "e", "ì": "i", "í": "i", "î": "i", "ï": "i",
                "ñ": "n", "ò": "o", "ó": "o", "ô": "o", "õ": "o", "ö": "o",
                "ù": "u", "ú": "u", "û": "u", "ü": "u", "ý": "y", "ÿ": "y",
                "Ā": "A", "ā": "a", "Ă": "A", "ă": "a", "Ą": "A", "ą": "a",
                "Ć": "C", "ć": "c", "Ĉ": "C", "ĉ": "c", "Ċ": "C", "ċ": "c", "Č": "C", "č": "c", "Ď": "D", "ď": "d",
                "Ē": "E", "ē": "e", "Ĕ": "E", "ĕ": "e", "Ė": "E", "ė": "e",
                "Ę": "E", "ę": "e", "Ě": "E", "ě": "e",
                "Ĝ": "G", "ĝ": "g", "Ğ": "G", "ğ": "g", "Ġ": "G", "ġ": "g", "Ģ": "G", "ģ": "g", "Ĥ": "H", "ĥ": "h",
                "Ĩ": "I", "ĩ": "i", "Ī": "I", "ī": "i", "Ĭ": "I", "ĭ": "i", "Į": "I", "į": "i", "İ": "I",
                "Ĵ": "J", "ĵ": "j", "Ķ": "K", "ķ": "k", "Ĺ": "L", "ĺ": "l", "Ļ": "L", "ļ": "l", "Ľ": "L", "ľ": "l",
                "Ń": "N", "ń": "n", "Ņ": "N", "ņ": "n", "Ň": "N", "ň": "n",
                "Ō": "O", "ō": "o", "Ŏ": "O", "ŏ": "o", "Ő": "O", "ő": "o",
                "Ŕ": "R", "ŕ": "r", "Ŗ": "R", "ŗ": "r", "Ř": "R", "ř": "r",
                "Ś": "S", "ś": "s", "Ŝ": "S", "ŝ": "s", "Ş": "S", "ş": "s", "Š": "S", "š": "s",
                "Ţ": "T", "ţ": "t", "Ť": "T", "ť": "t",
                "Ũ": "U", "ũ": "u", "Ū": "U", "ū": "u", "Ŭ": "U", "ŭ": "u", "Ů": "U", "ů": "u",
                "Ű": "U", "ű": "u", "Ų": "U", "ų": "u", "Ŵ": "W", "ŵ": "w",
                "Ŷ": "Y", "ŷ": "y", "Ÿ": "Y", "Ź": "Z", "ź": "z", "Ż": "Z", "ż": "z", "Ž": "Z", "ž": "z",
                "Ơ": "O", "ơ": "o", "Ư": "U", "ư": "u", "Ǎ": "A", "ǎ": "a", "Ǐ": "I", "ǐ": "i",
                "Ǒ": "O", "ǒ": "o", "Ǔ": "U", "ǔ": "u", "Ǖ": "U", "ǖ": "u", "Ǘ": "U", "ǘ": "u", "Ǚ": "U",
                "ǚ": "u", "Ǜ": "U", "ǜ": "u", "Ǟ": "A", "ǟ": "a", "Ǡ": "A", "ǡ": "a", "Ǣ": "Æ", "ǣ": "æ",
                "Ǧ": "G", "ǧ": "g", "Ǩ": "K", "ǩ": "k", "Ǫ": "O", "ǫ": "o", "Ǭ": "O", "ǭ": "o",
                "Ǯ": "Ʒ", "ǯ": "ʒ", "ǰ": "j", "Ǵ": "G", "ǵ": "g", "Ǹ": "N", "ǹ": "n",
                "Ǻ": "A", "ǻ": "a", "Ǽ": "Æ", "ǽ": "æ", "Ǿ": "Ø", "ǿ": "ø", "Ȁ": "A", "ȁ": "a", "Ȃ": "A", "ȃ": "a",
                "Ȅ": "E", "ȅ": "e", "Ȇ": "E", "ȇ": "e", "Ȉ": "I", "ȉ": "i", "Ȋ": "I", "ȋ": "i",
                "Ȍ": "O", "ȍ": "o", "Ȏ": "O", "ȏ": "o", "Ȑ": "R", "ȑ": "r", "Ȓ": "R", "ȓ": "r",
                "Ȕ": "U", "ȕ": "u", "Ȗ": "U", "ȗ": "u", "Ș": "S", "ș": "s", "Ț": "T", "ț": "t",
                "Ȟ": "H", "ȟ": "h", "Ȧ": "A", "ȧ": "a", "Ȩ": "E", "ȩ": "e",
                "Ȫ": "O", "ȫ": "o", "Ȭ": "O", "ȭ": "o", "Ȯ": "O", "ȯ": "o", "Ȱ": "O", "ȱ": "o",
                "Ȳ": "Y", "ȳ": "y", "̀": "̀", "́": "́", "̓": "̓", "̈́": "̈", "ʹ": "ʹ", ";": ";", "΅": "¨",
                "Ά": "Α", "·": "·", "Έ": "Ε", "Ή": "Η", "Ί": "Ι", "Ό": "Ο", "Ύ": "Υ", "Ώ": "Ω",
                "ΐ": "ι", "Ϊ": "Ι", "Ϋ": "Υ", "ά": "α", "έ": "ε", "ή": "η", "ί": "ι",
                "ϊ": "ι", "ϋ": "υ", "ό": "ο", "ύ": "υ", "ώ": "ω", "ϓ": "ϒ", "ϔ": "ϒ",
                "Ѐ": "Е", "Ё": "Е", "Ѓ": "Г", "Ї": "І", "Ќ": "К", "Ѝ": "И", "Ў": "У", "Й": "И", "й": "и",
                "ѐ": "е", "ё": "е", "ѓ": "г", "ї": "і", "ќ": "к", "ѝ": "и", "ў": "у", "Ѷ": "Ѵ", "ѷ": "ѵ",
                "Ӂ": "Ж", "ӂ": "ж", "Ӑ": "А", "ӑ": "а", "Ӓ": "А", "ӓ": "а",
                "Ӗ": "Е", "ӗ": "е", "Ӛ": "Ә", "ӛ": "ә", "Ӝ": "Ж", "ӝ": "ж", "Ӟ": "З", "ӟ": "з",
                "Ӣ": "И", "ӣ": "и", "Ӥ": "И", "ӥ": "и", "Ӧ": "О", "ӧ": "о", "Ӫ": "Ө", "ӫ": "ө",
                "Ӭ": "Э", "ӭ": "э", "Ӯ": "У", "ӯ": "у", "Ӱ": "У", "ӱ": "у", "Ӳ": "У", "ӳ": "у",
                "Ӵ": "Ч", "ӵ": "ч", "Ӹ": "Ы", "ӹ": "ы", "Ḁ": "A", "ḁ": "a",
                "Ḃ": "B", "ḃ": "b", "Ḅ": "B", "ḅ": "b", "Ḇ": "B", "ḇ": "b", "Ḉ": "C", "ḉ": "c",
                "Ḋ": "D", "ḋ": "d", "Ḍ": "D", "ḍ": "d", "Ḏ": "D", "ḏ": "d", "Ḑ": "D", "ḑ": "d", "Ḓ": "D", "ḓ": "d",
                "Ḕ": "E", "ḕ": "e", "Ḗ": "E", "ḗ": "e", "Ḙ": "E", "ḙ": "e", "Ḛ": "E", "ḛ": "e", "Ḝ": "E", "ḝ": "e",
                "Ḟ": "F", "ḟ": "f", "Ḡ": "G", "ḡ": "g", "Ḣ": "H", "ḣ": "h", "Ḥ": "H",
                "ḥ": "h", "Ḧ": "H", "ḧ": "h", "Ḩ": "H", "ḩ": "h", "Ḫ": "H", "ḫ": "h",
                "Ḭ": "I", "ḭ": "i", "Ḯ": "I", "ḯ": "i", "Ḱ": "K", "ḱ": "k", "Ḳ": "K", "ḳ": "k", "Ḵ": "K", "ḵ": "k",
                "Ḷ": "L", "ḷ": "l", "Ḹ": "L", "ḹ": "l", "Ḻ": "L", "ḻ": "l", "Ḽ": "L", "ḽ": "l",
                "Ḿ": "M", "ḿ": "m", "Ṁ": "M", "ṁ": "m", "Ṃ": "M", "ṃ": "m",
                "Ṅ": "N", "ṅ": "n", "Ṇ": "N", "ṇ": "n", "Ṉ": "N", "ṉ": "n", "Ṋ": "N", "ṋ": "n",
                "Ṍ": "O", "ṍ": "o", "Ṏ": "O", "ṏ": "o", "Ṑ": "O", "ṑ": "o", "Ṓ": "O", "ṓ": "o",
                "Ṕ": "P", "ṕ": "p", "Ṗ": "P", "ṗ": "p", "Ṙ": "R", "ṙ": "r", "Ṛ": "R",
                "ṛ": "r", "Ṝ": "R", "ṝ": "r", "Ṟ": "R", "ṟ": "r",
                "Ṡ": "S", "ṡ": "s", "Ṣ": "S", "ṣ": "s", "Ṥ": "S", "ṥ": "s", "Ṧ": "S", "ṧ": "s", "Ṩ": "S", "ṩ": "s",
                "Ṫ": "T", "ṫ": "t", "Ṭ": "T", "ṭ": "t", "Ṯ": "T", "ṯ": "t", "Ṱ": "T", "ṱ": "t",
                "Ṳ": "U", "ṳ": "u", "Ṵ": "U", "ṵ": "u", "Ṷ": "U", "ṷ": "u", "Ṹ": "U", "ṹ": "u", "Ṻ": "U", "ṻ": "u",
                "Ṽ": "V", "ṽ": "v", "Ṿ": "V", "ṿ": "v", "Ẁ": "W", "ẁ": "w", "Ẃ": "W",
                "ẃ": "w", "Ẅ": "W", "ẅ": "w", "Ẇ": "W", "ẇ": "w", "Ẉ": "W", "ẉ": "w",
                "Ẋ": "X", "ẋ": "x", "Ẍ": "X", "ẍ": "x", "Ẏ": "Y", "ẏ": "y",
                "Ẑ": "Z", "ẑ": "z", "Ẓ": "Z", "ẓ": "z", "Ẕ": "Z", "ẕ": "z",
                "ẖ": "h", "ẗ": "t", "ẘ": "w", "ẙ": "y", "ẛ": "ſ",
                "Ạ": "A", "ạ": "a", "Ả": "A", "ả": "a", "Ấ": "A", "ấ": "a", "Ầ": "A", "ầ": "a",
                "Ẩ": "A", "ẩ": "a", "Ẫ": "A", "ẫ": "a", "Ậ": "A", "ậ": "a", "Ắ": "A", "ắ": "a",
                "Ằ": "A", "ằ": "a", "Ẳ": "A", "ẳ": "a", "Ẵ": "A", "ẵ": "a", "Ặ": "A", "ặ": "a",
                "Ẹ": "E", "ẹ": "e", "Ẻ": "E", "ẻ": "e", "Ẽ": "E", "ẽ": "e", "Ế": "E", "ế": "e",
                "Ề": "E", "ề": "e", "Ể": "E", "ể": "e", "Ễ": "E", "ễ": "e", "Ệ": "E", "ệ": "e",
                "Ỉ": "I", "ỉ": "i", "Ị": "I", "ị": "i",
                "Ọ": "O", "ọ": "o", "Ỏ": "O", "ỏ": "o", "Ố": "O", "ố": "o", "Ồ": "O", "ồ": "o",
                "Ổ": "O", "ổ": "o", "Ỗ": "O", "ỗ": "o", "Ộ": "O", "ộ": "o", "Ớ": "O", "ớ": "o",
                "Ờ": "O", "ờ": "o", "Ở": "O", "ở": "o", "Ỡ": "O", "ỡ": "o", "Ợ": "O", "ợ": "o",
                "Ụ": "U", "ụ": "u", "Ủ": "U", "ủ": "u", "Ứ": "U", "ứ": "u", "Ừ": "U", "ừ": "u",
                "Ử": "U", "ử": "u", "Ữ": "U", "ữ": "u", "Ự": "U", "ự": "u",
                "Ỳ": "Y", "ỳ": "y", "Ỵ": "Y", "ỵ": "y", "Ỷ": "Y", "ỷ": "y", "Ỹ": "Y", "ỹ": "y",
                "ἀ": "α", "ἁ": "α", "ἂ": "α", "ἃ": "α", "ἄ": "α", "ἅ": "α", "ἆ": "α", "ἇ": "α",
                "Ἀ": "Α", "Ἁ": "Α", "Ἂ": "Α", "Ἃ": "Α", "Ἄ": "Α", "Ἅ": "Α", "Ἆ": "Α", "Ἇ": "Α",
                "ἐ": "ε", "ἑ": "ε", "ἒ": "ε", "ἓ": "ε", "ἔ": "ε", "ἕ": "ε", "Ἐ": "Ε", "Ἑ": "Ε",
                "Ἒ": "Ε", "Ἓ": "Ε", "Ἔ": "Ε", "Ἕ": "Ε",
                "ἠ": "η", "ἡ": "η", "ἢ": "η", "ἣ": "η", "ἤ": "η", "ἥ": "η", "ἦ": "η", "ἧ": "η",
                "Ἠ": "Η", "Ἡ": "Η", "Ἢ": "Η", "Ἣ": "Η", "Ἤ": "Η", "Ἥ": "Η", "Ἦ": "Η", "Ἧ": "Η",
                "ἰ": "ι", "ἱ": "ι", "ἲ": "ι", "ἳ": "ι", "ἴ": "ι", "ἵ": "ι", "ἶ": "ι", "ἷ": "ι",
                "Ἰ": "Ι", "Ἱ": "Ι", "Ἲ": "Ι", "Ἳ": "Ι", "Ἴ": "Ι", "Ἵ": "Ι", "Ἶ": "Ι", "Ἷ": "Ι",
                "ὀ": "ο", "ὁ": "ο", "ὂ": "ο", "ὃ": "ο", "ὄ": "ο", "ὅ": "ο", "Ὀ": "Ο", "Ὁ": "Ο",
                "Ὂ": "Ο", "Ὃ": "Ο", "Ὄ": "Ο", "Ὅ": "Ο",
                "ὐ": "υ", "ὑ": "υ", "ὒ": "υ", "ὓ": "υ", "ὔ": "υ", "ὕ": "υ", "ὖ": "υ", "ὗ": "υ",
                "Ὑ": "Υ", "Ὓ": "Υ", "Ὕ": "Υ", "Ὗ": "Υ",
                "ὠ": "ω", "ὡ": "ω", "ὢ": "ω", "ὣ": "ω", "ὤ": "ω", "ὥ": "ω", "ὦ": "ω", "ὧ": "ω",
                "Ὠ": "Ω", "Ὡ": "Ω", "Ὢ": "Ω", "Ὣ": "Ω", "Ὤ": "Ω", "Ὥ": "Ω", "Ὦ": "Ω", "Ὧ": "Ω",
                "ὰ": "α", "ὲ": "ε", "ὴ": "η", "ὶ": "ι", "ὸ": "ο", "ὺ": "υ", "ὼ": "ω",
                "ᾀ": "α", "ᾁ": "α", "ᾂ": "α", "ᾃ": "α", "ᾄ": "α", "ᾅ": "α", "ᾆ": "α", "ᾇ": "α",
                "ᾈ": "Α", "ᾉ": "Α", "ᾊ": "Α", "ᾋ": "Α", "ᾌ": "Α", "ᾍ": "Α", "ᾎ": "Α", "ᾏ": "Α",
                "ᾐ": "η", "ᾑ": "η", "ᾒ": "η", "ᾓ": "η", "ᾔ": "η", "ᾕ": "η", "ᾖ": "η", "ᾗ": "η",
                "ᾘ": "Η", "ᾙ": "Η", "ᾚ": "Η", "ᾛ": "Η", "ᾜ": "Η", "ᾝ": "Η", "ᾞ": "Η", "ᾟ": "Η",
                "ᾠ": "ω", "ᾡ": "ω", "ᾢ": "ω", "ᾣ": "ω", "ᾤ": "ω", "ᾥ": "ω", "ᾦ": "ω", "ᾧ": "ω",
                "ᾨ": "Ω", "ᾩ": "Ω", "ᾪ": "Ω", "ᾫ": "Ω", "ᾬ": "Ω", "ᾭ": "Ω", "ᾮ": "Ω", "ᾯ": "Ω",
                "ᾰ": "α", "ᾱ": "α", "ᾲ": "α", "ᾳ": "α", "ᾴ": "α", "ᾶ": "α", "ᾷ": "α",
                "Ᾰ": "Α", "Ᾱ": "Α", "Ὰ": "Α", "ᾼ": "Α",
                "ι": "ι", "῁": "¨", "ῂ": "η", "ῃ": "η", "ῄ": "η", "ῆ": "η", "ῇ": "η",
                "Ὲ": "Ε", "Ὴ": "Η", "ῌ": "Η", "῍": "᾿", "῎": "᾿", "῏": "᾿",
                "ῐ": "ι", "ῑ": "ι", "ῒ": "ι", "ῖ": "ι", "ῗ": "ι", "Ῐ": "Ι", "Ῑ": "Ι", "Ὶ": "Ι",
                "῝": "῾", "῞": "῾", "῟": "῾", "ῠ": "υ", "ῡ": "υ", "ῢ": "υ", "ΰ": "υ", "ῤ": "ρ", "ῥ": "ρ",
                "ῦ": "υ", "ῧ": "υ", "Ῠ": "Υ", "Ῡ": "Υ", "Ὺ": "Υ", "Ῥ": "Ρ",
                "῭": "¨", "`": "`", "ῲ": "ω", "ῳ": "ω", "ῴ": "ω", "ῶ": "ω", "ῷ": "ω",
                "Ὸ": "Ο", "Ὼ": "Ω", "ῼ": "Ω", "´": "´", " ": " ", " ": " ", "Ω": "Ω", "K": "K" };
            /* A VERY naive fill-in for the String.normalize function.
             * Mobile Safari only supports the function in iOS 10+, while
             * we currently support iOS 9.  (The last 32-bit iOS version)
             *
             * Note that this implementation assumes that all usage of String.normalize
             * is for use in wordform-keying operations common within the LMLayer.
             */
            String.prototype.normalize = function () {
                var chars = this.split('');
                return chars.map(function (c) {
                    if (c in PARTIAL_NFD_LOOKUP) {
                        return PARTIAL_NFD_LOOKUP[c];
                    }
                    return c;
                }).join('');
            };
        })();
    }
    //Autogenerated file - do not modify!
    var com;
    (function (com) {
        var keyman;
        (function (keyman) {
            var environment;
            (function (environment) {
                environment.VERSION = "15.0";
                environment.BUILD = 163;
                environment.ENVIRONMENT = "local";
                environment.SENTRY_RELEASE = "release-15.0.163-alpha-local";
            })(environment = keyman.environment || (keyman.environment = {}));
        })(keyman = com.keyman || (com.keyman = {}));
    })(com || (com = {}));
    var com;
    (function (com) {
        var keyman;
        (function (keyman) {
            var utils;
            (function (utils) {
                /**
                 * Function     deepCopy
                 * Scope        Private
                 * @param       {Object}      p           object to copy
                 * @param       {Array=}      c0          array member being copied
                 * @return      {Object}                  clone ('deep copy') of object
                 * Description  Makes an actual copy (not a reference) of an object, copying simple members,
                 *              arrays and member objects but not functions, so use with care!
                 */
                function deepCopy(p, c0) {
                    var c = c0 || {};
                    for (var i in p) {
                        if (typeof p[i] === 'object' && p[i] != null) {
                            c[i] = (p[i].constructor === Array) ? [] : {};
                            deepCopy(p[i], c[i]);
                        }
                        else {
                            c[i] = p[i];
                        }
                    }
                    return c;
                }
                utils.deepCopy = deepCopy;
            })(utils = keyman.utils || (keyman.utils = {}));
        })(keyman = com.keyman || (com.keyman = {}));
    })(com || (com = {}));
    var com;
    (function (com) {
        var keyman;
        (function (keyman) {
            var utils;
            (function (utils) {
                /**
                 * Returns the base global object available to the current JS platform.
                 * - In browsers, returns `window`.
                 * - In WebWorkers, returns `self`.
                 * - In Node, returns `global`.
                 */
                function getGlobalObject() {
                    // Evergreen browsers have started defining 'globalThis'.  
                    // Refer to https://devblogs.microsoft.com/typescript/announcing-typescript-3-4/#type-checking-for-globalthis
                    // and its referenced polyfill.  Said polyfill is very complex, so we opt for this far leaner variant.
                    if (typeof globalThis != 'undefined') {
                        return globalThis; // Not available in IE or older Edge versions
                        // @ts-ignore (TS will throw errors for whatever platform we're not compiling for.)
                    }
                    else if (typeof window != 'undefined') {
                        // @ts-ignore
                        return window; // The browser-based classic
                        // @ts-ignore
                    }
                    else if (typeof self != 'undefined') {
                        // @ts-ignore
                        return self; // WebWorker global
                    }
                    else {
                        // Assumption - if neither of the above exist, we're in Node, for unit-testing.
                        // Node doesn't have as many methods and properties as the other two, but what 
                        // matters for us is that it's the base global.
                        //
                        // Some other headless JS solutions use 'this' instead, but Node's enough for our needs.
                        // @ts-ignore
                        return global;
                    }
                }
                utils.getGlobalObject = getGlobalObject;
            })(utils = keyman.utils || (keyman.utils = {}));
        })(keyman = com.keyman || (com.keyman = {}));
    })(com || (com = {}));
    // Ensure that this class contains no reference into core KMW code - it is referenced
    // by components intended to be modular and possible to separate from core KMW.
    var com;
    (function (com) {
        var keyman;
        (function (keyman) {
            var utils;
            (function (utils) {
                // Dotted-decimal version
                var Version = /** @class */ (function () {
                    /**
                     * Parses version information, preparing it for use in comparisons.
                     * @param text Either a string representing a version number (ex: "9.0.0") or an array representing
                     *             its components (ex: [9, 0, 0]).
                     */
                    function Version(text) {
                        // If a keyboard doesn't specify a version, use the DEVELOPER_VERSION_FALLBACK values.
                        if (text === undefined || text === null) {
                            this.components = [].concat(Version.DEVELOPER_VERSION_FALLBACK.components);
                            return;
                        }
                        if (Array.isArray(text)) {
                            var components = text;
                            if (components.length < 2) {
                                throw new Error("Version string must have at least a major and minor component!");
                            }
                            else {
                                this.components = [].concat(components);
                                return;
                            }
                        }
                        // else, standard constructor path.
                        var parts = text.split('.');
                        var componentArray = [];
                        if (parts.length < 2) {
                            throw new Error("Version string must have at least a major and minor component!");
                        }
                        for (var i = 0; i < parts.length; i++) {
                            var value = parseInt(parts[i], 10);
                            if (isNaN(value)) {
                                throw new Error("Version string components must be numerical!");
                            }
                            componentArray.push(value);
                        }
                        this.components = componentArray;
                    }
                    Object.defineProperty(Version.prototype, "major", {
                        get: function () {
                            return this.components[0];
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Version.prototype, "minor", {
                        get: function () {
                            return this.components[1];
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Version.prototype.toString = function () {
                        return this.components.join('.');
                    };
                    Version.prototype.toJSON = function () {
                        return this.toString();
                    };
                    Version.prototype.equals = function (other) {
                        return this.compareTo(other) == 0;
                    };
                    Version.prototype.precedes = function (other) {
                        return this.compareTo(other) < 0;
                    };
                    Version.prototype.compareTo = function (other) {
                        // If the version info depth differs, we need a flag to indicate which instance is shorter.
                        var isShorter = this.components.length < other.components.length;
                        var maxDepth = (this.components.length < other.components.length) ? this.components.length : other.components.length;
                        var i;
                        for (i = 0; i < maxDepth; i++) {
                            var delta = this.components[i] - other.components[i];
                            if (delta != 0) {
                                return delta;
                            }
                        }
                        var longList = isShorter ? other.components : this.components;
                        do {
                            if (longList[i] > 0) {
                                return isShorter ? -1 : 1;
                            }
                            i++;
                        } while (i < longList.length);
                        // Equal.
                        return 0;
                    };
                    Version.CURRENT = new Version(com.keyman.environment.VERSION);
                    // Represents a default version value for keyboards compiled before this was compiled into keyboards.
                    // The exact version is unknown at this point, but the value is "good enough" for what we need.
                    Version.DEVELOPER_VERSION_FALLBACK = new Version([9, 0, 0]);
                    // For 12.0, the old default behavior of adding missing keycaps to the default layers was removed,
                    // as it results in unexpected, bug-like behavior for keyboard designers when it is unwanted.
                    Version.NO_DEFAULT_KEYCAPS = new Version([12, 0]);
                    Version.MAC_POSSIBLE_IPAD_ALIAS = new Version([10, 15]);
                    return Version;
                }());
                utils.Version = Version;
            })(utils = keyman.utils || (keyman.utils = {}));
        })(keyman = com.keyman || (com.keyman = {}));
    })(com || (com = {}));
    /***
       KeymanWeb 14.0
       Copyright 2020 SIL International
    ***/
    /**
     * Constructs a string from one or more Unicode character codepoint values
     * passed as integer parameters.
     *
     * @param  {number} cp0,...   1 or more Unicode codepoints, e.g. 0x0065, 0x10000
     * @return {string|null}      The new String object.
     */
    String.kmwFromCharCode = function (cp0) {
        var chars = [], i;
        for (i = 0; i < arguments.length; i++) {
            var c = Number(arguments[i]);
            if (!isFinite(c) || c < 0 || c > 0x10FFFF || Math.floor(c) !== c) {
                throw new RangeError("Invalid code point " + c);
            }
            if (c < 0x10000) {
                chars.push(c);
            }
            else {
                c -= 0x10000;
                chars.push((c >> 10) + 0xD800);
                chars.push((c % 0x400) + 0xDC00);
            }
        }
        return String.fromCharCode.apply(undefined, chars);
    };
    /**
     * Returns a number indicating the Unicode value of the character at the given
     * code point index, with support for supplementary plane characters.
     *
     * @param  {number}  codePointIndex  The code point index into the string (not
                                         the code unit index) to return
     * @return {number}                  The Unicode character value
     */
    String.prototype.kmwCharCodeAt = function (codePointIndex) {
        var str = String(this);
        var codeUnitIndex = 0;
        if (codePointIndex < 0 || codePointIndex >= str.length) {
            return NaN;
        }
        for (var i = 0; i < codePointIndex; i++) {
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
            if (codeUnitIndex === null)
                return NaN;
        }
        var first = str.charCodeAt(codeUnitIndex);
        if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
            var second = str.charCodeAt(codeUnitIndex + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;
            }
        }
        return first;
    };
    /**
     * Returns the code point index within the calling String object of the first occurrence
     * of the specified value, or -1 if not found.
     *
     * @param  {string}  searchValue    The value to search for
     * @param  {number}  [fromIndex]    Optional code point index to start searching from
     * @return {number}                 The code point index of the specified search value
     */
    String.prototype.kmwIndexOf = function (searchValue, fromIndex) {
        var str = String(this);
        var codeUnitIndex = str.indexOf(searchValue, fromIndex);
        if (codeUnitIndex < 0) {
            return codeUnitIndex;
        }
        var codePointIndex = 0;
        for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
            codePointIndex++;
        return codePointIndex;
    };
    /**
     * Returns the code point index within the calling String object of the last occurrence
     * of the specified value, or -1 if not found.
     *
     * @param  {string}  searchValue    The value to search for
     * @param  {number}  fromIndex      Optional code point index to start searching from
     * @return {number}                 The code point index of the specified search value
     */
    String.prototype.kmwLastIndexOf = function (searchValue, fromIndex) {
        var str = String(this);
        var codeUnitIndex = str.lastIndexOf(searchValue, fromIndex);
        if (codeUnitIndex < 0) {
            return codeUnitIndex;
        }
        var codePointIndex = 0;
        for (var i = 0; i !== null && i < codeUnitIndex; i = str.kmwNextChar(i))
            codePointIndex++;
        return codePointIndex;
    };
    /**
     * Returns the length of the string in code points, as opposed to code units.
     *
     * @return {number}                 The length of the string in code points
     */
    String.prototype.kmwLength = function () {
        var str = String(this);
        if (str.length == 0)
            return 0;
        for (var i = 0, codeUnitIndex = 0; codeUnitIndex !== null; i++)
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        return i;
    };
    /**
     * Extracts a section of a string and returns a new string.
     *
     * @param  {number}  beginSlice    The start code point index in the string to
     *                                 extract from
     * @param  {number}  endSlice      Optional end code point index in the string
     *                                 to extract to
     * @return {string}                The substring as selected by beginSlice and
     *                                 endSlice
     */
    String.prototype.kmwSlice = function (beginSlice, endSlice) {
        var str = String(this);
        var beginSliceCodeUnit = str.kmwCodePointToCodeUnit(beginSlice);
        var endSliceCodeUnit = str.kmwCodePointToCodeUnit(endSlice);
        if (beginSliceCodeUnit === null || endSliceCodeUnit === null)
            return '';
        else
            return str.slice(beginSliceCodeUnit, endSliceCodeUnit);
    };
    /**
     * Returns the characters in a string beginning at the specified location through
     * the specified number of characters.
     *
     * @param  {number}  start         The start code point index in the string to
     *                                 extract from
     * @param  {number=}  length        Optional length to extract
     * @return {string}                The substring as selected by start and length
     */
    String.prototype.kmwSubstr = function (start, length) {
        var str = String(this);
        if (start < 0) {
            start = str.kmwLength() + start;
        }
        if (start < 0)
            start = 0;
        var startCodeUnit = str.kmwCodePointToCodeUnit(start);
        var endCodeUnit = startCodeUnit;
        if (startCodeUnit === null)
            return '';
        if (arguments.length < 2) {
            endCodeUnit = str.length;
        }
        else {
            for (var i = 0; i < length; i++)
                endCodeUnit = str.kmwNextChar(endCodeUnit);
        }
        if (endCodeUnit === null)
            return str.substring(startCodeUnit);
        else
            return str.substring(startCodeUnit, endCodeUnit);
    };
    /**
     * Returns the characters in a string between two indexes into the string.
     *
     * @param  {number}  indexA        The start code point index in the string to
     *                                 extract from
     * @param  {number}  indexB        The end code point index in the string to
     *                                 extract to
     * @return {string}                The substring as selected by indexA and indexB
     */
    String.prototype.kmwSubstring = function (indexA, indexB) {
        var str = String(this), indexACodeUnit, indexBCodeUnit;
        if (typeof (indexB) == 'undefined') {
            indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
            indexBCodeUnit = str.length;
        }
        else {
            if (indexA > indexB) {
                var c = indexA;
                indexA = indexB;
                indexB = c;
            }
            indexACodeUnit = str.kmwCodePointToCodeUnit(indexA);
            indexBCodeUnit = str.kmwCodePointToCodeUnit(indexB);
        }
        if (isNaN(indexACodeUnit) || indexACodeUnit === null)
            indexACodeUnit = 0;
        if (isNaN(indexBCodeUnit) || indexBCodeUnit === null)
            indexBCodeUnit = str.length;
        return str.substring(indexACodeUnit, indexBCodeUnit);
    };
    /*
      Helper functions
    */
    /**
     * Returns the code unit index for the next code point in the string, accounting for
     * supplementary pairs
     *
     * @param  {number|null}  codeUnitIndex  The code unit position to increment
     * @return {number|null}                 The index of the next code point in the string,
     *                                       in code units
     */
    String.prototype.kmwNextChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex === null || codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
            return null;
        }
        var first = str.charCodeAt(codeUnitIndex);
        if (first >= 0xD800 && first <= 0xDBFF && str.length > codeUnitIndex + 1) {
            var second = str.charCodeAt(codeUnitIndex + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) {
                if (codeUnitIndex == str.length - 2) {
                    return null;
                }
                return codeUnitIndex + 2;
            }
        }
        return codeUnitIndex + 1;
    };
    /**
     * Returns the code unit index for the previous code point in the string, accounting
     * for supplementary pairs
     *
     * @param  {number|null}  codeUnitIndex  The code unit position to decrement
     * @return {number|null}                 The index of the previous code point in the
     *                                       string, in code units
    */
    String.prototype.kmwPrevChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex == null || codeUnitIndex <= 0 || codeUnitIndex > str.length) {
            return null;
        }
        var second = str.charCodeAt(codeUnitIndex - 1);
        if (second >= 0xDC00 && second <= 0xDFFF && codeUnitIndex > 1) {
            var first = str.charCodeAt(codeUnitIndex - 2);
            if (first >= 0xD800 && first <= 0xDBFF) {
                return codeUnitIndex - 2;
            }
        }
        return codeUnitIndex - 1;
    };
    /**
     * Returns the corresponding code unit index to the code point index passed
     *
     * @param  {number|null} codePointIndex  A code point index in the string
     * @return {number|null}                 The corresponding code unit index
     */
    String.prototype.kmwCodePointToCodeUnit = function (codePointIndex) {
        if (codePointIndex === null)
            return null;
        var str = String(this);
        var codeUnitIndex = 0;
        if (codePointIndex < 0) {
            codeUnitIndex = str.length;
            for (var i = 0; i > codePointIndex; i--)
                codeUnitIndex = str.kmwPrevChar(codeUnitIndex);
            return codeUnitIndex;
        }
        if (codePointIndex == str.kmwLength())
            return str.length;
        for (var i = 0; i < codePointIndex; i++)
            codeUnitIndex = str.kmwNextChar(codeUnitIndex);
        return codeUnitIndex;
    };
    /**
     * Returns the corresponding code point index to the code unit index passed
     *
     * @param  {number|null}  codeUnitIndex  A code unit index in the string
     * @return {number|null}                 The corresponding code point index
     */
    String.prototype.kmwCodeUnitToCodePoint = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex === null)
            return null;
        else if (codeUnitIndex == 0)
            return 0;
        else if (codeUnitIndex < 0)
            return str.substr(codeUnitIndex).kmwLength();
        else
            return str.substr(0, codeUnitIndex).kmwLength();
    };
    /**
     * Returns the character at a the code point index passed
     *
     * @param  {number}  codePointIndex  A code point index in the string
     * @return {string}                  The corresponding character
     */
    String.prototype.kmwCharAt = function (codePointIndex) {
        var str = String(this);
        if (codePointIndex >= 0)
            return str.kmwSubstr(codePointIndex, 1);
        else
            return '';
    };
    /**
     * String prototype library extensions for basic plane characters,
     * to simplify enabling or disabling supplementary plane functionality (I3319)
     */
    /**
     * Returns the code unit index for the next code point in the string
     *
     * @param  {number}  codeUnitIndex    A code point index in the string
     * @return {number|null}                   The corresponding character
     */
    String.prototype.kmwBMPNextChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex < 0 || codeUnitIndex >= str.length - 1) {
            return null;
        }
        return codeUnitIndex + 1;
    };
    /**
     * Returns the code unit index for the previous code point in the string
     *
     * @param  {number}  codeUnitIndex    A code unit index in the string
     * @return {number|null}                   The corresponding character
     */
    String.prototype.kmwBMPPrevChar = function (codeUnitIndex) {
        var str = String(this);
        if (codeUnitIndex <= 0 || codeUnitIndex > str.length) {
            return null;
        }
        return codeUnitIndex - 1;
    };
    /**
     * Returns the code unit index for a code point index
     *
     * @param  {number}  codePointIndex   A code point index in the string
     * @return {number}                   The corresponding character
     */
    String.prototype.kmwBMPCodePointToCodeUnit = function (codePointIndex) {
        return codePointIndex;
    };
    /**
     * Returns the code point index for a code unit index
     *
     * @param  {number}  codeUnitIndex    A code point index in the string
     * @return {number}                   The corresponding character
     */
    String.prototype.kmwBMPCodeUnitToCodePoint = function (codeUnitIndex) {
        return codeUnitIndex;
    };
    /**
     * Returns the length of a BMP string
     *
     * @return {number}                   The length in code points
     */
    String.prototype.kmwBMPLength = function () {
        var str = String(this);
        return str.length;
    };
    /**
     * Returns a substring
     *
     * @param  {number}  n
     * @param  {number=}  ln
     * @return {string}
     */
    String.prototype.kmwBMPSubstr = function (n, ln) {
        var str = String(this);
        if (n > -1)
            return str.substr(n, ln);
        else
            return str.substr(str.length + n, -n);
    };
    /**
     * Enable or disable supplementary plane string handling
     *
     * @param  {boolean}  bEnable
     */
    String.kmwEnableSupplementaryPlane = function (bEnable) {
        var p = String.prototype;
        String._kmwFromCharCode = bEnable ? String.kmwFromCharCode : String.fromCharCode;
        p._kmwCharAt = bEnable ? p.kmwCharAt : p.charAt;
        p._kmwCharCodeAt = bEnable ? p.kmwCharCodeAt : p.charCodeAt;
        p._kmwIndexOf = bEnable ? p.kmwIndexOf : p.indexOf;
        p._kmwLastIndexOf = bEnable ? p.kmwLastIndexOf : p.lastIndexOf;
        p._kmwSlice = bEnable ? p.kmwSlice : p.slice;
        p._kmwSubstring = bEnable ? p.kmwSubstring : p.substring;
        p._kmwSubstr = bEnable ? p.kmwSubstr : p.kmwBMPSubstr;
        p._kmwLength = bEnable ? p.kmwLength : p.kmwBMPLength;
        p._kmwNextChar = bEnable ? p.kmwNextChar : p.kmwBMPNextChar;
        p._kmwPrevChar = bEnable ? p.kmwPrevChar : p.kmwBMPPrevChar;
        p._kmwCodePointToCodeUnit = bEnable ? p.kmwCodePointToCodeUnit : p.kmwBMPCodePointToCodeUnit;
        p._kmwCodeUnitToCodePoint = bEnable ? p.kmwCodeUnitToCodePoint : p.kmwBMPCodeUnitToCodePoint;
    };
    var com;
    (function (com) {
        var keyman;
        (function (keyman) {
            var utils;
            (function (utils) {
                var Browser;
                (function (Browser) {
                    Browser["Chrome"] = "chrome";
                    Browser["Edge"] = "edge";
                    Browser["Firefox"] = "firefox";
                    Browser["Native"] = "native";
                    Browser["Opera"] = "opera";
                    Browser["Safari"] = "safari";
                    Browser["Other"] = "other";
                })(Browser = utils.Browser || (utils.Browser = {}));
                var OperatingSystem;
                (function (OperatingSystem) {
                    OperatingSystem["Windows"] = "windows";
                    OperatingSystem["macOS"] = "macosx";
                    OperatingSystem["Linux"] = "linux";
                    OperatingSystem["Android"] = "android";
                    OperatingSystem["iOS"] = "ios";
                    OperatingSystem["Other"] = "other";
                })(OperatingSystem = utils.OperatingSystem || (utils.OperatingSystem = {}));
                var FormFactor;
                (function (FormFactor) {
                    FormFactor["Desktop"] = "desktop";
                    FormFactor["Phone"] = "phone";
                    FormFactor["Tablet"] = "tablet";
                })(FormFactor = utils.FormFactor || (utils.FormFactor = {}));
                /**
                 * This class provides an abstract version of com.keyman.Device that is core-friendly,
                 * containing only the information needed by web-core for text processing use, devoid
                 * of any direct references to the DOM.
                 */
                var DeviceSpec = /** @class */ (function () {
                    function DeviceSpec(browser, formFactor, OS, touchable) {
                        switch (browser.toLowerCase()) {
                            case Browser.Chrome:
                            case Browser.Edge:
                            case Browser.Firefox:
                            case Browser.Native:
                            case Browser.Opera:
                            case Browser.Safari:
                                this.browser = browser.toLowerCase();
                                break;
                            default:
                                this.browser = Browser.Other;
                        }
                        switch (formFactor.toLowerCase()) {
                            case FormFactor.Desktop:
                            case FormFactor.Phone:
                            case FormFactor.Tablet:
                                this.formFactor = formFactor.toLowerCase();
                                break;
                            default:
                                throw ("Invalid form factor specified for device: " + formFactor);
                        }
                        switch (OS.toLowerCase()) {
                            case OperatingSystem.Windows.toLowerCase():
                            case OperatingSystem.macOS.toLowerCase():
                            case OperatingSystem.Linux.toLowerCase():
                            case OperatingSystem.Android.toLowerCase():
                            case OperatingSystem.iOS.toLowerCase():
                                this.OS = OS.toLowerCase();
                                break;
                            default:
                                this.OS = OperatingSystem.Other;
                        }
                        this.touchable = touchable;
                    }
                    return DeviceSpec;
                }());
                utils.DeviceSpec = DeviceSpec;
            })(utils = keyman.utils || (keyman.utils = {}));
        })(keyman = com.keyman || (com.keyman = {}));
    })(com || (com = {}));
    // References all utility includes from a single file, making import/export simple.
    ///<reference path="deepCopy.ts" />
    ///<reference path="globalObject.ts" />
    ///<reference path="version.ts" />
    ///<reference path="kmwstring.ts" />
    ///<reference path="deviceSpec.ts" />
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var __values = (this && this.__values) || function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var models;
    (function (models) {
        /**
         * @file dummy-model.ts
         *
         * Defines the Dummy model, which is used for testing the
         * prediction API exclusively.
         */
        /**
         * The Dummy Model that returns nonsensical, but predictable results.
         */
        var DummyModel = /** @class */ (function () {
            function DummyModel(options) {
                options = options || {};
                // Create a shallow copy of the suggestions;
                // this class mutates the array.
                this._futureSuggestions = options.futureSuggestions
                    ? options.futureSuggestions.slice() : [];
                if (options.punctuation) {
                    this.punctuation = options.punctuation;
                }
            }
            DummyModel.prototype.configure = function (capabilities) {
                this.configuration = {
                    leftContextCodePoints: capabilities.maxLeftContextCodePoints,
                    rightContextCodePoints: capabilities.maxRightContextCodePoints
                };
                return this.configuration;
            };
            DummyModel.prototype.predict = function (transform, context, injectedSuggestions) {
                var makeUniformDistribution = function (suggestions) {
                    var e_1, _a;
                    var distribution = [];
                    var n = suggestions.length;
                    try {
                        for (var suggestions_1 = __values(suggestions), suggestions_1_1 = suggestions_1.next(); !suggestions_1_1.done; suggestions_1_1 = suggestions_1.next()) {
                            var s = suggestions_1_1.value;
                            distribution.push({ sample: s, p: 1 }); // For a dummy model, this is sufficient.  The uniformness is all that matters.
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (suggestions_1_1 && !suggestions_1_1.done && (_a = suggestions_1.return))
                                _a.call(suggestions_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    return distribution;
                };
                if (injectedSuggestions) {
                    return makeUniformDistribution(injectedSuggestions);
                }
                var currentSet = this._futureSuggestions.shift();
                if (!currentSet) {
                    return [];
                }
                else {
                    return makeUniformDistribution(currentSet);
                }
            };
            return DummyModel;
        }());
        models.DummyModel = DummyModel;
        ;
    })(models || (models = {}));
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * Splits ASCII words.
         *
         * @param phrase
         */
        function ascii(phrase) {
            var matchWord = /[A-Za-z0-9']+/g;
            var words = [];
            var match;
            while ((match = matchWord.exec(phrase)) !== null) {
                words.push(new RegExpDerivedSpan(match[0], match.index));
            }
            return words;
        }
        wordBreakers.ascii = ascii;
        /**
         * A concrete span class that derives its properties from the result of
         * RegExp.exec() array.
         */
        var RegExpDerivedSpan = /** @class */ (function () {
            function RegExpDerivedSpan(text, start) {
                this.text = text;
                this.start = start;
            }
            Object.defineProperty(RegExpDerivedSpan.prototype, "length", {
                get: function () {
                    return this.text.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RegExpDerivedSpan.prototype, "end", {
                get: function () {
                    return this.start + this.text.length;
                },
                enumerable: true,
                configurable: true
            });
            return RegExpDerivedSpan;
        }());
    })(wordBreakers || (wordBreakers = {}));
    var wordBreakers;
    (function (wordBreakers) {
        var data;
        (function (data) {
            ;
            data.WORD_BREAK_PROPERTY = [
                [/*start*/ 0x0, 0 /* Other */],
                [/*start*/ 0xA, 1 /* LF */],
                [/*start*/ 0xB, 2 /* Newline */],
                [/*start*/ 0xD, 3 /* CR */],
                [/*start*/ 0xE, 0 /* Other */],
                [/*start*/ 0x20, 4 /* WSegSpace */],
                [/*start*/ 0x21, 0 /* Other */],
                [/*start*/ 0x22, 5 /* Double_Quote */],
                [/*start*/ 0x23, 0 /* Other */],
                [/*start*/ 0x27, 6 /* Single_Quote */],
                [/*start*/ 0x28, 0 /* Other */],
                [/*start*/ 0x2C, 7 /* MidNum */],
                [/*start*/ 0x2D, 0 /* Other */],
                [/*start*/ 0x2E, 8 /* MidNumLet */],
                [/*start*/ 0x2F, 0 /* Other */],
                [/*start*/ 0x30, 9 /* Numeric */],
                [/*start*/ 0x3A, 10 /* MidLetter */],
                [/*start*/ 0x3B, 7 /* MidNum */],
                [/*start*/ 0x3C, 0 /* Other */],
                [/*start*/ 0x41, 11 /* ALetter */],
                [/*start*/ 0x5B, 0 /* Other */],
                [/*start*/ 0x5F, 12 /* ExtendNumLet */],
                [/*start*/ 0x60, 0 /* Other */],
                [/*start*/ 0x61, 11 /* ALetter */],
                [/*start*/ 0x7B, 0 /* Other */],
                [/*start*/ 0x85, 2 /* Newline */],
                [/*start*/ 0x86, 0 /* Other */],
                [/*start*/ 0xAA, 11 /* ALetter */],
                [/*start*/ 0xAB, 0 /* Other */],
                [/*start*/ 0xAD, 13 /* Format */],
                [/*start*/ 0xAE, 0 /* Other */],
                [/*start*/ 0xB5, 11 /* ALetter */],
                [/*start*/ 0xB6, 0 /* Other */],
                [/*start*/ 0xB7, 10 /* MidLetter */],
                [/*start*/ 0xB8, 0 /* Other */],
                [/*start*/ 0xBA, 11 /* ALetter */],
                [/*start*/ 0xBB, 0 /* Other */],
                [/*start*/ 0xC0, 11 /* ALetter */],
                [/*start*/ 0xD7, 0 /* Other */],
                [/*start*/ 0xD8, 11 /* ALetter */],
                [/*start*/ 0xF7, 0 /* Other */],
                [/*start*/ 0xF8, 11 /* ALetter */],
                [/*start*/ 0x2D8, 0 /* Other */],
                [/*start*/ 0x2DE, 11 /* ALetter */],
                [/*start*/ 0x300, 14 /* Extend */],
                [/*start*/ 0x370, 11 /* ALetter */],
                [/*start*/ 0x375, 0 /* Other */],
                [/*start*/ 0x376, 11 /* ALetter */],
                [/*start*/ 0x378, 0 /* Other */],
                [/*start*/ 0x37A, 11 /* ALetter */],
                [/*start*/ 0x37E, 7 /* MidNum */],
                [/*start*/ 0x37F, 11 /* ALetter */],
                [/*start*/ 0x380, 0 /* Other */],
                [/*start*/ 0x386, 11 /* ALetter */],
                [/*start*/ 0x387, 10 /* MidLetter */],
                [/*start*/ 0x388, 11 /* ALetter */],
                [/*start*/ 0x38B, 0 /* Other */],
                [/*start*/ 0x38C, 11 /* ALetter */],
                [/*start*/ 0x38D, 0 /* Other */],
                [/*start*/ 0x38E, 11 /* ALetter */],
                [/*start*/ 0x3A2, 0 /* Other */],
                [/*start*/ 0x3A3, 11 /* ALetter */],
                [/*start*/ 0x3F6, 0 /* Other */],
                [/*start*/ 0x3F7, 11 /* ALetter */],
                [/*start*/ 0x482, 0 /* Other */],
                [/*start*/ 0x483, 14 /* Extend */],
                [/*start*/ 0x48A, 11 /* ALetter */],
                [/*start*/ 0x530, 0 /* Other */],
                [/*start*/ 0x531, 11 /* ALetter */],
                [/*start*/ 0x557, 0 /* Other */],
                [/*start*/ 0x559, 11 /* ALetter */],
                [/*start*/ 0x55D, 0 /* Other */],
                [/*start*/ 0x55E, 11 /* ALetter */],
                [/*start*/ 0x55F, 10 /* MidLetter */],
                [/*start*/ 0x560, 11 /* ALetter */],
                [/*start*/ 0x589, 7 /* MidNum */],
                [/*start*/ 0x58A, 11 /* ALetter */],
                [/*start*/ 0x58B, 0 /* Other */],
                [/*start*/ 0x591, 14 /* Extend */],
                [/*start*/ 0x5BE, 0 /* Other */],
                [/*start*/ 0x5BF, 14 /* Extend */],
                [/*start*/ 0x5C0, 0 /* Other */],
                [/*start*/ 0x5C1, 14 /* Extend */],
                [/*start*/ 0x5C3, 0 /* Other */],
                [/*start*/ 0x5C4, 14 /* Extend */],
                [/*start*/ 0x5C6, 0 /* Other */],
                [/*start*/ 0x5C7, 14 /* Extend */],
                [/*start*/ 0x5C8, 0 /* Other */],
                [/*start*/ 0x5D0, 15 /* Hebrew_Letter */],
                [/*start*/ 0x5EB, 0 /* Other */],
                [/*start*/ 0x5EF, 15 /* Hebrew_Letter */],
                [/*start*/ 0x5F3, 11 /* ALetter */],
                [/*start*/ 0x5F4, 10 /* MidLetter */],
                [/*start*/ 0x5F5, 0 /* Other */],
                [/*start*/ 0x600, 13 /* Format */],
                [/*start*/ 0x606, 0 /* Other */],
                [/*start*/ 0x60C, 7 /* MidNum */],
                [/*start*/ 0x60E, 0 /* Other */],
                [/*start*/ 0x610, 14 /* Extend */],
                [/*start*/ 0x61B, 0 /* Other */],
                [/*start*/ 0x61C, 13 /* Format */],
                [/*start*/ 0x61D, 0 /* Other */],
                [/*start*/ 0x620, 11 /* ALetter */],
                [/*start*/ 0x64B, 14 /* Extend */],
                [/*start*/ 0x660, 9 /* Numeric */],
                [/*start*/ 0x66A, 0 /* Other */],
                [/*start*/ 0x66B, 9 /* Numeric */],
                [/*start*/ 0x66C, 7 /* MidNum */],
                [/*start*/ 0x66D, 0 /* Other */],
                [/*start*/ 0x66E, 11 /* ALetter */],
                [/*start*/ 0x670, 14 /* Extend */],
                [/*start*/ 0x671, 11 /* ALetter */],
                [/*start*/ 0x6D4, 0 /* Other */],
                [/*start*/ 0x6D5, 11 /* ALetter */],
                [/*start*/ 0x6D6, 14 /* Extend */],
                [/*start*/ 0x6DD, 13 /* Format */],
                [/*start*/ 0x6DE, 0 /* Other */],
                [/*start*/ 0x6DF, 14 /* Extend */],
                [/*start*/ 0x6E5, 11 /* ALetter */],
                [/*start*/ 0x6E7, 14 /* Extend */],
                [/*start*/ 0x6E9, 0 /* Other */],
                [/*start*/ 0x6EA, 14 /* Extend */],
                [/*start*/ 0x6EE, 11 /* ALetter */],
                [/*start*/ 0x6F0, 9 /* Numeric */],
                [/*start*/ 0x6FA, 11 /* ALetter */],
                [/*start*/ 0x6FD, 0 /* Other */],
                [/*start*/ 0x6FF, 11 /* ALetter */],
                [/*start*/ 0x700, 0 /* Other */],
                [/*start*/ 0x70F, 13 /* Format */],
                [/*start*/ 0x710, 11 /* ALetter */],
                [/*start*/ 0x711, 14 /* Extend */],
                [/*start*/ 0x712, 11 /* ALetter */],
                [/*start*/ 0x730, 14 /* Extend */],
                [/*start*/ 0x74B, 0 /* Other */],
                [/*start*/ 0x74D, 11 /* ALetter */],
                [/*start*/ 0x7A6, 14 /* Extend */],
                [/*start*/ 0x7B1, 11 /* ALetter */],
                [/*start*/ 0x7B2, 0 /* Other */],
                [/*start*/ 0x7C0, 9 /* Numeric */],
                [/*start*/ 0x7CA, 11 /* ALetter */],
                [/*start*/ 0x7EB, 14 /* Extend */],
                [/*start*/ 0x7F4, 11 /* ALetter */],
                [/*start*/ 0x7F6, 0 /* Other */],
                [/*start*/ 0x7F8, 7 /* MidNum */],
                [/*start*/ 0x7F9, 0 /* Other */],
                [/*start*/ 0x7FA, 11 /* ALetter */],
                [/*start*/ 0x7FB, 0 /* Other */],
                [/*start*/ 0x7FD, 14 /* Extend */],
                [/*start*/ 0x7FE, 0 /* Other */],
                [/*start*/ 0x800, 11 /* ALetter */],
                [/*start*/ 0x816, 14 /* Extend */],
                [/*start*/ 0x81A, 11 /* ALetter */],
                [/*start*/ 0x81B, 14 /* Extend */],
                [/*start*/ 0x824, 11 /* ALetter */],
                [/*start*/ 0x825, 14 /* Extend */],
                [/*start*/ 0x828, 11 /* ALetter */],
                [/*start*/ 0x829, 14 /* Extend */],
                [/*start*/ 0x82E, 0 /* Other */],
                [/*start*/ 0x840, 11 /* ALetter */],
                [/*start*/ 0x859, 14 /* Extend */],
                [/*start*/ 0x85C, 0 /* Other */],
                [/*start*/ 0x860, 11 /* ALetter */],
                [/*start*/ 0x86B, 0 /* Other */],
                [/*start*/ 0x8A0, 11 /* ALetter */],
                [/*start*/ 0x8B5, 0 /* Other */],
                [/*start*/ 0x8B6, 11 /* ALetter */],
                [/*start*/ 0x8C8, 0 /* Other */],
                [/*start*/ 0x8D3, 14 /* Extend */],
                [/*start*/ 0x8E2, 13 /* Format */],
                [/*start*/ 0x8E3, 14 /* Extend */],
                [/*start*/ 0x904, 11 /* ALetter */],
                [/*start*/ 0x93A, 14 /* Extend */],
                [/*start*/ 0x93D, 11 /* ALetter */],
                [/*start*/ 0x93E, 14 /* Extend */],
                [/*start*/ 0x950, 11 /* ALetter */],
                [/*start*/ 0x951, 14 /* Extend */],
                [/*start*/ 0x958, 11 /* ALetter */],
                [/*start*/ 0x962, 14 /* Extend */],
                [/*start*/ 0x964, 0 /* Other */],
                [/*start*/ 0x966, 9 /* Numeric */],
                [/*start*/ 0x970, 0 /* Other */],
                [/*start*/ 0x971, 11 /* ALetter */],
                [/*start*/ 0x981, 14 /* Extend */],
                [/*start*/ 0x984, 0 /* Other */],
                [/*start*/ 0x985, 11 /* ALetter */],
                [/*start*/ 0x98D, 0 /* Other */],
                [/*start*/ 0x98F, 11 /* ALetter */],
                [/*start*/ 0x991, 0 /* Other */],
                [/*start*/ 0x993, 11 /* ALetter */],
                [/*start*/ 0x9A9, 0 /* Other */],
                [/*start*/ 0x9AA, 11 /* ALetter */],
                [/*start*/ 0x9B1, 0 /* Other */],
                [/*start*/ 0x9B2, 11 /* ALetter */],
                [/*start*/ 0x9B3, 0 /* Other */],
                [/*start*/ 0x9B6, 11 /* ALetter */],
                [/*start*/ 0x9BA, 0 /* Other */],
                [/*start*/ 0x9BC, 14 /* Extend */],
                [/*start*/ 0x9BD, 11 /* ALetter */],
                [/*start*/ 0x9BE, 14 /* Extend */],
                [/*start*/ 0x9C5, 0 /* Other */],
                [/*start*/ 0x9C7, 14 /* Extend */],
                [/*start*/ 0x9C9, 0 /* Other */],
                [/*start*/ 0x9CB, 14 /* Extend */],
                [/*start*/ 0x9CE, 11 /* ALetter */],
                [/*start*/ 0x9CF, 0 /* Other */],
                [/*start*/ 0x9D7, 14 /* Extend */],
                [/*start*/ 0x9D8, 0 /* Other */],
                [/*start*/ 0x9DC, 11 /* ALetter */],
                [/*start*/ 0x9DE, 0 /* Other */],
                [/*start*/ 0x9DF, 11 /* ALetter */],
                [/*start*/ 0x9E2, 14 /* Extend */],
                [/*start*/ 0x9E4, 0 /* Other */],
                [/*start*/ 0x9E6, 9 /* Numeric */],
                [/*start*/ 0x9F0, 11 /* ALetter */],
                [/*start*/ 0x9F2, 0 /* Other */],
                [/*start*/ 0x9FC, 11 /* ALetter */],
                [/*start*/ 0x9FD, 0 /* Other */],
                [/*start*/ 0x9FE, 14 /* Extend */],
                [/*start*/ 0x9FF, 0 /* Other */],
                [/*start*/ 0xA01, 14 /* Extend */],
                [/*start*/ 0xA04, 0 /* Other */],
                [/*start*/ 0xA05, 11 /* ALetter */],
                [/*start*/ 0xA0B, 0 /* Other */],
                [/*start*/ 0xA0F, 11 /* ALetter */],
                [/*start*/ 0xA11, 0 /* Other */],
                [/*start*/ 0xA13, 11 /* ALetter */],
                [/*start*/ 0xA29, 0 /* Other */],
                [/*start*/ 0xA2A, 11 /* ALetter */],
                [/*start*/ 0xA31, 0 /* Other */],
                [/*start*/ 0xA32, 11 /* ALetter */],
                [/*start*/ 0xA34, 0 /* Other */],
                [/*start*/ 0xA35, 11 /* ALetter */],
                [/*start*/ 0xA37, 0 /* Other */],
                [/*start*/ 0xA38, 11 /* ALetter */],
                [/*start*/ 0xA3A, 0 /* Other */],
                [/*start*/ 0xA3C, 14 /* Extend */],
                [/*start*/ 0xA3D, 0 /* Other */],
                [/*start*/ 0xA3E, 14 /* Extend */],
                [/*start*/ 0xA43, 0 /* Other */],
                [/*start*/ 0xA47, 14 /* Extend */],
                [/*start*/ 0xA49, 0 /* Other */],
                [/*start*/ 0xA4B, 14 /* Extend */],
                [/*start*/ 0xA4E, 0 /* Other */],
                [/*start*/ 0xA51, 14 /* Extend */],
                [/*start*/ 0xA52, 0 /* Other */],
                [/*start*/ 0xA59, 11 /* ALetter */],
                [/*start*/ 0xA5D, 0 /* Other */],
                [/*start*/ 0xA5E, 11 /* ALetter */],
                [/*start*/ 0xA5F, 0 /* Other */],
                [/*start*/ 0xA66, 9 /* Numeric */],
                [/*start*/ 0xA70, 14 /* Extend */],
                [/*start*/ 0xA72, 11 /* ALetter */],
                [/*start*/ 0xA75, 14 /* Extend */],
                [/*start*/ 0xA76, 0 /* Other */],
                [/*start*/ 0xA81, 14 /* Extend */],
                [/*start*/ 0xA84, 0 /* Other */],
                [/*start*/ 0xA85, 11 /* ALetter */],
                [/*start*/ 0xA8E, 0 /* Other */],
                [/*start*/ 0xA8F, 11 /* ALetter */],
                [/*start*/ 0xA92, 0 /* Other */],
                [/*start*/ 0xA93, 11 /* ALetter */],
                [/*start*/ 0xAA9, 0 /* Other */],
                [/*start*/ 0xAAA, 11 /* ALetter */],
                [/*start*/ 0xAB1, 0 /* Other */],
                [/*start*/ 0xAB2, 11 /* ALetter */],
                [/*start*/ 0xAB4, 0 /* Other */],
                [/*start*/ 0xAB5, 11 /* ALetter */],
                [/*start*/ 0xABA, 0 /* Other */],
                [/*start*/ 0xABC, 14 /* Extend */],
                [/*start*/ 0xABD, 11 /* ALetter */],
                [/*start*/ 0xABE, 14 /* Extend */],
                [/*start*/ 0xAC6, 0 /* Other */],
                [/*start*/ 0xAC7, 14 /* Extend */],
                [/*start*/ 0xACA, 0 /* Other */],
                [/*start*/ 0xACB, 14 /* Extend */],
                [/*start*/ 0xACE, 0 /* Other */],
                [/*start*/ 0xAD0, 11 /* ALetter */],
                [/*start*/ 0xAD1, 0 /* Other */],
                [/*start*/ 0xAE0, 11 /* ALetter */],
                [/*start*/ 0xAE2, 14 /* Extend */],
                [/*start*/ 0xAE4, 0 /* Other */],
                [/*start*/ 0xAE6, 9 /* Numeric */],
                [/*start*/ 0xAF0, 0 /* Other */],
                [/*start*/ 0xAF9, 11 /* ALetter */],
                [/*start*/ 0xAFA, 14 /* Extend */],
                [/*start*/ 0xB00, 0 /* Other */],
                [/*start*/ 0xB01, 14 /* Extend */],
                [/*start*/ 0xB04, 0 /* Other */],
                [/*start*/ 0xB05, 11 /* ALetter */],
                [/*start*/ 0xB0D, 0 /* Other */],
                [/*start*/ 0xB0F, 11 /* ALetter */],
                [/*start*/ 0xB11, 0 /* Other */],
                [/*start*/ 0xB13, 11 /* ALetter */],
                [/*start*/ 0xB29, 0 /* Other */],
                [/*start*/ 0xB2A, 11 /* ALetter */],
                [/*start*/ 0xB31, 0 /* Other */],
                [/*start*/ 0xB32, 11 /* ALetter */],
                [/*start*/ 0xB34, 0 /* Other */],
                [/*start*/ 0xB35, 11 /* ALetter */],
                [/*start*/ 0xB3A, 0 /* Other */],
                [/*start*/ 0xB3C, 14 /* Extend */],
                [/*start*/ 0xB3D, 11 /* ALetter */],
                [/*start*/ 0xB3E, 14 /* Extend */],
                [/*start*/ 0xB45, 0 /* Other */],
                [/*start*/ 0xB47, 14 /* Extend */],
                [/*start*/ 0xB49, 0 /* Other */],
                [/*start*/ 0xB4B, 14 /* Extend */],
                [/*start*/ 0xB4E, 0 /* Other */],
                [/*start*/ 0xB55, 14 /* Extend */],
                [/*start*/ 0xB58, 0 /* Other */],
                [/*start*/ 0xB5C, 11 /* ALetter */],
                [/*start*/ 0xB5E, 0 /* Other */],
                [/*start*/ 0xB5F, 11 /* ALetter */],
                [/*start*/ 0xB62, 14 /* Extend */],
                [/*start*/ 0xB64, 0 /* Other */],
                [/*start*/ 0xB66, 9 /* Numeric */],
                [/*start*/ 0xB70, 0 /* Other */],
                [/*start*/ 0xB71, 11 /* ALetter */],
                [/*start*/ 0xB72, 0 /* Other */],
                [/*start*/ 0xB82, 14 /* Extend */],
                [/*start*/ 0xB83, 11 /* ALetter */],
                [/*start*/ 0xB84, 0 /* Other */],
                [/*start*/ 0xB85, 11 /* ALetter */],
                [/*start*/ 0xB8B, 0 /* Other */],
                [/*start*/ 0xB8E, 11 /* ALetter */],
                [/*start*/ 0xB91, 0 /* Other */],
                [/*start*/ 0xB92, 11 /* ALetter */],
                [/*start*/ 0xB96, 0 /* Other */],
                [/*start*/ 0xB99, 11 /* ALetter */],
                [/*start*/ 0xB9B, 0 /* Other */],
                [/*start*/ 0xB9C, 11 /* ALetter */],
                [/*start*/ 0xB9D, 0 /* Other */],
                [/*start*/ 0xB9E, 11 /* ALetter */],
                [/*start*/ 0xBA0, 0 /* Other */],
                [/*start*/ 0xBA3, 11 /* ALetter */],
                [/*start*/ 0xBA5, 0 /* Other */],
                [/*start*/ 0xBA8, 11 /* ALetter */],
                [/*start*/ 0xBAB, 0 /* Other */],
                [/*start*/ 0xBAE, 11 /* ALetter */],
                [/*start*/ 0xBBA, 0 /* Other */],
                [/*start*/ 0xBBE, 14 /* Extend */],
                [/*start*/ 0xBC3, 0 /* Other */],
                [/*start*/ 0xBC6, 14 /* Extend */],
                [/*start*/ 0xBC9, 0 /* Other */],
                [/*start*/ 0xBCA, 14 /* Extend */],
                [/*start*/ 0xBCE, 0 /* Other */],
                [/*start*/ 0xBD0, 11 /* ALetter */],
                [/*start*/ 0xBD1, 0 /* Other */],
                [/*start*/ 0xBD7, 14 /* Extend */],
                [/*start*/ 0xBD8, 0 /* Other */],
                [/*start*/ 0xBE6, 9 /* Numeric */],
                [/*start*/ 0xBF0, 0 /* Other */],
                [/*start*/ 0xC00, 14 /* Extend */],
                [/*start*/ 0xC05, 11 /* ALetter */],
                [/*start*/ 0xC0D, 0 /* Other */],
                [/*start*/ 0xC0E, 11 /* ALetter */],
                [/*start*/ 0xC11, 0 /* Other */],
                [/*start*/ 0xC12, 11 /* ALetter */],
                [/*start*/ 0xC29, 0 /* Other */],
                [/*start*/ 0xC2A, 11 /* ALetter */],
                [/*start*/ 0xC3A, 0 /* Other */],
                [/*start*/ 0xC3D, 11 /* ALetter */],
                [/*start*/ 0xC3E, 14 /* Extend */],
                [/*start*/ 0xC45, 0 /* Other */],
                [/*start*/ 0xC46, 14 /* Extend */],
                [/*start*/ 0xC49, 0 /* Other */],
                [/*start*/ 0xC4A, 14 /* Extend */],
                [/*start*/ 0xC4E, 0 /* Other */],
                [/*start*/ 0xC55, 14 /* Extend */],
                [/*start*/ 0xC57, 0 /* Other */],
                [/*start*/ 0xC58, 11 /* ALetter */],
                [/*start*/ 0xC5B, 0 /* Other */],
                [/*start*/ 0xC60, 11 /* ALetter */],
                [/*start*/ 0xC62, 14 /* Extend */],
                [/*start*/ 0xC64, 0 /* Other */],
                [/*start*/ 0xC66, 9 /* Numeric */],
                [/*start*/ 0xC70, 0 /* Other */],
                [/*start*/ 0xC80, 11 /* ALetter */],
                [/*start*/ 0xC81, 14 /* Extend */],
                [/*start*/ 0xC84, 0 /* Other */],
                [/*start*/ 0xC85, 11 /* ALetter */],
                [/*start*/ 0xC8D, 0 /* Other */],
                [/*start*/ 0xC8E, 11 /* ALetter */],
                [/*start*/ 0xC91, 0 /* Other */],
                [/*start*/ 0xC92, 11 /* ALetter */],
                [/*start*/ 0xCA9, 0 /* Other */],
                [/*start*/ 0xCAA, 11 /* ALetter */],
                [/*start*/ 0xCB4, 0 /* Other */],
                [/*start*/ 0xCB5, 11 /* ALetter */],
                [/*start*/ 0xCBA, 0 /* Other */],
                [/*start*/ 0xCBC, 14 /* Extend */],
                [/*start*/ 0xCBD, 11 /* ALetter */],
                [/*start*/ 0xCBE, 14 /* Extend */],
                [/*start*/ 0xCC5, 0 /* Other */],
                [/*start*/ 0xCC6, 14 /* Extend */],
                [/*start*/ 0xCC9, 0 /* Other */],
                [/*start*/ 0xCCA, 14 /* Extend */],
                [/*start*/ 0xCCE, 0 /* Other */],
                [/*start*/ 0xCD5, 14 /* Extend */],
                [/*start*/ 0xCD7, 0 /* Other */],
                [/*start*/ 0xCDE, 11 /* ALetter */],
                [/*start*/ 0xCDF, 0 /* Other */],
                [/*start*/ 0xCE0, 11 /* ALetter */],
                [/*start*/ 0xCE2, 14 /* Extend */],
                [/*start*/ 0xCE4, 0 /* Other */],
                [/*start*/ 0xCE6, 9 /* Numeric */],
                [/*start*/ 0xCF0, 0 /* Other */],
                [/*start*/ 0xCF1, 11 /* ALetter */],
                [/*start*/ 0xCF3, 0 /* Other */],
                [/*start*/ 0xD00, 14 /* Extend */],
                [/*start*/ 0xD04, 11 /* ALetter */],
                [/*start*/ 0xD0D, 0 /* Other */],
                [/*start*/ 0xD0E, 11 /* ALetter */],
                [/*start*/ 0xD11, 0 /* Other */],
                [/*start*/ 0xD12, 11 /* ALetter */],
                [/*start*/ 0xD3B, 14 /* Extend */],
                [/*start*/ 0xD3D, 11 /* ALetter */],
                [/*start*/ 0xD3E, 14 /* Extend */],
                [/*start*/ 0xD45, 0 /* Other */],
                [/*start*/ 0xD46, 14 /* Extend */],
                [/*start*/ 0xD49, 0 /* Other */],
                [/*start*/ 0xD4A, 14 /* Extend */],
                [/*start*/ 0xD4E, 11 /* ALetter */],
                [/*start*/ 0xD4F, 0 /* Other */],
                [/*start*/ 0xD54, 11 /* ALetter */],
                [/*start*/ 0xD57, 14 /* Extend */],
                [/*start*/ 0xD58, 0 /* Other */],
                [/*start*/ 0xD5F, 11 /* ALetter */],
                [/*start*/ 0xD62, 14 /* Extend */],
                [/*start*/ 0xD64, 0 /* Other */],
                [/*start*/ 0xD66, 9 /* Numeric */],
                [/*start*/ 0xD70, 0 /* Other */],
                [/*start*/ 0xD7A, 11 /* ALetter */],
                [/*start*/ 0xD80, 0 /* Other */],
                [/*start*/ 0xD81, 14 /* Extend */],
                [/*start*/ 0xD84, 0 /* Other */],
                [/*start*/ 0xD85, 11 /* ALetter */],
                [/*start*/ 0xD97, 0 /* Other */],
                [/*start*/ 0xD9A, 11 /* ALetter */],
                [/*start*/ 0xDB2, 0 /* Other */],
                [/*start*/ 0xDB3, 11 /* ALetter */],
                [/*start*/ 0xDBC, 0 /* Other */],
                [/*start*/ 0xDBD, 11 /* ALetter */],
                [/*start*/ 0xDBE, 0 /* Other */],
                [/*start*/ 0xDC0, 11 /* ALetter */],
                [/*start*/ 0xDC7, 0 /* Other */],
                [/*start*/ 0xDCA, 14 /* Extend */],
                [/*start*/ 0xDCB, 0 /* Other */],
                [/*start*/ 0xDCF, 14 /* Extend */],
                [/*start*/ 0xDD5, 0 /* Other */],
                [/*start*/ 0xDD6, 14 /* Extend */],
                [/*start*/ 0xDD7, 0 /* Other */],
                [/*start*/ 0xDD8, 14 /* Extend */],
                [/*start*/ 0xDE0, 0 /* Other */],
                [/*start*/ 0xDE6, 9 /* Numeric */],
                [/*start*/ 0xDF0, 0 /* Other */],
                [/*start*/ 0xDF2, 14 /* Extend */],
                [/*start*/ 0xDF4, 0 /* Other */],
                [/*start*/ 0xE31, 14 /* Extend */],
                [/*start*/ 0xE32, 0 /* Other */],
                [/*start*/ 0xE34, 14 /* Extend */],
                [/*start*/ 0xE3B, 0 /* Other */],
                [/*start*/ 0xE47, 14 /* Extend */],
                [/*start*/ 0xE4F, 0 /* Other */],
                [/*start*/ 0xE50, 9 /* Numeric */],
                [/*start*/ 0xE5A, 0 /* Other */],
                [/*start*/ 0xEB1, 14 /* Extend */],
                [/*start*/ 0xEB2, 0 /* Other */],
                [/*start*/ 0xEB4, 14 /* Extend */],
                [/*start*/ 0xEBD, 0 /* Other */],
                [/*start*/ 0xEC8, 14 /* Extend */],
                [/*start*/ 0xECE, 0 /* Other */],
                [/*start*/ 0xED0, 9 /* Numeric */],
                [/*start*/ 0xEDA, 0 /* Other */],
                [/*start*/ 0xF00, 11 /* ALetter */],
                [/*start*/ 0xF01, 0 /* Other */],
                [/*start*/ 0xF18, 14 /* Extend */],
                [/*start*/ 0xF1A, 0 /* Other */],
                [/*start*/ 0xF20, 9 /* Numeric */],
                [/*start*/ 0xF2A, 0 /* Other */],
                [/*start*/ 0xF35, 14 /* Extend */],
                [/*start*/ 0xF36, 0 /* Other */],
                [/*start*/ 0xF37, 14 /* Extend */],
                [/*start*/ 0xF38, 0 /* Other */],
                [/*start*/ 0xF39, 14 /* Extend */],
                [/*start*/ 0xF3A, 0 /* Other */],
                [/*start*/ 0xF3E, 14 /* Extend */],
                [/*start*/ 0xF40, 11 /* ALetter */],
                [/*start*/ 0xF48, 0 /* Other */],
                [/*start*/ 0xF49, 11 /* ALetter */],
                [/*start*/ 0xF6D, 0 /* Other */],
                [/*start*/ 0xF71, 14 /* Extend */],
                [/*start*/ 0xF85, 0 /* Other */],
                [/*start*/ 0xF86, 14 /* Extend */],
                [/*start*/ 0xF88, 11 /* ALetter */],
                [/*start*/ 0xF8D, 14 /* Extend */],
                [/*start*/ 0xF98, 0 /* Other */],
                [/*start*/ 0xF99, 14 /* Extend */],
                [/*start*/ 0xFBD, 0 /* Other */],
                [/*start*/ 0xFC6, 14 /* Extend */],
                [/*start*/ 0xFC7, 0 /* Other */],
                [/*start*/ 0x102B, 14 /* Extend */],
                [/*start*/ 0x103F, 0 /* Other */],
                [/*start*/ 0x1040, 9 /* Numeric */],
                [/*start*/ 0x104A, 0 /* Other */],
                [/*start*/ 0x1056, 14 /* Extend */],
                [/*start*/ 0x105A, 0 /* Other */],
                [/*start*/ 0x105E, 14 /* Extend */],
                [/*start*/ 0x1061, 0 /* Other */],
                [/*start*/ 0x1062, 14 /* Extend */],
                [/*start*/ 0x1065, 0 /* Other */],
                [/*start*/ 0x1067, 14 /* Extend */],
                [/*start*/ 0x106E, 0 /* Other */],
                [/*start*/ 0x1071, 14 /* Extend */],
                [/*start*/ 0x1075, 0 /* Other */],
                [/*start*/ 0x1082, 14 /* Extend */],
                [/*start*/ 0x108E, 0 /* Other */],
                [/*start*/ 0x108F, 14 /* Extend */],
                [/*start*/ 0x1090, 9 /* Numeric */],
                [/*start*/ 0x109A, 14 /* Extend */],
                [/*start*/ 0x109E, 0 /* Other */],
                [/*start*/ 0x10A0, 11 /* ALetter */],
                [/*start*/ 0x10C6, 0 /* Other */],
                [/*start*/ 0x10C7, 11 /* ALetter */],
                [/*start*/ 0x10C8, 0 /* Other */],
                [/*start*/ 0x10CD, 11 /* ALetter */],
                [/*start*/ 0x10CE, 0 /* Other */],
                [/*start*/ 0x10D0, 11 /* ALetter */],
                [/*start*/ 0x10FB, 0 /* Other */],
                [/*start*/ 0x10FC, 11 /* ALetter */],
                [/*start*/ 0x1249, 0 /* Other */],
                [/*start*/ 0x124A, 11 /* ALetter */],
                [/*start*/ 0x124E, 0 /* Other */],
                [/*start*/ 0x1250, 11 /* ALetter */],
                [/*start*/ 0x1257, 0 /* Other */],
                [/*start*/ 0x1258, 11 /* ALetter */],
                [/*start*/ 0x1259, 0 /* Other */],
                [/*start*/ 0x125A, 11 /* ALetter */],
                [/*start*/ 0x125E, 0 /* Other */],
                [/*start*/ 0x1260, 11 /* ALetter */],
                [/*start*/ 0x1289, 0 /* Other */],
                [/*start*/ 0x128A, 11 /* ALetter */],
                [/*start*/ 0x128E, 0 /* Other */],
                [/*start*/ 0x1290, 11 /* ALetter */],
                [/*start*/ 0x12B1, 0 /* Other */],
                [/*start*/ 0x12B2, 11 /* ALetter */],
                [/*start*/ 0x12B6, 0 /* Other */],
                [/*start*/ 0x12B8, 11 /* ALetter */],
                [/*start*/ 0x12BF, 0 /* Other */],
                [/*start*/ 0x12C0, 11 /* ALetter */],
                [/*start*/ 0x12C1, 0 /* Other */],
                [/*start*/ 0x12C2, 11 /* ALetter */],
                [/*start*/ 0x12C6, 0 /* Other */],
                [/*start*/ 0x12C8, 11 /* ALetter */],
                [/*start*/ 0x12D7, 0 /* Other */],
                [/*start*/ 0x12D8, 11 /* ALetter */],
                [/*start*/ 0x1311, 0 /* Other */],
                [/*start*/ 0x1312, 11 /* ALetter */],
                [/*start*/ 0x1316, 0 /* Other */],
                [/*start*/ 0x1318, 11 /* ALetter */],
                [/*start*/ 0x135B, 0 /* Other */],
                [/*start*/ 0x135D, 14 /* Extend */],
                [/*start*/ 0x1360, 0 /* Other */],
                [/*start*/ 0x1380, 11 /* ALetter */],
                [/*start*/ 0x1390, 0 /* Other */],
                [/*start*/ 0x13A0, 11 /* ALetter */],
                [/*start*/ 0x13F6, 0 /* Other */],
                [/*start*/ 0x13F8, 11 /* ALetter */],
                [/*start*/ 0x13FE, 0 /* Other */],
                [/*start*/ 0x1401, 11 /* ALetter */],
                [/*start*/ 0x166D, 0 /* Other */],
                [/*start*/ 0x166F, 11 /* ALetter */],
                [/*start*/ 0x1680, 4 /* WSegSpace */],
                [/*start*/ 0x1681, 11 /* ALetter */],
                [/*start*/ 0x169B, 0 /* Other */],
                [/*start*/ 0x16A0, 11 /* ALetter */],
                [/*start*/ 0x16EB, 0 /* Other */],
                [/*start*/ 0x16EE, 11 /* ALetter */],
                [/*start*/ 0x16F9, 0 /* Other */],
                [/*start*/ 0x1700, 11 /* ALetter */],
                [/*start*/ 0x170D, 0 /* Other */],
                [/*start*/ 0x170E, 11 /* ALetter */],
                [/*start*/ 0x1712, 14 /* Extend */],
                [/*start*/ 0x1715, 0 /* Other */],
                [/*start*/ 0x1720, 11 /* ALetter */],
                [/*start*/ 0x1732, 14 /* Extend */],
                [/*start*/ 0x1735, 0 /* Other */],
                [/*start*/ 0x1740, 11 /* ALetter */],
                [/*start*/ 0x1752, 14 /* Extend */],
                [/*start*/ 0x1754, 0 /* Other */],
                [/*start*/ 0x1760, 11 /* ALetter */],
                [/*start*/ 0x176D, 0 /* Other */],
                [/*start*/ 0x176E, 11 /* ALetter */],
                [/*start*/ 0x1771, 0 /* Other */],
                [/*start*/ 0x1772, 14 /* Extend */],
                [/*start*/ 0x1774, 0 /* Other */],
                [/*start*/ 0x17B4, 14 /* Extend */],
                [/*start*/ 0x17D4, 0 /* Other */],
                [/*start*/ 0x17DD, 14 /* Extend */],
                [/*start*/ 0x17DE, 0 /* Other */],
                [/*start*/ 0x17E0, 9 /* Numeric */],
                [/*start*/ 0x17EA, 0 /* Other */],
                [/*start*/ 0x180B, 14 /* Extend */],
                [/*start*/ 0x180E, 13 /* Format */],
                [/*start*/ 0x180F, 0 /* Other */],
                [/*start*/ 0x1810, 9 /* Numeric */],
                [/*start*/ 0x181A, 0 /* Other */],
                [/*start*/ 0x1820, 11 /* ALetter */],
                [/*start*/ 0x1879, 0 /* Other */],
                [/*start*/ 0x1880, 11 /* ALetter */],
                [/*start*/ 0x1885, 14 /* Extend */],
                [/*start*/ 0x1887, 11 /* ALetter */],
                [/*start*/ 0x18A9, 14 /* Extend */],
                [/*start*/ 0x18AA, 11 /* ALetter */],
                [/*start*/ 0x18AB, 0 /* Other */],
                [/*start*/ 0x18B0, 11 /* ALetter */],
                [/*start*/ 0x18F6, 0 /* Other */],
                [/*start*/ 0x1900, 11 /* ALetter */],
                [/*start*/ 0x191F, 0 /* Other */],
                [/*start*/ 0x1920, 14 /* Extend */],
                [/*start*/ 0x192C, 0 /* Other */],
                [/*start*/ 0x1930, 14 /* Extend */],
                [/*start*/ 0x193C, 0 /* Other */],
                [/*start*/ 0x1946, 9 /* Numeric */],
                [/*start*/ 0x1950, 0 /* Other */],
                [/*start*/ 0x19D0, 9 /* Numeric */],
                [/*start*/ 0x19DA, 0 /* Other */],
                [/*start*/ 0x1A00, 11 /* ALetter */],
                [/*start*/ 0x1A17, 14 /* Extend */],
                [/*start*/ 0x1A1C, 0 /* Other */],
                [/*start*/ 0x1A55, 14 /* Extend */],
                [/*start*/ 0x1A5F, 0 /* Other */],
                [/*start*/ 0x1A60, 14 /* Extend */],
                [/*start*/ 0x1A7D, 0 /* Other */],
                [/*start*/ 0x1A7F, 14 /* Extend */],
                [/*start*/ 0x1A80, 9 /* Numeric */],
                [/*start*/ 0x1A8A, 0 /* Other */],
                [/*start*/ 0x1A90, 9 /* Numeric */],
                [/*start*/ 0x1A9A, 0 /* Other */],
                [/*start*/ 0x1AB0, 14 /* Extend */],
                [/*start*/ 0x1AC1, 0 /* Other */],
                [/*start*/ 0x1B00, 14 /* Extend */],
                [/*start*/ 0x1B05, 11 /* ALetter */],
                [/*start*/ 0x1B34, 14 /* Extend */],
                [/*start*/ 0x1B45, 11 /* ALetter */],
                [/*start*/ 0x1B4C, 0 /* Other */],
                [/*start*/ 0x1B50, 9 /* Numeric */],
                [/*start*/ 0x1B5A, 0 /* Other */],
                [/*start*/ 0x1B6B, 14 /* Extend */],
                [/*start*/ 0x1B74, 0 /* Other */],
                [/*start*/ 0x1B80, 14 /* Extend */],
                [/*start*/ 0x1B83, 11 /* ALetter */],
                [/*start*/ 0x1BA1, 14 /* Extend */],
                [/*start*/ 0x1BAE, 11 /* ALetter */],
                [/*start*/ 0x1BB0, 9 /* Numeric */],
                [/*start*/ 0x1BBA, 11 /* ALetter */],
                [/*start*/ 0x1BE6, 14 /* Extend */],
                [/*start*/ 0x1BF4, 0 /* Other */],
                [/*start*/ 0x1C00, 11 /* ALetter */],
                [/*start*/ 0x1C24, 14 /* Extend */],
                [/*start*/ 0x1C38, 0 /* Other */],
                [/*start*/ 0x1C40, 9 /* Numeric */],
                [/*start*/ 0x1C4A, 0 /* Other */],
                [/*start*/ 0x1C4D, 11 /* ALetter */],
                [/*start*/ 0x1C50, 9 /* Numeric */],
                [/*start*/ 0x1C5A, 11 /* ALetter */],
                [/*start*/ 0x1C7E, 0 /* Other */],
                [/*start*/ 0x1C80, 11 /* ALetter */],
                [/*start*/ 0x1C89, 0 /* Other */],
                [/*start*/ 0x1C90, 11 /* ALetter */],
                [/*start*/ 0x1CBB, 0 /* Other */],
                [/*start*/ 0x1CBD, 11 /* ALetter */],
                [/*start*/ 0x1CC0, 0 /* Other */],
                [/*start*/ 0x1CD0, 14 /* Extend */],
                [/*start*/ 0x1CD3, 0 /* Other */],
                [/*start*/ 0x1CD4, 14 /* Extend */],
                [/*start*/ 0x1CE9, 11 /* ALetter */],
                [/*start*/ 0x1CED, 14 /* Extend */],
                [/*start*/ 0x1CEE, 11 /* ALetter */],
                [/*start*/ 0x1CF4, 14 /* Extend */],
                [/*start*/ 0x1CF5, 11 /* ALetter */],
                [/*start*/ 0x1CF7, 14 /* Extend */],
                [/*start*/ 0x1CFA, 11 /* ALetter */],
                [/*start*/ 0x1CFB, 0 /* Other */],
                [/*start*/ 0x1D00, 11 /* ALetter */],
                [/*start*/ 0x1DC0, 14 /* Extend */],
                [/*start*/ 0x1DFA, 0 /* Other */],
                [/*start*/ 0x1DFB, 14 /* Extend */],
                [/*start*/ 0x1E00, 11 /* ALetter */],
                [/*start*/ 0x1F16, 0 /* Other */],
                [/*start*/ 0x1F18, 11 /* ALetter */],
                [/*start*/ 0x1F1E, 0 /* Other */],
                [/*start*/ 0x1F20, 11 /* ALetter */],
                [/*start*/ 0x1F46, 0 /* Other */],
                [/*start*/ 0x1F48, 11 /* ALetter */],
                [/*start*/ 0x1F4E, 0 /* Other */],
                [/*start*/ 0x1F50, 11 /* ALetter */],
                [/*start*/ 0x1F58, 0 /* Other */],
                [/*start*/ 0x1F59, 11 /* ALetter */],
                [/*start*/ 0x1F5A, 0 /* Other */],
                [/*start*/ 0x1F5B, 11 /* ALetter */],
                [/*start*/ 0x1F5C, 0 /* Other */],
                [/*start*/ 0x1F5D, 11 /* ALetter */],
                [/*start*/ 0x1F5E, 0 /* Other */],
                [/*start*/ 0x1F5F, 11 /* ALetter */],
                [/*start*/ 0x1F7E, 0 /* Other */],
                [/*start*/ 0x1F80, 11 /* ALetter */],
                [/*start*/ 0x1FB5, 0 /* Other */],
                [/*start*/ 0x1FB6, 11 /* ALetter */],
                [/*start*/ 0x1FBD, 0 /* Other */],
                [/*start*/ 0x1FBE, 11 /* ALetter */],
                [/*start*/ 0x1FBF, 0 /* Other */],
                [/*start*/ 0x1FC2, 11 /* ALetter */],
                [/*start*/ 0x1FC5, 0 /* Other */],
                [/*start*/ 0x1FC6, 11 /* ALetter */],
                [/*start*/ 0x1FCD, 0 /* Other */],
                [/*start*/ 0x1FD0, 11 /* ALetter */],
                [/*start*/ 0x1FD4, 0 /* Other */],
                [/*start*/ 0x1FD6, 11 /* ALetter */],
                [/*start*/ 0x1FDC, 0 /* Other */],
                [/*start*/ 0x1FE0, 11 /* ALetter */],
                [/*start*/ 0x1FED, 0 /* Other */],
                [/*start*/ 0x1FF2, 11 /* ALetter */],
                [/*start*/ 0x1FF5, 0 /* Other */],
                [/*start*/ 0x1FF6, 11 /* ALetter */],
                [/*start*/ 0x1FFD, 0 /* Other */],
                [/*start*/ 0x2000, 4 /* WSegSpace */],
                [/*start*/ 0x2007, 0 /* Other */],
                [/*start*/ 0x2008, 4 /* WSegSpace */],
                [/*start*/ 0x200B, 0 /* Other */],
                [/*start*/ 0x200C, 14 /* Extend */],
                [/*start*/ 0x200D, 16 /* ZWJ */],
                [/*start*/ 0x200E, 13 /* Format */],
                [/*start*/ 0x2010, 0 /* Other */],
                [/*start*/ 0x2018, 8 /* MidNumLet */],
                [/*start*/ 0x201A, 0 /* Other */],
                [/*start*/ 0x2024, 8 /* MidNumLet */],
                [/*start*/ 0x2025, 0 /* Other */],
                [/*start*/ 0x2027, 10 /* MidLetter */],
                [/*start*/ 0x2028, 2 /* Newline */],
                [/*start*/ 0x202A, 13 /* Format */],
                [/*start*/ 0x202F, 12 /* ExtendNumLet */],
                [/*start*/ 0x2030, 0 /* Other */],
                [/*start*/ 0x203F, 12 /* ExtendNumLet */],
                [/*start*/ 0x2041, 0 /* Other */],
                [/*start*/ 0x2044, 7 /* MidNum */],
                [/*start*/ 0x2045, 0 /* Other */],
                [/*start*/ 0x2054, 12 /* ExtendNumLet */],
                [/*start*/ 0x2055, 0 /* Other */],
                [/*start*/ 0x205F, 4 /* WSegSpace */],
                [/*start*/ 0x2060, 13 /* Format */],
                [/*start*/ 0x2065, 0 /* Other */],
                [/*start*/ 0x2066, 13 /* Format */],
                [/*start*/ 0x2070, 0 /* Other */],
                [/*start*/ 0x2071, 11 /* ALetter */],
                [/*start*/ 0x2072, 0 /* Other */],
                [/*start*/ 0x207F, 11 /* ALetter */],
                [/*start*/ 0x2080, 0 /* Other */],
                [/*start*/ 0x2090, 11 /* ALetter */],
                [/*start*/ 0x209D, 0 /* Other */],
                [/*start*/ 0x20D0, 14 /* Extend */],
                [/*start*/ 0x20F1, 0 /* Other */],
                [/*start*/ 0x2102, 11 /* ALetter */],
                [/*start*/ 0x2103, 0 /* Other */],
                [/*start*/ 0x2107, 11 /* ALetter */],
                [/*start*/ 0x2108, 0 /* Other */],
                [/*start*/ 0x210A, 11 /* ALetter */],
                [/*start*/ 0x2114, 0 /* Other */],
                [/*start*/ 0x2115, 11 /* ALetter */],
                [/*start*/ 0x2116, 0 /* Other */],
                [/*start*/ 0x2119, 11 /* ALetter */],
                [/*start*/ 0x211E, 0 /* Other */],
                [/*start*/ 0x2124, 11 /* ALetter */],
                [/*start*/ 0x2125, 0 /* Other */],
                [/*start*/ 0x2126, 11 /* ALetter */],
                [/*start*/ 0x2127, 0 /* Other */],
                [/*start*/ 0x2128, 11 /* ALetter */],
                [/*start*/ 0x2129, 0 /* Other */],
                [/*start*/ 0x212A, 11 /* ALetter */],
                [/*start*/ 0x212E, 0 /* Other */],
                [/*start*/ 0x212F, 11 /* ALetter */],
                [/*start*/ 0x213A, 0 /* Other */],
                [/*start*/ 0x213C, 11 /* ALetter */],
                [/*start*/ 0x2140, 0 /* Other */],
                [/*start*/ 0x2145, 11 /* ALetter */],
                [/*start*/ 0x214A, 0 /* Other */],
                [/*start*/ 0x214E, 11 /* ALetter */],
                [/*start*/ 0x214F, 0 /* Other */],
                [/*start*/ 0x2160, 11 /* ALetter */],
                [/*start*/ 0x2189, 0 /* Other */],
                [/*start*/ 0x24B6, 11 /* ALetter */],
                [/*start*/ 0x24EA, 0 /* Other */],
                [/*start*/ 0x2C00, 11 /* ALetter */],
                [/*start*/ 0x2C2F, 0 /* Other */],
                [/*start*/ 0x2C30, 11 /* ALetter */],
                [/*start*/ 0x2C5F, 0 /* Other */],
                [/*start*/ 0x2C60, 11 /* ALetter */],
                [/*start*/ 0x2CE5, 0 /* Other */],
                [/*start*/ 0x2CEB, 11 /* ALetter */],
                [/*start*/ 0x2CEF, 14 /* Extend */],
                [/*start*/ 0x2CF2, 11 /* ALetter */],
                [/*start*/ 0x2CF4, 0 /* Other */],
                [/*start*/ 0x2D00, 11 /* ALetter */],
                [/*start*/ 0x2D26, 0 /* Other */],
                [/*start*/ 0x2D27, 11 /* ALetter */],
                [/*start*/ 0x2D28, 0 /* Other */],
                [/*start*/ 0x2D2D, 11 /* ALetter */],
                [/*start*/ 0x2D2E, 0 /* Other */],
                [/*start*/ 0x2D30, 11 /* ALetter */],
                [/*start*/ 0x2D68, 0 /* Other */],
                [/*start*/ 0x2D6F, 11 /* ALetter */],
                [/*start*/ 0x2D70, 0 /* Other */],
                [/*start*/ 0x2D7F, 14 /* Extend */],
                [/*start*/ 0x2D80, 11 /* ALetter */],
                [/*start*/ 0x2D97, 0 /* Other */],
                [/*start*/ 0x2DA0, 11 /* ALetter */],
                [/*start*/ 0x2DA7, 0 /* Other */],
                [/*start*/ 0x2DA8, 11 /* ALetter */],
                [/*start*/ 0x2DAF, 0 /* Other */],
                [/*start*/ 0x2DB0, 11 /* ALetter */],
                [/*start*/ 0x2DB7, 0 /* Other */],
                [/*start*/ 0x2DB8, 11 /* ALetter */],
                [/*start*/ 0x2DBF, 0 /* Other */],
                [/*start*/ 0x2DC0, 11 /* ALetter */],
                [/*start*/ 0x2DC7, 0 /* Other */],
                [/*start*/ 0x2DC8, 11 /* ALetter */],
                [/*start*/ 0x2DCF, 0 /* Other */],
                [/*start*/ 0x2DD0, 11 /* ALetter */],
                [/*start*/ 0x2DD7, 0 /* Other */],
                [/*start*/ 0x2DD8, 11 /* ALetter */],
                [/*start*/ 0x2DDF, 0 /* Other */],
                [/*start*/ 0x2DE0, 14 /* Extend */],
                [/*start*/ 0x2E00, 0 /* Other */],
                [/*start*/ 0x2E2F, 11 /* ALetter */],
                [/*start*/ 0x2E30, 0 /* Other */],
                [/*start*/ 0x3000, 4 /* WSegSpace */],
                [/*start*/ 0x3001, 0 /* Other */],
                [/*start*/ 0x3005, 11 /* ALetter */],
                [/*start*/ 0x3006, 0 /* Other */],
                [/*start*/ 0x302A, 14 /* Extend */],
                [/*start*/ 0x3030, 0 /* Other */],
                [/*start*/ 0x3031, 17 /* Katakana */],
                [/*start*/ 0x3036, 0 /* Other */],
                [/*start*/ 0x303B, 11 /* ALetter */],
                [/*start*/ 0x303D, 0 /* Other */],
                [/*start*/ 0x3099, 14 /* Extend */],
                [/*start*/ 0x309B, 17 /* Katakana */],
                [/*start*/ 0x309D, 0 /* Other */],
                [/*start*/ 0x30A0, 17 /* Katakana */],
                [/*start*/ 0x30FB, 0 /* Other */],
                [/*start*/ 0x30FC, 17 /* Katakana */],
                [/*start*/ 0x3100, 0 /* Other */],
                [/*start*/ 0x3105, 11 /* ALetter */],
                [/*start*/ 0x3130, 0 /* Other */],
                [/*start*/ 0x3131, 11 /* ALetter */],
                [/*start*/ 0x318F, 0 /* Other */],
                [/*start*/ 0x31A0, 11 /* ALetter */],
                [/*start*/ 0x31C0, 0 /* Other */],
                [/*start*/ 0x31F0, 17 /* Katakana */],
                [/*start*/ 0x3200, 0 /* Other */],
                [/*start*/ 0x32D0, 17 /* Katakana */],
                [/*start*/ 0x32FF, 0 /* Other */],
                [/*start*/ 0x3300, 17 /* Katakana */],
                [/*start*/ 0x3358, 0 /* Other */],
                [/*start*/ 0xA000, 11 /* ALetter */],
                [/*start*/ 0xA48D, 0 /* Other */],
                [/*start*/ 0xA4D0, 11 /* ALetter */],
                [/*start*/ 0xA4FE, 0 /* Other */],
                [/*start*/ 0xA500, 11 /* ALetter */],
                [/*start*/ 0xA60D, 0 /* Other */],
                [/*start*/ 0xA610, 11 /* ALetter */],
                [/*start*/ 0xA620, 9 /* Numeric */],
                [/*start*/ 0xA62A, 11 /* ALetter */],
                [/*start*/ 0xA62C, 0 /* Other */],
                [/*start*/ 0xA640, 11 /* ALetter */],
                [/*start*/ 0xA66F, 14 /* Extend */],
                [/*start*/ 0xA673, 0 /* Other */],
                [/*start*/ 0xA674, 14 /* Extend */],
                [/*start*/ 0xA67E, 0 /* Other */],
                [/*start*/ 0xA67F, 11 /* ALetter */],
                [/*start*/ 0xA69E, 14 /* Extend */],
                [/*start*/ 0xA6A0, 11 /* ALetter */],
                [/*start*/ 0xA6F0, 14 /* Extend */],
                [/*start*/ 0xA6F2, 0 /* Other */],
                [/*start*/ 0xA708, 11 /* ALetter */],
                [/*start*/ 0xA7C0, 0 /* Other */],
                [/*start*/ 0xA7C2, 11 /* ALetter */],
                [/*start*/ 0xA7CB, 0 /* Other */],
                [/*start*/ 0xA7F5, 11 /* ALetter */],
                [/*start*/ 0xA802, 14 /* Extend */],
                [/*start*/ 0xA803, 11 /* ALetter */],
                [/*start*/ 0xA806, 14 /* Extend */],
                [/*start*/ 0xA807, 11 /* ALetter */],
                [/*start*/ 0xA80B, 14 /* Extend */],
                [/*start*/ 0xA80C, 11 /* ALetter */],
                [/*start*/ 0xA823, 14 /* Extend */],
                [/*start*/ 0xA828, 0 /* Other */],
                [/*start*/ 0xA82C, 14 /* Extend */],
                [/*start*/ 0xA82D, 0 /* Other */],
                [/*start*/ 0xA840, 11 /* ALetter */],
                [/*start*/ 0xA874, 0 /* Other */],
                [/*start*/ 0xA880, 14 /* Extend */],
                [/*start*/ 0xA882, 11 /* ALetter */],
                [/*start*/ 0xA8B4, 14 /* Extend */],
                [/*start*/ 0xA8C6, 0 /* Other */],
                [/*start*/ 0xA8D0, 9 /* Numeric */],
                [/*start*/ 0xA8DA, 0 /* Other */],
                [/*start*/ 0xA8E0, 14 /* Extend */],
                [/*start*/ 0xA8F2, 11 /* ALetter */],
                [/*start*/ 0xA8F8, 0 /* Other */],
                [/*start*/ 0xA8FB, 11 /* ALetter */],
                [/*start*/ 0xA8FC, 0 /* Other */],
                [/*start*/ 0xA8FD, 11 /* ALetter */],
                [/*start*/ 0xA8FF, 14 /* Extend */],
                [/*start*/ 0xA900, 9 /* Numeric */],
                [/*start*/ 0xA90A, 11 /* ALetter */],
                [/*start*/ 0xA926, 14 /* Extend */],
                [/*start*/ 0xA92E, 0 /* Other */],
                [/*start*/ 0xA930, 11 /* ALetter */],
                [/*start*/ 0xA947, 14 /* Extend */],
                [/*start*/ 0xA954, 0 /* Other */],
                [/*start*/ 0xA960, 11 /* ALetter */],
                [/*start*/ 0xA97D, 0 /* Other */],
                [/*start*/ 0xA980, 14 /* Extend */],
                [/*start*/ 0xA984, 11 /* ALetter */],
                [/*start*/ 0xA9B3, 14 /* Extend */],
                [/*start*/ 0xA9C1, 0 /* Other */],
                [/*start*/ 0xA9CF, 11 /* ALetter */],
                [/*start*/ 0xA9D0, 9 /* Numeric */],
                [/*start*/ 0xA9DA, 0 /* Other */],
                [/*start*/ 0xA9E5, 14 /* Extend */],
                [/*start*/ 0xA9E6, 0 /* Other */],
                [/*start*/ 0xA9F0, 9 /* Numeric */],
                [/*start*/ 0xA9FA, 0 /* Other */],
                [/*start*/ 0xAA00, 11 /* ALetter */],
                [/*start*/ 0xAA29, 14 /* Extend */],
                [/*start*/ 0xAA37, 0 /* Other */],
                [/*start*/ 0xAA40, 11 /* ALetter */],
                [/*start*/ 0xAA43, 14 /* Extend */],
                [/*start*/ 0xAA44, 11 /* ALetter */],
                [/*start*/ 0xAA4C, 14 /* Extend */],
                [/*start*/ 0xAA4E, 0 /* Other */],
                [/*start*/ 0xAA50, 9 /* Numeric */],
                [/*start*/ 0xAA5A, 0 /* Other */],
                [/*start*/ 0xAA7B, 14 /* Extend */],
                [/*start*/ 0xAA7E, 0 /* Other */],
                [/*start*/ 0xAAB0, 14 /* Extend */],
                [/*start*/ 0xAAB1, 0 /* Other */],
                [/*start*/ 0xAAB2, 14 /* Extend */],
                [/*start*/ 0xAAB5, 0 /* Other */],
                [/*start*/ 0xAAB7, 14 /* Extend */],
                [/*start*/ 0xAAB9, 0 /* Other */],
                [/*start*/ 0xAABE, 14 /* Extend */],
                [/*start*/ 0xAAC0, 0 /* Other */],
                [/*start*/ 0xAAC1, 14 /* Extend */],
                [/*start*/ 0xAAC2, 0 /* Other */],
                [/*start*/ 0xAAE0, 11 /* ALetter */],
                [/*start*/ 0xAAEB, 14 /* Extend */],
                [/*start*/ 0xAAF0, 0 /* Other */],
                [/*start*/ 0xAAF2, 11 /* ALetter */],
                [/*start*/ 0xAAF5, 14 /* Extend */],
                [/*start*/ 0xAAF7, 0 /* Other */],
                [/*start*/ 0xAB01, 11 /* ALetter */],
                [/*start*/ 0xAB07, 0 /* Other */],
                [/*start*/ 0xAB09, 11 /* ALetter */],
                [/*start*/ 0xAB0F, 0 /* Other */],
                [/*start*/ 0xAB11, 11 /* ALetter */],
                [/*start*/ 0xAB17, 0 /* Other */],
                [/*start*/ 0xAB20, 11 /* ALetter */],
                [/*start*/ 0xAB27, 0 /* Other */],
                [/*start*/ 0xAB28, 11 /* ALetter */],
                [/*start*/ 0xAB2F, 0 /* Other */],
                [/*start*/ 0xAB30, 11 /* ALetter */],
                [/*start*/ 0xAB6A, 0 /* Other */],
                [/*start*/ 0xAB70, 11 /* ALetter */],
                [/*start*/ 0xABE3, 14 /* Extend */],
                [/*start*/ 0xABEB, 0 /* Other */],
                [/*start*/ 0xABEC, 14 /* Extend */],
                [/*start*/ 0xABEE, 0 /* Other */],
                [/*start*/ 0xABF0, 9 /* Numeric */],
                [/*start*/ 0xABFA, 0 /* Other */],
                [/*start*/ 0xAC00, 11 /* ALetter */],
                [/*start*/ 0xD7A4, 0 /* Other */],
                [/*start*/ 0xD7B0, 11 /* ALetter */],
                [/*start*/ 0xD7C7, 0 /* Other */],
                [/*start*/ 0xD7CB, 11 /* ALetter */],
                [/*start*/ 0xD7FC, 0 /* Other */],
                [/*start*/ 0xFB00, 11 /* ALetter */],
                [/*start*/ 0xFB07, 0 /* Other */],
                [/*start*/ 0xFB13, 11 /* ALetter */],
                [/*start*/ 0xFB18, 0 /* Other */],
                [/*start*/ 0xFB1D, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB1E, 14 /* Extend */],
                [/*start*/ 0xFB1F, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB29, 0 /* Other */],
                [/*start*/ 0xFB2A, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB37, 0 /* Other */],
                [/*start*/ 0xFB38, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB3D, 0 /* Other */],
                [/*start*/ 0xFB3E, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB3F, 0 /* Other */],
                [/*start*/ 0xFB40, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB42, 0 /* Other */],
                [/*start*/ 0xFB43, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB45, 0 /* Other */],
                [/*start*/ 0xFB46, 15 /* Hebrew_Letter */],
                [/*start*/ 0xFB50, 11 /* ALetter */],
                [/*start*/ 0xFBB2, 0 /* Other */],
                [/*start*/ 0xFBD3, 11 /* ALetter */],
                [/*start*/ 0xFD3E, 0 /* Other */],
                [/*start*/ 0xFD50, 11 /* ALetter */],
                [/*start*/ 0xFD90, 0 /* Other */],
                [/*start*/ 0xFD92, 11 /* ALetter */],
                [/*start*/ 0xFDC8, 0 /* Other */],
                [/*start*/ 0xFDF0, 11 /* ALetter */],
                [/*start*/ 0xFDFC, 0 /* Other */],
                [/*start*/ 0xFE00, 14 /* Extend */],
                [/*start*/ 0xFE10, 7 /* MidNum */],
                [/*start*/ 0xFE11, 0 /* Other */],
                [/*start*/ 0xFE13, 10 /* MidLetter */],
                [/*start*/ 0xFE14, 7 /* MidNum */],
                [/*start*/ 0xFE15, 0 /* Other */],
                [/*start*/ 0xFE20, 14 /* Extend */],
                [/*start*/ 0xFE30, 0 /* Other */],
                [/*start*/ 0xFE33, 12 /* ExtendNumLet */],
                [/*start*/ 0xFE35, 0 /* Other */],
                [/*start*/ 0xFE4D, 12 /* ExtendNumLet */],
                [/*start*/ 0xFE50, 7 /* MidNum */],
                [/*start*/ 0xFE51, 0 /* Other */],
                [/*start*/ 0xFE52, 8 /* MidNumLet */],
                [/*start*/ 0xFE53, 0 /* Other */],
                [/*start*/ 0xFE54, 7 /* MidNum */],
                [/*start*/ 0xFE55, 10 /* MidLetter */],
                [/*start*/ 0xFE56, 0 /* Other */],
                [/*start*/ 0xFE70, 11 /* ALetter */],
                [/*start*/ 0xFE75, 0 /* Other */],
                [/*start*/ 0xFE76, 11 /* ALetter */],
                [/*start*/ 0xFEFD, 0 /* Other */],
                [/*start*/ 0xFEFF, 13 /* Format */],
                [/*start*/ 0xFF00, 0 /* Other */],
                [/*start*/ 0xFF07, 8 /* MidNumLet */],
                [/*start*/ 0xFF08, 0 /* Other */],
                [/*start*/ 0xFF0C, 7 /* MidNum */],
                [/*start*/ 0xFF0D, 0 /* Other */],
                [/*start*/ 0xFF0E, 8 /* MidNumLet */],
                [/*start*/ 0xFF0F, 0 /* Other */],
                [/*start*/ 0xFF10, 9 /* Numeric */],
                [/*start*/ 0xFF1A, 10 /* MidLetter */],
                [/*start*/ 0xFF1B, 7 /* MidNum */],
                [/*start*/ 0xFF1C, 0 /* Other */],
                [/*start*/ 0xFF21, 11 /* ALetter */],
                [/*start*/ 0xFF3B, 0 /* Other */],
                [/*start*/ 0xFF3F, 12 /* ExtendNumLet */],
                [/*start*/ 0xFF40, 0 /* Other */],
                [/*start*/ 0xFF41, 11 /* ALetter */],
                [/*start*/ 0xFF5B, 0 /* Other */],
                [/*start*/ 0xFF66, 17 /* Katakana */],
                [/*start*/ 0xFF9E, 14 /* Extend */],
                [/*start*/ 0xFFA0, 11 /* ALetter */],
                [/*start*/ 0xFFBF, 0 /* Other */],
                [/*start*/ 0xFFC2, 11 /* ALetter */],
                [/*start*/ 0xFFC8, 0 /* Other */],
                [/*start*/ 0xFFCA, 11 /* ALetter */],
                [/*start*/ 0xFFD0, 0 /* Other */],
                [/*start*/ 0xFFD2, 11 /* ALetter */],
                [/*start*/ 0xFFD8, 0 /* Other */],
                [/*start*/ 0xFFDA, 11 /* ALetter */],
                [/*start*/ 0xFFDD, 0 /* Other */],
                [/*start*/ 0xFFF9, 13 /* Format */],
                [/*start*/ 0xFFFC, 0 /* Other */],
                [/*start*/ 0x10000, 11 /* ALetter */],
                [/*start*/ 0x1000C, 0 /* Other */],
                [/*start*/ 0x1000D, 11 /* ALetter */],
                [/*start*/ 0x10027, 0 /* Other */],
                [/*start*/ 0x10028, 11 /* ALetter */],
                [/*start*/ 0x1003B, 0 /* Other */],
                [/*start*/ 0x1003C, 11 /* ALetter */],
                [/*start*/ 0x1003E, 0 /* Other */],
                [/*start*/ 0x1003F, 11 /* ALetter */],
                [/*start*/ 0x1004E, 0 /* Other */],
                [/*start*/ 0x10050, 11 /* ALetter */],
                [/*start*/ 0x1005E, 0 /* Other */],
                [/*start*/ 0x10080, 11 /* ALetter */],
                [/*start*/ 0x100FB, 0 /* Other */],
                [/*start*/ 0x10140, 11 /* ALetter */],
                [/*start*/ 0x10175, 0 /* Other */],
                [/*start*/ 0x101FD, 14 /* Extend */],
                [/*start*/ 0x101FE, 0 /* Other */],
                [/*start*/ 0x10280, 11 /* ALetter */],
                [/*start*/ 0x1029D, 0 /* Other */],
                [/*start*/ 0x102A0, 11 /* ALetter */],
                [/*start*/ 0x102D1, 0 /* Other */],
                [/*start*/ 0x102E0, 14 /* Extend */],
                [/*start*/ 0x102E1, 0 /* Other */],
                [/*start*/ 0x10300, 11 /* ALetter */],
                [/*start*/ 0x10320, 0 /* Other */],
                [/*start*/ 0x1032D, 11 /* ALetter */],
                [/*start*/ 0x1034B, 0 /* Other */],
                [/*start*/ 0x10350, 11 /* ALetter */],
                [/*start*/ 0x10376, 14 /* Extend */],
                [/*start*/ 0x1037B, 0 /* Other */],
                [/*start*/ 0x10380, 11 /* ALetter */],
                [/*start*/ 0x1039E, 0 /* Other */],
                [/*start*/ 0x103A0, 11 /* ALetter */],
                [/*start*/ 0x103C4, 0 /* Other */],
                [/*start*/ 0x103C8, 11 /* ALetter */],
                [/*start*/ 0x103D0, 0 /* Other */],
                [/*start*/ 0x103D1, 11 /* ALetter */],
                [/*start*/ 0x103D6, 0 /* Other */],
                [/*start*/ 0x10400, 11 /* ALetter */],
                [/*start*/ 0x1049E, 0 /* Other */],
                [/*start*/ 0x104A0, 9 /* Numeric */],
                [/*start*/ 0x104AA, 0 /* Other */],
                [/*start*/ 0x104B0, 11 /* ALetter */],
                [/*start*/ 0x104D4, 0 /* Other */],
                [/*start*/ 0x104D8, 11 /* ALetter */],
                [/*start*/ 0x104FC, 0 /* Other */],
                [/*start*/ 0x10500, 11 /* ALetter */],
                [/*start*/ 0x10528, 0 /* Other */],
                [/*start*/ 0x10530, 11 /* ALetter */],
                [/*start*/ 0x10564, 0 /* Other */],
                [/*start*/ 0x10600, 11 /* ALetter */],
                [/*start*/ 0x10737, 0 /* Other */],
                [/*start*/ 0x10740, 11 /* ALetter */],
                [/*start*/ 0x10756, 0 /* Other */],
                [/*start*/ 0x10760, 11 /* ALetter */],
                [/*start*/ 0x10768, 0 /* Other */],
                [/*start*/ 0x10800, 11 /* ALetter */],
                [/*start*/ 0x10806, 0 /* Other */],
                [/*start*/ 0x10808, 11 /* ALetter */],
                [/*start*/ 0x10809, 0 /* Other */],
                [/*start*/ 0x1080A, 11 /* ALetter */],
                [/*start*/ 0x10836, 0 /* Other */],
                [/*start*/ 0x10837, 11 /* ALetter */],
                [/*start*/ 0x10839, 0 /* Other */],
                [/*start*/ 0x1083C, 11 /* ALetter */],
                [/*start*/ 0x1083D, 0 /* Other */],
                [/*start*/ 0x1083F, 11 /* ALetter */],
                [/*start*/ 0x10856, 0 /* Other */],
                [/*start*/ 0x10860, 11 /* ALetter */],
                [/*start*/ 0x10877, 0 /* Other */],
                [/*start*/ 0x10880, 11 /* ALetter */],
                [/*start*/ 0x1089F, 0 /* Other */],
                [/*start*/ 0x108E0, 11 /* ALetter */],
                [/*start*/ 0x108F3, 0 /* Other */],
                [/*start*/ 0x108F4, 11 /* ALetter */],
                [/*start*/ 0x108F6, 0 /* Other */],
                [/*start*/ 0x10900, 11 /* ALetter */],
                [/*start*/ 0x10916, 0 /* Other */],
                [/*start*/ 0x10920, 11 /* ALetter */],
                [/*start*/ 0x1093A, 0 /* Other */],
                [/*start*/ 0x10980, 11 /* ALetter */],
                [/*start*/ 0x109B8, 0 /* Other */],
                [/*start*/ 0x109BE, 11 /* ALetter */],
                [/*start*/ 0x109C0, 0 /* Other */],
                [/*start*/ 0x10A00, 11 /* ALetter */],
                [/*start*/ 0x10A01, 14 /* Extend */],
                [/*start*/ 0x10A04, 0 /* Other */],
                [/*start*/ 0x10A05, 14 /* Extend */],
                [/*start*/ 0x10A07, 0 /* Other */],
                [/*start*/ 0x10A0C, 14 /* Extend */],
                [/*start*/ 0x10A10, 11 /* ALetter */],
                [/*start*/ 0x10A14, 0 /* Other */],
                [/*start*/ 0x10A15, 11 /* ALetter */],
                [/*start*/ 0x10A18, 0 /* Other */],
                [/*start*/ 0x10A19, 11 /* ALetter */],
                [/*start*/ 0x10A36, 0 /* Other */],
                [/*start*/ 0x10A38, 14 /* Extend */],
                [/*start*/ 0x10A3B, 0 /* Other */],
                [/*start*/ 0x10A3F, 14 /* Extend */],
                [/*start*/ 0x10A40, 0 /* Other */],
                [/*start*/ 0x10A60, 11 /* ALetter */],
                [/*start*/ 0x10A7D, 0 /* Other */],
                [/*start*/ 0x10A80, 11 /* ALetter */],
                [/*start*/ 0x10A9D, 0 /* Other */],
                [/*start*/ 0x10AC0, 11 /* ALetter */],
                [/*start*/ 0x10AC8, 0 /* Other */],
                [/*start*/ 0x10AC9, 11 /* ALetter */],
                [/*start*/ 0x10AE5, 14 /* Extend */],
                [/*start*/ 0x10AE7, 0 /* Other */],
                [/*start*/ 0x10B00, 11 /* ALetter */],
                [/*start*/ 0x10B36, 0 /* Other */],
                [/*start*/ 0x10B40, 11 /* ALetter */],
                [/*start*/ 0x10B56, 0 /* Other */],
                [/*start*/ 0x10B60, 11 /* ALetter */],
                [/*start*/ 0x10B73, 0 /* Other */],
                [/*start*/ 0x10B80, 11 /* ALetter */],
                [/*start*/ 0x10B92, 0 /* Other */],
                [/*start*/ 0x10C00, 11 /* ALetter */],
                [/*start*/ 0x10C49, 0 /* Other */],
                [/*start*/ 0x10C80, 11 /* ALetter */],
                [/*start*/ 0x10CB3, 0 /* Other */],
                [/*start*/ 0x10CC0, 11 /* ALetter */],
                [/*start*/ 0x10CF3, 0 /* Other */],
                [/*start*/ 0x10D00, 11 /* ALetter */],
                [/*start*/ 0x10D24, 14 /* Extend */],
                [/*start*/ 0x10D28, 0 /* Other */],
                [/*start*/ 0x10D30, 9 /* Numeric */],
                [/*start*/ 0x10D3A, 0 /* Other */],
                [/*start*/ 0x10E80, 11 /* ALetter */],
                [/*start*/ 0x10EAA, 0 /* Other */],
                [/*start*/ 0x10EAB, 14 /* Extend */],
                [/*start*/ 0x10EAD, 0 /* Other */],
                [/*start*/ 0x10EB0, 11 /* ALetter */],
                [/*start*/ 0x10EB2, 0 /* Other */],
                [/*start*/ 0x10F00, 11 /* ALetter */],
                [/*start*/ 0x10F1D, 0 /* Other */],
                [/*start*/ 0x10F27, 11 /* ALetter */],
                [/*start*/ 0x10F28, 0 /* Other */],
                [/*start*/ 0x10F30, 11 /* ALetter */],
                [/*start*/ 0x10F46, 14 /* Extend */],
                [/*start*/ 0x10F51, 0 /* Other */],
                [/*start*/ 0x10FB0, 11 /* ALetter */],
                [/*start*/ 0x10FC5, 0 /* Other */],
                [/*start*/ 0x10FE0, 11 /* ALetter */],
                [/*start*/ 0x10FF7, 0 /* Other */],
                [/*start*/ 0x11000, 14 /* Extend */],
                [/*start*/ 0x11003, 11 /* ALetter */],
                [/*start*/ 0x11038, 14 /* Extend */],
                [/*start*/ 0x11047, 0 /* Other */],
                [/*start*/ 0x11066, 9 /* Numeric */],
                [/*start*/ 0x11070, 0 /* Other */],
                [/*start*/ 0x1107F, 14 /* Extend */],
                [/*start*/ 0x11083, 11 /* ALetter */],
                [/*start*/ 0x110B0, 14 /* Extend */],
                [/*start*/ 0x110BB, 0 /* Other */],
                [/*start*/ 0x110BD, 13 /* Format */],
                [/*start*/ 0x110BE, 0 /* Other */],
                [/*start*/ 0x110CD, 13 /* Format */],
                [/*start*/ 0x110CE, 0 /* Other */],
                [/*start*/ 0x110D0, 11 /* ALetter */],
                [/*start*/ 0x110E9, 0 /* Other */],
                [/*start*/ 0x110F0, 9 /* Numeric */],
                [/*start*/ 0x110FA, 0 /* Other */],
                [/*start*/ 0x11100, 14 /* Extend */],
                [/*start*/ 0x11103, 11 /* ALetter */],
                [/*start*/ 0x11127, 14 /* Extend */],
                [/*start*/ 0x11135, 0 /* Other */],
                [/*start*/ 0x11136, 9 /* Numeric */],
                [/*start*/ 0x11140, 0 /* Other */],
                [/*start*/ 0x11144, 11 /* ALetter */],
                [/*start*/ 0x11145, 14 /* Extend */],
                [/*start*/ 0x11147, 11 /* ALetter */],
                [/*start*/ 0x11148, 0 /* Other */],
                [/*start*/ 0x11150, 11 /* ALetter */],
                [/*start*/ 0x11173, 14 /* Extend */],
                [/*start*/ 0x11174, 0 /* Other */],
                [/*start*/ 0x11176, 11 /* ALetter */],
                [/*start*/ 0x11177, 0 /* Other */],
                [/*start*/ 0x11180, 14 /* Extend */],
                [/*start*/ 0x11183, 11 /* ALetter */],
                [/*start*/ 0x111B3, 14 /* Extend */],
                [/*start*/ 0x111C1, 11 /* ALetter */],
                [/*start*/ 0x111C5, 0 /* Other */],
                [/*start*/ 0x111C9, 14 /* Extend */],
                [/*start*/ 0x111CD, 0 /* Other */],
                [/*start*/ 0x111CE, 14 /* Extend */],
                [/*start*/ 0x111D0, 9 /* Numeric */],
                [/*start*/ 0x111DA, 11 /* ALetter */],
                [/*start*/ 0x111DB, 0 /* Other */],
                [/*start*/ 0x111DC, 11 /* ALetter */],
                [/*start*/ 0x111DD, 0 /* Other */],
                [/*start*/ 0x11200, 11 /* ALetter */],
                [/*start*/ 0x11212, 0 /* Other */],
                [/*start*/ 0x11213, 11 /* ALetter */],
                [/*start*/ 0x1122C, 14 /* Extend */],
                [/*start*/ 0x11238, 0 /* Other */],
                [/*start*/ 0x1123E, 14 /* Extend */],
                [/*start*/ 0x1123F, 0 /* Other */],
                [/*start*/ 0x11280, 11 /* ALetter */],
                [/*start*/ 0x11287, 0 /* Other */],
                [/*start*/ 0x11288, 11 /* ALetter */],
                [/*start*/ 0x11289, 0 /* Other */],
                [/*start*/ 0x1128A, 11 /* ALetter */],
                [/*start*/ 0x1128E, 0 /* Other */],
                [/*start*/ 0x1128F, 11 /* ALetter */],
                [/*start*/ 0x1129E, 0 /* Other */],
                [/*start*/ 0x1129F, 11 /* ALetter */],
                [/*start*/ 0x112A9, 0 /* Other */],
                [/*start*/ 0x112B0, 11 /* ALetter */],
                [/*start*/ 0x112DF, 14 /* Extend */],
                [/*start*/ 0x112EB, 0 /* Other */],
                [/*start*/ 0x112F0, 9 /* Numeric */],
                [/*start*/ 0x112FA, 0 /* Other */],
                [/*start*/ 0x11300, 14 /* Extend */],
                [/*start*/ 0x11304, 0 /* Other */],
                [/*start*/ 0x11305, 11 /* ALetter */],
                [/*start*/ 0x1130D, 0 /* Other */],
                [/*start*/ 0x1130F, 11 /* ALetter */],
                [/*start*/ 0x11311, 0 /* Other */],
                [/*start*/ 0x11313, 11 /* ALetter */],
                [/*start*/ 0x11329, 0 /* Other */],
                [/*start*/ 0x1132A, 11 /* ALetter */],
                [/*start*/ 0x11331, 0 /* Other */],
                [/*start*/ 0x11332, 11 /* ALetter */],
                [/*start*/ 0x11334, 0 /* Other */],
                [/*start*/ 0x11335, 11 /* ALetter */],
                [/*start*/ 0x1133A, 0 /* Other */],
                [/*start*/ 0x1133B, 14 /* Extend */],
                [/*start*/ 0x1133D, 11 /* ALetter */],
                [/*start*/ 0x1133E, 14 /* Extend */],
                [/*start*/ 0x11345, 0 /* Other */],
                [/*start*/ 0x11347, 14 /* Extend */],
                [/*start*/ 0x11349, 0 /* Other */],
                [/*start*/ 0x1134B, 14 /* Extend */],
                [/*start*/ 0x1134E, 0 /* Other */],
                [/*start*/ 0x11350, 11 /* ALetter */],
                [/*start*/ 0x11351, 0 /* Other */],
                [/*start*/ 0x11357, 14 /* Extend */],
                [/*start*/ 0x11358, 0 /* Other */],
                [/*start*/ 0x1135D, 11 /* ALetter */],
                [/*start*/ 0x11362, 14 /* Extend */],
                [/*start*/ 0x11364, 0 /* Other */],
                [/*start*/ 0x11366, 14 /* Extend */],
                [/*start*/ 0x1136D, 0 /* Other */],
                [/*start*/ 0x11370, 14 /* Extend */],
                [/*start*/ 0x11375, 0 /* Other */],
                [/*start*/ 0x11400, 11 /* ALetter */],
                [/*start*/ 0x11435, 14 /* Extend */],
                [/*start*/ 0x11447, 11 /* ALetter */],
                [/*start*/ 0x1144B, 0 /* Other */],
                [/*start*/ 0x11450, 9 /* Numeric */],
                [/*start*/ 0x1145A, 0 /* Other */],
                [/*start*/ 0x1145E, 14 /* Extend */],
                [/*start*/ 0x1145F, 11 /* ALetter */],
                [/*start*/ 0x11462, 0 /* Other */],
                [/*start*/ 0x11480, 11 /* ALetter */],
                [/*start*/ 0x114B0, 14 /* Extend */],
                [/*start*/ 0x114C4, 11 /* ALetter */],
                [/*start*/ 0x114C6, 0 /* Other */],
                [/*start*/ 0x114C7, 11 /* ALetter */],
                [/*start*/ 0x114C8, 0 /* Other */],
                [/*start*/ 0x114D0, 9 /* Numeric */],
                [/*start*/ 0x114DA, 0 /* Other */],
                [/*start*/ 0x11580, 11 /* ALetter */],
                [/*start*/ 0x115AF, 14 /* Extend */],
                [/*start*/ 0x115B6, 0 /* Other */],
                [/*start*/ 0x115B8, 14 /* Extend */],
                [/*start*/ 0x115C1, 0 /* Other */],
                [/*start*/ 0x115D8, 11 /* ALetter */],
                [/*start*/ 0x115DC, 14 /* Extend */],
                [/*start*/ 0x115DE, 0 /* Other */],
                [/*start*/ 0x11600, 11 /* ALetter */],
                [/*start*/ 0x11630, 14 /* Extend */],
                [/*start*/ 0x11641, 0 /* Other */],
                [/*start*/ 0x11644, 11 /* ALetter */],
                [/*start*/ 0x11645, 0 /* Other */],
                [/*start*/ 0x11650, 9 /* Numeric */],
                [/*start*/ 0x1165A, 0 /* Other */],
                [/*start*/ 0x11680, 11 /* ALetter */],
                [/*start*/ 0x116AB, 14 /* Extend */],
                [/*start*/ 0x116B8, 11 /* ALetter */],
                [/*start*/ 0x116B9, 0 /* Other */],
                [/*start*/ 0x116C0, 9 /* Numeric */],
                [/*start*/ 0x116CA, 0 /* Other */],
                [/*start*/ 0x1171D, 14 /* Extend */],
                [/*start*/ 0x1172C, 0 /* Other */],
                [/*start*/ 0x11730, 9 /* Numeric */],
                [/*start*/ 0x1173A, 0 /* Other */],
                [/*start*/ 0x11800, 11 /* ALetter */],
                [/*start*/ 0x1182C, 14 /* Extend */],
                [/*start*/ 0x1183B, 0 /* Other */],
                [/*start*/ 0x118A0, 11 /* ALetter */],
                [/*start*/ 0x118E0, 9 /* Numeric */],
                [/*start*/ 0x118EA, 0 /* Other */],
                [/*start*/ 0x118FF, 11 /* ALetter */],
                [/*start*/ 0x11907, 0 /* Other */],
                [/*start*/ 0x11909, 11 /* ALetter */],
                [/*start*/ 0x1190A, 0 /* Other */],
                [/*start*/ 0x1190C, 11 /* ALetter */],
                [/*start*/ 0x11914, 0 /* Other */],
                [/*start*/ 0x11915, 11 /* ALetter */],
                [/*start*/ 0x11917, 0 /* Other */],
                [/*start*/ 0x11918, 11 /* ALetter */],
                [/*start*/ 0x11930, 14 /* Extend */],
                [/*start*/ 0x11936, 0 /* Other */],
                [/*start*/ 0x11937, 14 /* Extend */],
                [/*start*/ 0x11939, 0 /* Other */],
                [/*start*/ 0x1193B, 14 /* Extend */],
                [/*start*/ 0x1193F, 11 /* ALetter */],
                [/*start*/ 0x11940, 14 /* Extend */],
                [/*start*/ 0x11941, 11 /* ALetter */],
                [/*start*/ 0x11942, 14 /* Extend */],
                [/*start*/ 0x11944, 0 /* Other */],
                [/*start*/ 0x11950, 9 /* Numeric */],
                [/*start*/ 0x1195A, 0 /* Other */],
                [/*start*/ 0x119A0, 11 /* ALetter */],
                [/*start*/ 0x119A8, 0 /* Other */],
                [/*start*/ 0x119AA, 11 /* ALetter */],
                [/*start*/ 0x119D1, 14 /* Extend */],
                [/*start*/ 0x119D8, 0 /* Other */],
                [/*start*/ 0x119DA, 14 /* Extend */],
                [/*start*/ 0x119E1, 11 /* ALetter */],
                [/*start*/ 0x119E2, 0 /* Other */],
                [/*start*/ 0x119E3, 11 /* ALetter */],
                [/*start*/ 0x119E4, 14 /* Extend */],
                [/*start*/ 0x119E5, 0 /* Other */],
                [/*start*/ 0x11A00, 11 /* ALetter */],
                [/*start*/ 0x11A01, 14 /* Extend */],
                [/*start*/ 0x11A0B, 11 /* ALetter */],
                [/*start*/ 0x11A33, 14 /* Extend */],
                [/*start*/ 0x11A3A, 11 /* ALetter */],
                [/*start*/ 0x11A3B, 14 /* Extend */],
                [/*start*/ 0x11A3F, 0 /* Other */],
                [/*start*/ 0x11A47, 14 /* Extend */],
                [/*start*/ 0x11A48, 0 /* Other */],
                [/*start*/ 0x11A50, 11 /* ALetter */],
                [/*start*/ 0x11A51, 14 /* Extend */],
                [/*start*/ 0x11A5C, 11 /* ALetter */],
                [/*start*/ 0x11A8A, 14 /* Extend */],
                [/*start*/ 0x11A9A, 0 /* Other */],
                [/*start*/ 0x11A9D, 11 /* ALetter */],
                [/*start*/ 0x11A9E, 0 /* Other */],
                [/*start*/ 0x11AC0, 11 /* ALetter */],
                [/*start*/ 0x11AF9, 0 /* Other */],
                [/*start*/ 0x11C00, 11 /* ALetter */],
                [/*start*/ 0x11C09, 0 /* Other */],
                [/*start*/ 0x11C0A, 11 /* ALetter */],
                [/*start*/ 0x11C2F, 14 /* Extend */],
                [/*start*/ 0x11C37, 0 /* Other */],
                [/*start*/ 0x11C38, 14 /* Extend */],
                [/*start*/ 0x11C40, 11 /* ALetter */],
                [/*start*/ 0x11C41, 0 /* Other */],
                [/*start*/ 0x11C50, 9 /* Numeric */],
                [/*start*/ 0x11C5A, 0 /* Other */],
                [/*start*/ 0x11C72, 11 /* ALetter */],
                [/*start*/ 0x11C90, 0 /* Other */],
                [/*start*/ 0x11C92, 14 /* Extend */],
                [/*start*/ 0x11CA8, 0 /* Other */],
                [/*start*/ 0x11CA9, 14 /* Extend */],
                [/*start*/ 0x11CB7, 0 /* Other */],
                [/*start*/ 0x11D00, 11 /* ALetter */],
                [/*start*/ 0x11D07, 0 /* Other */],
                [/*start*/ 0x11D08, 11 /* ALetter */],
                [/*start*/ 0x11D0A, 0 /* Other */],
                [/*start*/ 0x11D0B, 11 /* ALetter */],
                [/*start*/ 0x11D31, 14 /* Extend */],
                [/*start*/ 0x11D37, 0 /* Other */],
                [/*start*/ 0x11D3A, 14 /* Extend */],
                [/*start*/ 0x11D3B, 0 /* Other */],
                [/*start*/ 0x11D3C, 14 /* Extend */],
                [/*start*/ 0x11D3E, 0 /* Other */],
                [/*start*/ 0x11D3F, 14 /* Extend */],
                [/*start*/ 0x11D46, 11 /* ALetter */],
                [/*start*/ 0x11D47, 14 /* Extend */],
                [/*start*/ 0x11D48, 0 /* Other */],
                [/*start*/ 0x11D50, 9 /* Numeric */],
                [/*start*/ 0x11D5A, 0 /* Other */],
                [/*start*/ 0x11D60, 11 /* ALetter */],
                [/*start*/ 0x11D66, 0 /* Other */],
                [/*start*/ 0x11D67, 11 /* ALetter */],
                [/*start*/ 0x11D69, 0 /* Other */],
                [/*start*/ 0x11D6A, 11 /* ALetter */],
                [/*start*/ 0x11D8A, 14 /* Extend */],
                [/*start*/ 0x11D8F, 0 /* Other */],
                [/*start*/ 0x11D90, 14 /* Extend */],
                [/*start*/ 0x11D92, 0 /* Other */],
                [/*start*/ 0x11D93, 14 /* Extend */],
                [/*start*/ 0x11D98, 11 /* ALetter */],
                [/*start*/ 0x11D99, 0 /* Other */],
                [/*start*/ 0x11DA0, 9 /* Numeric */],
                [/*start*/ 0x11DAA, 0 /* Other */],
                [/*start*/ 0x11EE0, 11 /* ALetter */],
                [/*start*/ 0x11EF3, 14 /* Extend */],
                [/*start*/ 0x11EF7, 0 /* Other */],
                [/*start*/ 0x11FB0, 11 /* ALetter */],
                [/*start*/ 0x11FB1, 0 /* Other */],
                [/*start*/ 0x12000, 11 /* ALetter */],
                [/*start*/ 0x1239A, 0 /* Other */],
                [/*start*/ 0x12400, 11 /* ALetter */],
                [/*start*/ 0x1246F, 0 /* Other */],
                [/*start*/ 0x12480, 11 /* ALetter */],
                [/*start*/ 0x12544, 0 /* Other */],
                [/*start*/ 0x13000, 11 /* ALetter */],
                [/*start*/ 0x1342F, 0 /* Other */],
                [/*start*/ 0x13430, 13 /* Format */],
                [/*start*/ 0x13439, 0 /* Other */],
                [/*start*/ 0x14400, 11 /* ALetter */],
                [/*start*/ 0x14647, 0 /* Other */],
                [/*start*/ 0x16800, 11 /* ALetter */],
                [/*start*/ 0x16A39, 0 /* Other */],
                [/*start*/ 0x16A40, 11 /* ALetter */],
                [/*start*/ 0x16A5F, 0 /* Other */],
                [/*start*/ 0x16A60, 9 /* Numeric */],
                [/*start*/ 0x16A6A, 0 /* Other */],
                [/*start*/ 0x16AD0, 11 /* ALetter */],
                [/*start*/ 0x16AEE, 0 /* Other */],
                [/*start*/ 0x16AF0, 14 /* Extend */],
                [/*start*/ 0x16AF5, 0 /* Other */],
                [/*start*/ 0x16B00, 11 /* ALetter */],
                [/*start*/ 0x16B30, 14 /* Extend */],
                [/*start*/ 0x16B37, 0 /* Other */],
                [/*start*/ 0x16B40, 11 /* ALetter */],
                [/*start*/ 0x16B44, 0 /* Other */],
                [/*start*/ 0x16B50, 9 /* Numeric */],
                [/*start*/ 0x16B5A, 0 /* Other */],
                [/*start*/ 0x16B63, 11 /* ALetter */],
                [/*start*/ 0x16B78, 0 /* Other */],
                [/*start*/ 0x16B7D, 11 /* ALetter */],
                [/*start*/ 0x16B90, 0 /* Other */],
                [/*start*/ 0x16E40, 11 /* ALetter */],
                [/*start*/ 0x16E80, 0 /* Other */],
                [/*start*/ 0x16F00, 11 /* ALetter */],
                [/*start*/ 0x16F4B, 0 /* Other */],
                [/*start*/ 0x16F4F, 14 /* Extend */],
                [/*start*/ 0x16F50, 11 /* ALetter */],
                [/*start*/ 0x16F51, 14 /* Extend */],
                [/*start*/ 0x16F88, 0 /* Other */],
                [/*start*/ 0x16F8F, 14 /* Extend */],
                [/*start*/ 0x16F93, 11 /* ALetter */],
                [/*start*/ 0x16FA0, 0 /* Other */],
                [/*start*/ 0x16FE0, 11 /* ALetter */],
                [/*start*/ 0x16FE2, 0 /* Other */],
                [/*start*/ 0x16FE3, 11 /* ALetter */],
                [/*start*/ 0x16FE4, 14 /* Extend */],
                [/*start*/ 0x16FE5, 0 /* Other */],
                [/*start*/ 0x16FF0, 14 /* Extend */],
                [/*start*/ 0x16FF2, 0 /* Other */],
                [/*start*/ 0x1B000, 17 /* Katakana */],
                [/*start*/ 0x1B001, 0 /* Other */],
                [/*start*/ 0x1B164, 17 /* Katakana */],
                [/*start*/ 0x1B168, 0 /* Other */],
                [/*start*/ 0x1BC00, 11 /* ALetter */],
                [/*start*/ 0x1BC6B, 0 /* Other */],
                [/*start*/ 0x1BC70, 11 /* ALetter */],
                [/*start*/ 0x1BC7D, 0 /* Other */],
                [/*start*/ 0x1BC80, 11 /* ALetter */],
                [/*start*/ 0x1BC89, 0 /* Other */],
                [/*start*/ 0x1BC90, 11 /* ALetter */],
                [/*start*/ 0x1BC9A, 0 /* Other */],
                [/*start*/ 0x1BC9D, 14 /* Extend */],
                [/*start*/ 0x1BC9F, 0 /* Other */],
                [/*start*/ 0x1BCA0, 13 /* Format */],
                [/*start*/ 0x1BCA4, 0 /* Other */],
                [/*start*/ 0x1D165, 14 /* Extend */],
                [/*start*/ 0x1D16A, 0 /* Other */],
                [/*start*/ 0x1D16D, 14 /* Extend */],
                [/*start*/ 0x1D173, 13 /* Format */],
                [/*start*/ 0x1D17B, 14 /* Extend */],
                [/*start*/ 0x1D183, 0 /* Other */],
                [/*start*/ 0x1D185, 14 /* Extend */],
                [/*start*/ 0x1D18C, 0 /* Other */],
                [/*start*/ 0x1D1AA, 14 /* Extend */],
                [/*start*/ 0x1D1AE, 0 /* Other */],
                [/*start*/ 0x1D242, 14 /* Extend */],
                [/*start*/ 0x1D245, 0 /* Other */],
                [/*start*/ 0x1D400, 11 /* ALetter */],
                [/*start*/ 0x1D455, 0 /* Other */],
                [/*start*/ 0x1D456, 11 /* ALetter */],
                [/*start*/ 0x1D49D, 0 /* Other */],
                [/*start*/ 0x1D49E, 11 /* ALetter */],
                [/*start*/ 0x1D4A0, 0 /* Other */],
                [/*start*/ 0x1D4A2, 11 /* ALetter */],
                [/*start*/ 0x1D4A3, 0 /* Other */],
                [/*start*/ 0x1D4A5, 11 /* ALetter */],
                [/*start*/ 0x1D4A7, 0 /* Other */],
                [/*start*/ 0x1D4A9, 11 /* ALetter */],
                [/*start*/ 0x1D4AD, 0 /* Other */],
                [/*start*/ 0x1D4AE, 11 /* ALetter */],
                [/*start*/ 0x1D4BA, 0 /* Other */],
                [/*start*/ 0x1D4BB, 11 /* ALetter */],
                [/*start*/ 0x1D4BC, 0 /* Other */],
                [/*start*/ 0x1D4BD, 11 /* ALetter */],
                [/*start*/ 0x1D4C4, 0 /* Other */],
                [/*start*/ 0x1D4C5, 11 /* ALetter */],
                [/*start*/ 0x1D506, 0 /* Other */],
                [/*start*/ 0x1D507, 11 /* ALetter */],
                [/*start*/ 0x1D50B, 0 /* Other */],
                [/*start*/ 0x1D50D, 11 /* ALetter */],
                [/*start*/ 0x1D515, 0 /* Other */],
                [/*start*/ 0x1D516, 11 /* ALetter */],
                [/*start*/ 0x1D51D, 0 /* Other */],
                [/*start*/ 0x1D51E, 11 /* ALetter */],
                [/*start*/ 0x1D53A, 0 /* Other */],
                [/*start*/ 0x1D53B, 11 /* ALetter */],
                [/*start*/ 0x1D53F, 0 /* Other */],
                [/*start*/ 0x1D540, 11 /* ALetter */],
                [/*start*/ 0x1D545, 0 /* Other */],
                [/*start*/ 0x1D546, 11 /* ALetter */],
                [/*start*/ 0x1D547, 0 /* Other */],
                [/*start*/ 0x1D54A, 11 /* ALetter */],
                [/*start*/ 0x1D551, 0 /* Other */],
                [/*start*/ 0x1D552, 11 /* ALetter */],
                [/*start*/ 0x1D6A6, 0 /* Other */],
                [/*start*/ 0x1D6A8, 11 /* ALetter */],
                [/*start*/ 0x1D6C1, 0 /* Other */],
                [/*start*/ 0x1D6C2, 11 /* ALetter */],
                [/*start*/ 0x1D6DB, 0 /* Other */],
                [/*start*/ 0x1D6DC, 11 /* ALetter */],
                [/*start*/ 0x1D6FB, 0 /* Other */],
                [/*start*/ 0x1D6FC, 11 /* ALetter */],
                [/*start*/ 0x1D715, 0 /* Other */],
                [/*start*/ 0x1D716, 11 /* ALetter */],
                [/*start*/ 0x1D735, 0 /* Other */],
                [/*start*/ 0x1D736, 11 /* ALetter */],
                [/*start*/ 0x1D74F, 0 /* Other */],
                [/*start*/ 0x1D750, 11 /* ALetter */],
                [/*start*/ 0x1D76F, 0 /* Other */],
                [/*start*/ 0x1D770, 11 /* ALetter */],
                [/*start*/ 0x1D789, 0 /* Other */],
                [/*start*/ 0x1D78A, 11 /* ALetter */],
                [/*start*/ 0x1D7A9, 0 /* Other */],
                [/*start*/ 0x1D7AA, 11 /* ALetter */],
                [/*start*/ 0x1D7C3, 0 /* Other */],
                [/*start*/ 0x1D7C4, 11 /* ALetter */],
                [/*start*/ 0x1D7CC, 0 /* Other */],
                [/*start*/ 0x1D7CE, 9 /* Numeric */],
                [/*start*/ 0x1D800, 0 /* Other */],
                [/*start*/ 0x1DA00, 14 /* Extend */],
                [/*start*/ 0x1DA37, 0 /* Other */],
                [/*start*/ 0x1DA3B, 14 /* Extend */],
                [/*start*/ 0x1DA6D, 0 /* Other */],
                [/*start*/ 0x1DA75, 14 /* Extend */],
                [/*start*/ 0x1DA76, 0 /* Other */],
                [/*start*/ 0x1DA84, 14 /* Extend */],
                [/*start*/ 0x1DA85, 0 /* Other */],
                [/*start*/ 0x1DA9B, 14 /* Extend */],
                [/*start*/ 0x1DAA0, 0 /* Other */],
                [/*start*/ 0x1DAA1, 14 /* Extend */],
                [/*start*/ 0x1DAB0, 0 /* Other */],
                [/*start*/ 0x1E000, 14 /* Extend */],
                [/*start*/ 0x1E007, 0 /* Other */],
                [/*start*/ 0x1E008, 14 /* Extend */],
                [/*start*/ 0x1E019, 0 /* Other */],
                [/*start*/ 0x1E01B, 14 /* Extend */],
                [/*start*/ 0x1E022, 0 /* Other */],
                [/*start*/ 0x1E023, 14 /* Extend */],
                [/*start*/ 0x1E025, 0 /* Other */],
                [/*start*/ 0x1E026, 14 /* Extend */],
                [/*start*/ 0x1E02B, 0 /* Other */],
                [/*start*/ 0x1E100, 11 /* ALetter */],
                [/*start*/ 0x1E12D, 0 /* Other */],
                [/*start*/ 0x1E130, 14 /* Extend */],
                [/*start*/ 0x1E137, 11 /* ALetter */],
                [/*start*/ 0x1E13E, 0 /* Other */],
                [/*start*/ 0x1E140, 9 /* Numeric */],
                [/*start*/ 0x1E14A, 0 /* Other */],
                [/*start*/ 0x1E14E, 11 /* ALetter */],
                [/*start*/ 0x1E14F, 0 /* Other */],
                [/*start*/ 0x1E2C0, 11 /* ALetter */],
                [/*start*/ 0x1E2EC, 14 /* Extend */],
                [/*start*/ 0x1E2F0, 9 /* Numeric */],
                [/*start*/ 0x1E2FA, 0 /* Other */],
                [/*start*/ 0x1E800, 11 /* ALetter */],
                [/*start*/ 0x1E8C5, 0 /* Other */],
                [/*start*/ 0x1E8D0, 14 /* Extend */],
                [/*start*/ 0x1E8D7, 0 /* Other */],
                [/*start*/ 0x1E900, 11 /* ALetter */],
                [/*start*/ 0x1E944, 14 /* Extend */],
                [/*start*/ 0x1E94B, 11 /* ALetter */],
                [/*start*/ 0x1E94C, 0 /* Other */],
                [/*start*/ 0x1E950, 9 /* Numeric */],
                [/*start*/ 0x1E95A, 0 /* Other */],
                [/*start*/ 0x1EE00, 11 /* ALetter */],
                [/*start*/ 0x1EE04, 0 /* Other */],
                [/*start*/ 0x1EE05, 11 /* ALetter */],
                [/*start*/ 0x1EE20, 0 /* Other */],
                [/*start*/ 0x1EE21, 11 /* ALetter */],
                [/*start*/ 0x1EE23, 0 /* Other */],
                [/*start*/ 0x1EE24, 11 /* ALetter */],
                [/*start*/ 0x1EE25, 0 /* Other */],
                [/*start*/ 0x1EE27, 11 /* ALetter */],
                [/*start*/ 0x1EE28, 0 /* Other */],
                [/*start*/ 0x1EE29, 11 /* ALetter */],
                [/*start*/ 0x1EE33, 0 /* Other */],
                [/*start*/ 0x1EE34, 11 /* ALetter */],
                [/*start*/ 0x1EE38, 0 /* Other */],
                [/*start*/ 0x1EE39, 11 /* ALetter */],
                [/*start*/ 0x1EE3A, 0 /* Other */],
                [/*start*/ 0x1EE3B, 11 /* ALetter */],
                [/*start*/ 0x1EE3C, 0 /* Other */],
                [/*start*/ 0x1EE42, 11 /* ALetter */],
                [/*start*/ 0x1EE43, 0 /* Other */],
                [/*start*/ 0x1EE47, 11 /* ALetter */],
                [/*start*/ 0x1EE48, 0 /* Other */],
                [/*start*/ 0x1EE49, 11 /* ALetter */],
                [/*start*/ 0x1EE4A, 0 /* Other */],
                [/*start*/ 0x1EE4B, 11 /* ALetter */],
                [/*start*/ 0x1EE4C, 0 /* Other */],
                [/*start*/ 0x1EE4D, 11 /* ALetter */],
                [/*start*/ 0x1EE50, 0 /* Other */],
                [/*start*/ 0x1EE51, 11 /* ALetter */],
                [/*start*/ 0x1EE53, 0 /* Other */],
                [/*start*/ 0x1EE54, 11 /* ALetter */],
                [/*start*/ 0x1EE55, 0 /* Other */],
                [/*start*/ 0x1EE57, 11 /* ALetter */],
                [/*start*/ 0x1EE58, 0 /* Other */],
                [/*start*/ 0x1EE59, 11 /* ALetter */],
                [/*start*/ 0x1EE5A, 0 /* Other */],
                [/*start*/ 0x1EE5B, 11 /* ALetter */],
                [/*start*/ 0x1EE5C, 0 /* Other */],
                [/*start*/ 0x1EE5D, 11 /* ALetter */],
                [/*start*/ 0x1EE5E, 0 /* Other */],
                [/*start*/ 0x1EE5F, 11 /* ALetter */],
                [/*start*/ 0x1EE60, 0 /* Other */],
                [/*start*/ 0x1EE61, 11 /* ALetter */],
                [/*start*/ 0x1EE63, 0 /* Other */],
                [/*start*/ 0x1EE64, 11 /* ALetter */],
                [/*start*/ 0x1EE65, 0 /* Other */],
                [/*start*/ 0x1EE67, 11 /* ALetter */],
                [/*start*/ 0x1EE6B, 0 /* Other */],
                [/*start*/ 0x1EE6C, 11 /* ALetter */],
                [/*start*/ 0x1EE73, 0 /* Other */],
                [/*start*/ 0x1EE74, 11 /* ALetter */],
                [/*start*/ 0x1EE78, 0 /* Other */],
                [/*start*/ 0x1EE79, 11 /* ALetter */],
                [/*start*/ 0x1EE7D, 0 /* Other */],
                [/*start*/ 0x1EE7E, 11 /* ALetter */],
                [/*start*/ 0x1EE7F, 0 /* Other */],
                [/*start*/ 0x1EE80, 11 /* ALetter */],
                [/*start*/ 0x1EE8A, 0 /* Other */],
                [/*start*/ 0x1EE8B, 11 /* ALetter */],
                [/*start*/ 0x1EE9C, 0 /* Other */],
                [/*start*/ 0x1EEA1, 11 /* ALetter */],
                [/*start*/ 0x1EEA4, 0 /* Other */],
                [/*start*/ 0x1EEA5, 11 /* ALetter */],
                [/*start*/ 0x1EEAA, 0 /* Other */],
                [/*start*/ 0x1EEAB, 11 /* ALetter */],
                [/*start*/ 0x1EEBC, 0 /* Other */],
                [/*start*/ 0x1F130, 11 /* ALetter */],
                [/*start*/ 0x1F14A, 0 /* Other */],
                [/*start*/ 0x1F150, 11 /* ALetter */],
                [/*start*/ 0x1F16A, 0 /* Other */],
                [/*start*/ 0x1F170, 11 /* ALetter */],
                [/*start*/ 0x1F18A, 0 /* Other */],
                [/*start*/ 0x1F1E6, 18 /* Regional_Indicator */],
                [/*start*/ 0x1F200, 0 /* Other */],
                [/*start*/ 0x1F3FB, 14 /* Extend */],
                [/*start*/ 0x1F400, 0 /* Other */],
                [/*start*/ 0x1FBF0, 9 /* Numeric */],
                [/*start*/ 0x1FBFA, 0 /* Other */],
                [/*start*/ 0xE0001, 13 /* Format */],
                [/*start*/ 0xE0002, 0 /* Other */],
                [/*start*/ 0xE0020, 14 /* Extend */],
                [/*start*/ 0xE0080, 0 /* Other */],
                [/*start*/ 0xE0100, 14 /* Extend */],
                [/*start*/ 0xE01F0, 0 /* Other */],
            ];
        })(data = wordBreakers.data || (wordBreakers.data = {}));
    })(wordBreakers || (wordBreakers = {}));
    var __read = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    };
    // Include the word-breaking data here:
    /// <reference path="./data.ts" />
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * Word breaker based on Unicode Standard Annex #29, Section 4.1:
         * Default Word Boundary Specification.
         *
         * @see http://unicode.org/reports/tr29/#Word_Boundaries
         * @see https://github.com/eddieantonio/unicode-default-word-boundary/tree/v12.0.0
         */
        function default_(text) {
            var boundaries = findBoundaries(text);
            if (boundaries.length == 0) {
                return [];
            }
            // All non-empty strings have at least TWO boundaries at the start and end of
            // the string.
            var spans = [];
            for (var i = 0; i < boundaries.length - 1; i++) {
                var start = boundaries[i];
                var end = boundaries[i + 1];
                var span = new LazySpan(text, start, end);
                if (isNonSpace(span.text)) {
                    spans.push(span);
                    // Preserve a sequence-final space if it exists.  Needed to signal "end of word".
                }
                else if (i == boundaries.length - 2) { // if "we just checked the final boundary"...
                    // We don't want to return the whitespace itself; the correct token is simply ''.
                    span = new LazySpan(text, end, end);
                    spans.push(span);
                }
            }
            return spans;
        }
        wordBreakers.default_ = default_;
        var WORD_BREAK_PROPERTY = wordBreakers.data.WORD_BREAK_PROPERTY;
        /**
         * A span that does not cut out the substring until it absolutely has to!
         */
        var LazySpan = /** @class */ (function () {
            function LazySpan(source, start, end) {
                this._source = source;
                this.start = start;
                this.end = end;
            }
            Object.defineProperty(LazySpan.prototype, "text", {
                get: function () {
                    return this._source.substring(this.start, this.end);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(LazySpan.prototype, "length", {
                get: function () {
                    return this.end - this.start;
                },
                enumerable: true,
                configurable: true
            });
            return LazySpan;
        }());
        /**
         * Returns true when the chunk does not solely consist of whitespace.
         *
         * @param chunk a chunk of text. Starts and ends at word boundaries.
         */
        function isNonSpace(chunk) {
            return !Array.from(chunk).map(property).every(function (wb) {
                return (wb === 3 /* CR */ ||
                    wb === 1 /* LF */ ||
                    wb === 2 /* Newline */ ||
                    wb === 4 /* WSegSpace */);
            });
        }
        /**
         * Yields a series of string indices where a word break should
         * occur. That is, there should be a break BEFORE each string
         * index yielded by this generator.
         *
         * @param text Text to find word boundaries in.
         */
        function findBoundaries(text) {
            var _a, _b, _c;
            // WB1 and WB2: no boundaries if given an empty string.
            if (text.length === 0) {
                // There are no boundaries in an empty string!
                return [];
            }
            // This algorithm works by maintaining a sliding window of four SCALAR VALUES.
            //
            //  - Scalar values? JavaScript strings are NOT actually a string of
            //    Unicode code points; some characters are made up of TWO
            //    JavaScript indices. e.g.,
            //        "💩".length === 2;
            //        "💩"[0] === '\uD83D';
            //        "💩"[1] === '\uDCA9';
            //
            //    These characters that are represented by TWO indices are
            //    called "surrogate pairs". Since we don't want to be in the
            //    "middle" of a character, make sure we're always advancing
            //    by scalar values, and NOT indices. That means, we sometimes
            //    need to advance by TWO indices, not just one.
            //  - Four values? Some rules look at what's to the left of
            //    left, and some look at what's to the right of right. So
            //    keep track of this!
            var boundaries = [];
            var rightPos;
            var lookaheadPos = 0; // lookahead, one scalar value to the right of right.
            // Before the start of the string is also the start of the string.
            var lookbehind;
            var left = 19 /* sot */;
            var right = 19 /* sot */;
            var lookahead = wordbreakPropertyAt(0);
            // Count RIs to make sure we're not splitting emoji flags:
            var nConsecutiveRegionalIndicators = 0;
            do {
                // Shift all positions, one scalar value to the right.
                rightPos = lookaheadPos;
                lookaheadPos = positionAfter(lookaheadPos);
                // Shift all properties, one scalar value to the right.
                _a = __read([left, right, lookahead, wordbreakPropertyAt(lookaheadPos)], 4), lookbehind = _a[0], left = _a[1], right = _a[2], lookahead = _a[3];
                // Break at the start and end of text, unless the text is empty.
                // WB1: Break at start of text...
                if (left === 19 /* sot */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // WB2: Break at the end of text...
                if (right === 20 /* eot */) {
                    boundaries.push(rightPos);
                    break; // Reached the end of the string. We're done!
                }
                // WB3: Do not break within CRLF:
                if (left === 3 /* CR */ && right === 1 /* LF */)
                    continue;
                // WB3b: Otherwise, break after...
                if (left === 2 /* Newline */ ||
                    left === 3 /* CR */ ||
                    left === 1 /* LF */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // WB3a: ...and before newlines
                if (right === 2 /* Newline */ ||
                    right === 3 /* CR */ ||
                    right === 1 /* LF */) {
                    boundaries.push(rightPos);
                    continue;
                }
                // TODO: WB3c is not implemented, due to its complex, error-prone
                // implementation, requiring a ginormous regexp, and the fact that
                // the only thing it does is prevent big emoji sequences from being
                // split up, like 🧚🏼‍♂️
                // https://www.unicode.org/Public/emoji/12.0/emoji-zwj-sequences.txt
                // WB3d: Keep horizontal whitespace together
                if (left === 4 /* WSegSpace */ && right == 4 /* WSegSpace */)
                    continue;
                // WB4: Ignore format and extend characters
                // This is to keep grapheme clusters together!
                // See: Section 6.2: https://unicode.org/reports/tr29/#Grapheme_Cluster_and_Format_Rules
                // N.B.: The rule about "except after sot, CR, LF, and
                // Newline" already been by WB1, WB2, WB3a, and WB3b above.
                while (right === 13 /* Format */ ||
                    right === 14 /* Extend */ ||
                    right === 16 /* ZWJ */) {
                    // Continue advancing in the string, as if these
                    // characters do not exist. DO NOT update left and
                    // lookbehind however!
                    _b = __read([lookaheadPos, positionAfter(lookaheadPos)], 2), rightPos = _b[0], lookaheadPos = _b[1];
                    _c = __read([lookahead, wordbreakPropertyAt(lookaheadPos)], 2), right = _c[0], lookahead = _c[1];
                }
                // In ignoring the characters in the previous loop, we could
                // have fallen off the end of the string, so end the loop
                // prematurely if that happens!
                if (right === 20 /* eot */) {
                    boundaries.push(rightPos);
                    break;
                }
                // WB4 (continued): Lookahead must ALSO ignore these format,
                // extend, ZWJ characters!
                while (lookahead === 13 /* Format */ ||
                    lookahead === 14 /* Extend */ ||
                    lookahead === 16 /* ZWJ */) {
                    // Continue advancing in the string, as if these
                    // characters do not exist. DO NOT update left and right,
                    // however!
                    lookaheadPos = positionAfter(lookaheadPos);
                    lookahead = wordbreakPropertyAt(lookaheadPos);
                }
                // WB5: Do not break between most letters.
                if (isAHLetter(left) && isAHLetter(right))
                    continue;
                // Do not break across certain punctuation
                // WB6: (Don't break before apostrophes in contractions)
                if (isAHLetter(left) && isAHLetter(lookahead) &&
                    (right === 10 /* MidLetter */ || isMidNumLetQ(right)))
                    continue;
                // WB7: (Don't break after apostrophes in contractions)
                if (isAHLetter(lookbehind) && isAHLetter(right) &&
                    (left === 10 /* MidLetter */ || isMidNumLetQ(left)))
                    continue;
                // WB7a
                if (left === 15 /* Hebrew_Letter */ && right === 6 /* Single_Quote */)
                    continue;
                // WB7b
                if (left === 15 /* Hebrew_Letter */ && right === 5 /* Double_Quote */ &&
                    lookahead === 15 /* Hebrew_Letter */)
                    continue;
                // WB7c
                if (lookbehind === 15 /* Hebrew_Letter */ && left === 5 /* Double_Quote */ &&
                    right === 15 /* Hebrew_Letter */)
                    continue;
                // Do not break within sequences of digits, or digits adjacent to letters.
                // e.g., "3a" or "A3"
                // WB8
                if (left === 9 /* Numeric */ && right === 9 /* Numeric */)
                    continue;
                // WB9
                if (isAHLetter(left) && right === 9 /* Numeric */)
                    continue;
                // WB10
                if (left === 9 /* Numeric */ && isAHLetter(right))
                    continue;
                // Do not break within sequences, such as 3.2, 3,456.789
                // WB11
                if (lookbehind === 9 /* Numeric */ && right === 9 /* Numeric */ &&
                    (left === 7 /* MidNum */ || isMidNumLetQ(left)))
                    continue;
                // WB12
                if (left === 9 /* Numeric */ && lookahead === 9 /* Numeric */ &&
                    (right === 7 /* MidNum */ || isMidNumLetQ(right)))
                    continue;
                // WB13: Do not break between Katakana
                if (left === 17 /* Katakana */ && right === 17 /* Katakana */)
                    continue;
                // Do not break from extenders (e.g., U+202F NARROW NO-BREAK SPACE)
                // WB13a
                if ((isAHLetter(left) ||
                    left === 9 /* Numeric */ ||
                    left === 17 /* Katakana */ ||
                    left === 12 /* ExtendNumLet */) &&
                    right === 12 /* ExtendNumLet */)
                    continue;
                // WB13b
                if ((isAHLetter(right) ||
                    right === 9 /* Numeric */ ||
                    right === 17 /* Katakana */) && left === 12 /* ExtendNumLet */)
                    continue;
                // WB15 & WB16:
                // Do not break within emoji flag sequences. That is, do not break between
                // regional indicator (RI) symbols if there is an odd number of RI
                // characters before the break point.
                if (right === 18 /* Regional_Indicator */) {
                    // Emoji flags are actually composed of TWO scalar values, each being a
                    // "regional indicator". These indicators correspond to Latin letters. Put
                    // two of them together, and they spell out an ISO 3166-1-alpha-2 country
                    // code. Since these always come in pairs, NEVER split the pairs! So, if
                    // we happen to be inside the middle of an odd numbered of
                    // Regional_Indicators, DON'T SPLIT IT!
                    nConsecutiveRegionalIndicators += 1;
                    if ((nConsecutiveRegionalIndicators % 2) == 1) {
                        continue;
                    }
                }
                else {
                    nConsecutiveRegionalIndicators = 0;
                }
                // WB999: Otherwise, break EVERYWHERE (including around ideographs)
                boundaries.push(rightPos);
            } while (rightPos < text.length);
            return boundaries;
            ///// Internal utility functions /////
            /**
             * Returns the position of the start of the next scalar value. This jumps
             * over surrogate pairs.
             *
             * If asked for the character AFTER the end of the string, this always
             * returns the length of the string.
             */
            function positionAfter(pos) {
                if (pos >= text.length) {
                    return text.length;
                }
                else if (isStartOfSurrogatePair(text[pos])) {
                    return pos + 2;
                }
                return pos + 1;
            }
            /**
             * Return the value of the Word_Break property at the given string index.
             * @param pos position in the text.
             */
            function wordbreakPropertyAt(pos) {
                if (pos < 0) {
                    return 19 /* sot */; // Always "start of string" before the string starts!
                }
                else if (pos >= text.length) {
                    return 20 /* eot */; // Always "end of string" after the string ends!
                }
                else if (isStartOfSurrogatePair(text[pos])) {
                    // Surrogate pairs the next TWO items from the string!
                    return property(text[pos] + text[pos + 1]);
                }
                return property(text[pos]);
            }
            // Word_Break rule macros
            // See: https://unicode.org/reports/tr29/#WB_Rule_Macros
            function isAHLetter(prop) {
                return prop === 11 /* ALetter */ ||
                    prop === 15 /* Hebrew_Letter */;
            }
            function isMidNumLetQ(prop) {
                return prop === 8 /* MidNumLet */ ||
                    prop === 6 /* Single_Quote */;
            }
        }
        function isStartOfSurrogatePair(character) {
            var codeUnit = character.charCodeAt(0);
            return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;
        }
        /**
         * Return the Word_Break property value for a character.
         * Note that
         * @param character a scalar value
         */
        function property(character) {
            // This MUST be a scalar value.
            // TODO: remove dependence on character.codepointAt()?
            var codepoint = character.codePointAt(0);
            return searchForProperty(codepoint, 0, WORD_BREAK_PROPERTY.length - 1);
        }
        /**
         * Binary search for the word break property of a given CODE POINT.
         */
        function searchForProperty(codePoint, left, right) {
            // All items that are not found in the array are assigned the 'Other' property.
            if (right < left) {
                return 0 /* Other */;
            }
            var midpoint = left + ~~((right - left) / 2);
            var candidate = WORD_BREAK_PROPERTY[midpoint];
            var nextRange = WORD_BREAK_PROPERTY[midpoint + 1];
            var startOfNextRange = nextRange ? nextRange[0 /* Start */] : Infinity;
            if (codePoint < candidate[0 /* Start */]) {
                return searchForProperty(codePoint, left, midpoint - 1);
            }
            else if (codePoint >= startOfNextRange) {
                return searchForProperty(codePoint, midpoint + 1, right);
            }
            // We found it!
            return candidate[1 /* Value */];
        }
    })(wordBreakers || (wordBreakers = {}));
    // We cannot export a member whose name is a reserved word when
    // implementing a namespace, BUT we can manually make the
    // assignment and **declare** it as part of the namespace.
    wordBreakers['default'] = wordBreakers.default_;
    var wordBreakers;
    (function (wordBreakers) {
        /**
         * A **VERY** dumb word breaker that simply splits at words. Do not use this
         * word breaker!
         *
         * @param phrase The phrase in which to break words.
         * @deprecated Use a word breaker tailored to your language instead!
         */
        function placeholder(phrase) {
            var nextStart = 0;
            return phrase.split(/\s+/).map(function (utterance) {
                // XXX: The indices are NOT accurate to the original phrase!
                var span = {
                    start: nextStart,
                    end: nextStart + utterance.length,
                    text: utterance,
                    length: utterance.length
                };
                nextStart = span.end;
                return span;
            });
        }
        wordBreakers.placeholder = placeholder;
    })(wordBreakers || (wordBreakers = {}));
    /// <reference path="./ascii.ts" />
    /// <reference path="./default/index.ts" />
    /// <reference path="./placeholder.ts" />
    // Let the word breakers be available both in the browser and in Node.
    if (typeof module !== "undefined" && module.exports) {
        module.exports['wordBreakers'] = wordBreakers;
    }
    var models;
    (function (models) {
        models.SENTINEL_CODE_UNIT = '\uFDD0';
        function applyTransform(transform, context) {
            // First, get the current context
            var fullLeftContext = context.left || '';
            var lLen = fullLeftContext.kmwLength();
            var lDel = lLen < transform.deleteLeft ? lLen : transform.deleteLeft;
            var leftContext = fullLeftContext.kmwSubstr(0, lLen - lDel) + (transform.insert || '');
            var fullRightContext = context.right || '';
            var rLen = fullRightContext.kmwLength();
            var rDel = rLen < transform.deleteRight ? rLen : transform.deleteRight;
            var rightContext = fullRightContext.kmwSubstr(rDel);
            return {
                left: leftContext,
                right: rightContext,
                startOfBuffer: context.startOfBuffer,
                endOfBuffer: context.endOfBuffer
            };
        }
        models.applyTransform = applyTransform;
        /**
         * Merges two Transforms as if they were applied to a `Context` successively.
         * @param first
         * @param second
         */
        function buildMergedTransform(first, second) {
            // These exist to avoid parameter mutation.
            var mergedFirstInsert = first.insert;
            var mergedSecondDelete = second.deleteLeft;
            // The 'fun' case:  the second Transform wants to delete something from the first.
            if (second.deleteLeft) {
                var firstLength = first.insert.kmwLength();
                if (firstLength <= second.deleteLeft) {
                    mergedFirstInsert = '';
                    mergedSecondDelete = second.deleteLeft - firstLength;
                }
                else {
                    mergedFirstInsert = first.insert.kmwSubstr(0, firstLength - second.deleteLeft);
                    mergedSecondDelete = 0;
                }
            }
            return {
                insert: mergedFirstInsert + second.insert,
                deleteLeft: first.deleteLeft + mergedSecondDelete,
                // As `first` would affect the context before `second` could take effect,
                // this is the correct way to merge `deleteRight`.
                deleteRight: (first.deleteRight || 0) + (second.deleteRight || 0)
            };
        }
        models.buildMergedTransform = buildMergedTransform;
        function isHighSurrogate(codeUnit) {
            if (typeof codeUnit == 'string') {
                codeUnit = codeUnit.charCodeAt(0);
            }
            return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;
        }
        models.isHighSurrogate = isHighSurrogate;
        function isLowSurrogate(codeUnit) {
            if (typeof codeUnit == 'string') {
                codeUnit = codeUnit.charCodeAt(0);
            }
            return codeUnit >= 0xDC00 && codeUnit <= 0xDFFF;
        }
        models.isLowSurrogate = isLowSurrogate;
        function isSentinel(char) {
            return char == models.SENTINEL_CODE_UNIT;
        }
        models.isSentinel = isSentinel;
        function transformToSuggestion(transform, p) {
            var suggestion = {
                transform: transform,
                transformId: transform.id,
                displayAs: transform.insert
            };
            if (p === 0 || p) {
                suggestion.p = p;
            }
            return suggestion;
        }
        models.transformToSuggestion = transformToSuggestion;
        function defaultApplyCasing(casing, text) {
            switch (casing) {
                case 'lower':
                    return text.toLowerCase();
                case 'upper':
                    return text.toUpperCase();
                case 'initial':
                    // The length of the first code unit, as measured in code points.
                    var headUnitLength = 1;
                    // Is the first character a high surrogate, indicating possible use of UTF-16 
                    // surrogate pairs?  Also, is the string long enough for there to BE a pair?
                    if (text.length > 1 && isHighSurrogate(text.charAt(0))) {
                        // It's possible, so now we check for low surrogates.
                        if (isLowSurrogate(text.charCodeAt(1))) {
                            // We have a surrogate pair; this pair is the 'first' character.
                            headUnitLength = 2;
                        }
                    }
                    // Capitalizes the first code unit of the string, leaving the rest intact.
                    return text.substring(0, headUnitLength).toUpperCase().concat(text.substring(headUnitLength));
            }
        }
        models.defaultApplyCasing = defaultApplyCasing;
    })(models || (models = {}));
    /**
     * @file priority-queue.ts
     *
     * Defines a mildly abstracted priority queue implementation.
     */
    var models;
    (function (models) {
        var PriorityQueue = /** @class */ (function () {
            /**
             * Constructs an empty priority queue.
             * @param comparator A `Comparator` returning negative values when and only when
             * the first parameter should precede the second parameter.
             */
            function PriorityQueue(comparator, initialEntries) {
                if (initialEntries === void 0) {
                    initialEntries = [];
                }
                // TODO: We may wish to allow options specifying a limit or threshold for adding
                // items to the priority queue.  Possibly both.
                //
                // When that time comes, consider a min-max heap.
                // https://en.wikipedia.org/wiki/Min-max_heap
                this.comparator = comparator;
                this.heap = Array.from(initialEntries);
                this.heapify();
            }
            PriorityQueue.leftChildIndex = function (index) {
                return index * 2 + 1;
            };
            PriorityQueue.rightChildIndex = function (index) {
                return index * 2 + 2;
            };
            PriorityQueue.parentIndex = function (index) {
                return Math.floor((index - 1) / 2);
            };
            PriorityQueue.prototype.heapify = function (start, end) {
                if (start == undefined || end == undefined) {
                    this.heapify(0, this.count - 1);
                }
                // Use of 'indices' here is a bit of a customization.
                // At the cost of (temporary) extra storage space, we can more efficiently enqueue
                // multiple elements simultaneously.
                var queuedIndices = [];
                var lastParent = -1;
                for (var i = end; i >= start; i--) {
                    var parent = PriorityQueue.parentIndex(i);
                    if (this.siftDown(i) && parent < start && lastParent != parent) {
                        // We only need to queue examination for a heap node if its children have changed
                        // and it isn't already being examined.
                        queuedIndices.push(parent);
                        lastParent = parent;
                    }
                }
                lastParent = -1;
                while (queuedIndices.length > 0) {
                    var index = queuedIndices.shift();
                    var parent = PriorityQueue.parentIndex(index);
                    if (this.siftDown(index) && parent >= 0 && lastParent != parent) {
                        // We only need to queue examination for a heap node if its children have changed.
                        queuedIndices.push(parent);
                        lastParent = parent;
                    }
                }
            };
            Object.defineProperty(PriorityQueue.prototype, "count", {
                /**
                 * Returns the number of elements currently held by the priority queue.
                 */
                get: function () {
                    return this.heap.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Returns the highest-priority item within the priority queue.
             * <p>
             * Is O(1).
             */
            PriorityQueue.prototype.peek = function () {
                return this.heap[0]; // undefined if it doesn't exist... which is completely correct.
            };
            /**
             * Inserts a new element into the priority queue, placing it in order.
             * <p>
             * Is O(log N), where N = # of items in the priority queue.
             * @param element
             */
            PriorityQueue.prototype.enqueue = function (element) {
                var index = this.heap.length;
                this.heap.push(element);
                var parent = PriorityQueue.parentIndex;
                var parentIndex = parent(index);
                while (index !== 0 && this.comparator(this.heap[index], this.heap[parentIndex]) < 0) {
                    var a = this.heap[index];
                    this.heap[index] = this.heap[parentIndex];
                    this.heap[parentIndex] = a;
                    index = parentIndex;
                    parentIndex = parent(index);
                }
            };
            /**
             * Efficiently batch-enqueues multiple elements.
             * Worst-case is the _better_ of the following:
             * - O(`elements.count` + `heap.count`) - large element counts will trigger in-place
             * heap reconstruction.
             * - O(`elements.count` * log(`heap.count`)) - logarithmic when elements.count << heap.count
             * @param elements A group of elements to enqueue simultaneously.
             */
            PriorityQueue.prototype.enqueueAll = function (elements) {
                if (elements.length == 0) {
                    return;
                }
                var firstIndex = this.count;
                this.heap = this.heap.concat(elements);
                var firstParent = PriorityQueue.parentIndex(firstIndex);
                // The 'parent' of index 0 will return -1, which is illegal.
                this.heapify(firstParent >= 0 ? firstParent : 0, PriorityQueue.parentIndex(this.count - 1));
            };
            /**
             * Removes the highest-priority element from the queue, returning it.
             * <p>
             * Is O(log N), where N = number of items in the priority queue.
             */
            PriorityQueue.prototype.dequeue = function () {
                if (this.count == 0) {
                    return undefined;
                }
                var root = this.heap[0];
                var tail = this.heap.pop();
                if (this.heap.length > 0) {
                    this.heap[0] = tail;
                    this.siftDown(0);
                }
                return root;
            };
            /**
             * Compares the entry at the specified index against its children,
             * propagating it downward within the heap until heap requirements are specified.
             * <p>
             * Is O(log N), where N = number of items in the priority queue.
             *
             * @param index The index of the top-most node that must be examined
             * for repositioning.
             * @returns `true` if a swap occurred, `false` otherwise.
             */
            PriorityQueue.prototype.siftDown = function (index) {
                var leftIndex = PriorityQueue.leftChildIndex(index);
                var rightIndex = PriorityQueue.rightChildIndex(index);
                var topMostIndex = index;
                if (leftIndex < this.heap.length && this.comparator(this.heap[leftIndex], this.heap[topMostIndex]) < 0) {
                    topMostIndex = leftIndex;
                }
                if (rightIndex < this.heap.length && this.comparator(this.heap[rightIndex], this.heap[topMostIndex]) < 0) {
                    topMostIndex = rightIndex;
                }
                if (topMostIndex != index) {
                    var a = this.heap[index];
                    this.heap[index] = this.heap[topMostIndex];
                    this.heap[topMostIndex] = a;
                    this.siftDown(topMostIndex);
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
             * Returns an array containing all entries of the priority queue.
             * Altering the returned array will not affect the queue, but mutating
             * the array's elements can cause unintended side effects.
             *
             * This function makes no guarantees on the ordering of the returned elements;
             * they will almost certainly be unsorted.
             */
            PriorityQueue.prototype.toArray = function () {
                return Array.from(this.heap);
            };
            return PriorityQueue;
        }());
        models.PriorityQueue = PriorityQueue;
    })(models || (models = {}));
    // While we _could_ define this within @keymanapp/models-wordbreakers instead, it's probably
    // better to leave that package as _just_ the wordbreakers.  
    var models;
    (function (models) {
        function tokenize(wordBreaker, context) {
            context = context || {
                left: undefined,
                startOfBuffer: undefined,
                endOfBuffer: undefined
            };
            var leftSpans = wordBreaker(context.left || '') || [];
            var rightSpans = wordBreaker(context.right || '') || [];
            var tokenization = {
                left: leftSpans.map(function (span) { return span.text; }),
                right: rightSpans.map(function (span) { return span.text; }),
                // A default initialization of the value.
                caretSplitsToken: false
            };
            // Now the hard part - determining whether or not the caret caused a token split.
            if (leftSpans.length > 0 && rightSpans.length > 0) {
                var leftTail = leftSpans[leftSpans.length - 1];
                var rightHead = rightSpans[0];
                // If tokenization includes all characters on each side of the caret,
                // we have a good candidate for a caret-splitting scenario.
                var leftSuffixWordbreak = leftTail.end != context.left.length;
                var rightPrefixWordbreak = rightHead.start != 0;
                if (leftSuffixWordbreak || rightPrefixWordbreak) {
                    // Bypass the final test, as we already know the caret didn't split a token.
                    // (The tokenization process already removed characters between the two.)
                    return tokenization;
                }
                // Worth note - some languages don't use wordbreaking characters.  So, a final check:
                //
                // Does the wordbreaker split a merge of the 'two center' tokens?
                // If not, then the caret is responsible for the split.
                if (wordBreaker(leftTail.text + rightHead.text).length == 1) {
                    tokenization.caretSplitsToken = true;
                }
            }
            return tokenization;
        }
        models.tokenize = tokenize;
        /**
         * Get the last word of the phrase before the caret or nothing.
         * @param fullLeftContext the entire left context of the string.
         */
        function getLastPreCaretToken(wordBreaker, context) {
            var tokenization = tokenize(wordBreaker, context);
            if (tokenization.left.length > 0) {
                return tokenization.left.pop();
            }
            return '';
        }
        models.getLastPreCaretToken = getLastPreCaretToken;
        // While it is currently identical to getLastWord, this may change in the future.
        // It's best not to write ourselves into a corner on this one, as disambiguating later
        // would likely be pretty painful.
        function wordbreak(wordBreaker, context) {
            return getLastPreCaretToken(wordBreaker, context);
        }
        models.wordbreak = wordbreak;
    })(models || (models = {}));
    /*
     * Copyright (c) 2019 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2019 SIL International
     * Copyright (c) 2015–2017 Conrad Irwin
     * Copyright (c) 2011–2015 Marc Campbell
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    var __generator = (this && this.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    // Worth noting:  we're starting to get quite a 'library' of common model/LMLayer functionality.
    // Should probably make a 'lm-utils' submodule.
    /// <reference path="common.ts" />
    /// <reference path="priority-queue.ts" />
    /// <reference path="tokenization.ts" />
    /**
     * @file trie-model.ts
     *
     * Defines a simple word list (unigram) model.
     */
    var models;
    (function (models) {
        /** Upper bound on the amount of suggestions to generate. */
        var MAX_SUGGESTIONS = 12;
        /**
         * @class TrieModel
         *
         * Defines a trie-backed word list model, or the unigram model.
         * Unigram models throw away all preceding words, and search
         * for the next word exclusively. As such, they can perform simple
         * prefix searches within words, however they are not very good
         * at predicting the next word.
         */
        var TrieModel = /** @class */ (function () {
            function TrieModel(trieData, options) {
                if (options === void 0) {
                    options = {};
                }
                this.languageUsesCasing = options.languageUsesCasing;
                this.applyCasing = options.applyCasing;
                this._trie = new Trie(trieData['root'], trieData['totalWeight'], options.searchTermToKey || defaultSearchTermToKey);
                this.breakWords = options.wordBreaker || getDefaultWordBreaker();
                this.punctuation = options.punctuation;
            }
            TrieModel.prototype.configure = function (capabilities) {
                return this.configuration = {
                    leftContextCodePoints: capabilities.maxLeftContextCodePoints,
                    rightContextCodePoints: capabilities.maxRightContextCodePoints
                };
            };
            TrieModel.prototype.toKey = function (text) {
                return this._trie.toKey(text);
            };
            TrieModel.prototype.predict = function (transform, context) {
                // Special-case the empty buffer/transform: return the top suggestions.
                if (!transform.insert && !context.left && !context.right && context.startOfBuffer && context.endOfBuffer) {
                    return makeDistribution(this._trie.firstN(MAX_SUGGESTIONS).map(function (_a) {
                        var text = _a.text, p = _a.p;
                        return ({
                            transform: {
                                insert: text,
                                deleteLeft: 0
                            },
                            displayAs: text,
                            p: p
                        });
                    }));
                }
                // Compute the results of the keystroke:
                var newContext = models.applyTransform(transform, context);
                // Computes the different in word length after applying the transform above.
                var leftDelOffset = transform.deleteLeft - transform.insert.kmwLength();
                // All text to the left of the cursor INCLUDING anything that has
                // just been typed.
                var prefix = models.getLastPreCaretToken(this.breakWords, newContext);
                // Return suggestions from the trie.
                return makeDistribution(this._trie.lookup(prefix).map(function (_a) {
                    var text = _a.text, p = _a.p;
                    return models.transformToSuggestion({
                        insert: text,
                        // Delete whatever the prefix that the user wrote.
                        deleteLeft: leftDelOffset + prefix.kmwLength()
                        // Note: a separate capitalization/orthography engine can take this
                        // result and transform it as needed.
                    }, p);
                }));
                /* Helper */
                function makeDistribution(suggestions) {
                    var e_2, _a;
                    var distribution = [];
                    try {
                        for (var suggestions_2 = __values(suggestions), suggestions_2_1 = suggestions_2.next(); !suggestions_2_1.done; suggestions_2_1 = suggestions_2.next()) {
                            var s = suggestions_2_1.value;
                            distribution.push({ sample: s, p: s.p });
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (suggestions_2_1 && !suggestions_2_1.done && (_a = suggestions_2.return))
                                _a.call(suggestions_2);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                    return distribution;
                }
            };
            Object.defineProperty(TrieModel.prototype, "wordbreaker", {
                get: function () {
                    return this.breakWords;
                },
                enumerable: true,
                configurable: true
            });
            TrieModel.prototype.traverseFromRoot = function () {
                return new TrieModel.Traversal(this._trie['root'], '');
            };
            TrieModel.Traversal = /** @class */ (function () {
                function class_1(root, prefix) {
                    this.root = root;
                    this.prefix = prefix;
                }
                class_1.prototype.children = function () {
                    var root, _loop_1, this_1, _a, _b, entry, e_3_1, prefix_1, children, _loop_2, children_1, children_1_1, key, e_4_1;
                    var e_3, _c, e_4, _d;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0:
                                root = this.root;
                                if (!(root.type == 'internal'))
                                    return [3 /*break*/, 9];
                                _loop_1 = function (entry) {
                                    var entryNode, internalNode_1, _loop_3, _a, _b, lowSurrogate, e_5_1, fullText, prefix_2, prefix_3;
                                    var e_5, _c;
                                    return __generator(this, function (_d) {
                                        switch (_d.label) {
                                            case 0:
                                                entryNode = root.children[entry];
                                                if (!models.isHighSurrogate(entry))
                                                    return [3 /*break*/, 12];
                                                if (!(entryNode.type == 'internal'))
                                                    return [3 /*break*/, 9];
                                                internalNode_1 = entryNode;
                                                _loop_3 = function (lowSurrogate) {
                                                    var prefix;
                                                    return __generator(this, function (_a) {
                                                        switch (_a.label) {
                                                            case 0:
                                                                prefix = this_1.prefix + entry + lowSurrogate;
                                                                return [4 /*yield*/, {
                                                                        char: entry + lowSurrogate,
                                                                        traversal: function () { return new TrieModel.Traversal(internalNode_1.children[lowSurrogate], prefix); }
                                                                    }];
                                                            case 1:
                                                                _a.sent();
                                                                return [2 /*return*/];
                                                        }
                                                    });
                                                };
                                                _d.label = 1;
                                            case 1:
                                                _d.trys.push([1, 6, 7, 8]);
                                                _a = (e_5 = void 0, __values(internalNode_1.values)), _b = _a.next();
                                                _d.label = 2;
                                            case 2:
                                                if (!!_b.done)
                                                    return [3 /*break*/, 5];
                                                lowSurrogate = _b.value;
                                                return [5 /*yield**/, _loop_3(lowSurrogate)];
                                            case 3:
                                                _d.sent();
                                                _d.label = 4;
                                            case 4:
                                                _b = _a.next();
                                                return [3 /*break*/, 2];
                                            case 5: return [3 /*break*/, 8];
                                            case 6:
                                                e_5_1 = _d.sent();
                                                e_5 = { error: e_5_1 };
                                                return [3 /*break*/, 8];
                                            case 7:
                                                try {
                                                    if (_b && !_b.done && (_c = _a.return))
                                                        _c.call(_a);
                                                }
                                                finally {
                                                    if (e_5)
                                                        throw e_5.error;
                                                }
                                                return [7 /*endfinally*/];
                                            case 8: return [3 /*break*/, 11];
                                            case 9:
                                                fullText = entryNode.entries[0].key;
                                                entry = entry + fullText[this_1.prefix.length + 1]; // The other half of the non-BMP char.
                                                prefix_2 = this_1.prefix + entry;
                                                return [4 /*yield*/, {
                                                        char: entry,
                                                        traversal: function () { return new TrieModel.Traversal(entryNode, prefix_2); }
                                                    }];
                                            case 10:
                                                _d.sent();
                                                _d.label = 11;
                                            case 11: return [3 /*break*/, 16];
                                            case 12:
                                                if (!models.isSentinel(entry))
                                                    return [3 /*break*/, 13];
                                                return [2 /*return*/, "continue"];
                                            case 13:
                                                if (!!entry)
                                                    return [3 /*break*/, 14];
                                                return [2 /*return*/, "continue"];
                                            case 14:
                                                prefix_3 = this_1.prefix + entry;
                                                return [4 /*yield*/, {
                                                        char: entry,
                                                        traversal: function () { return new TrieModel.Traversal(entryNode, prefix_3); }
                                                    }];
                                            case 15:
                                                _d.sent();
                                                _d.label = 16;
                                            case 16: return [2 /*return*/];
                                        }
                                    });
                                };
                                this_1 = this;
                                _e.label = 1;
                            case 1:
                                _e.trys.push([1, 6, 7, 8]);
                                _a = __values(root.values), _b = _a.next();
                                _e.label = 2;
                            case 2:
                                if (!!_b.done)
                                    return [3 /*break*/, 5];
                                entry = _b.value;
                                return [5 /*yield**/, _loop_1(entry)];
                            case 3:
                                _e.sent();
                                _e.label = 4;
                            case 4:
                                _b = _a.next();
                                return [3 /*break*/, 2];
                            case 5: return [3 /*break*/, 8];
                            case 6:
                                e_3_1 = _e.sent();
                                e_3 = { error: e_3_1 };
                                return [3 /*break*/, 8];
                            case 7:
                                try {
                                    if (_b && !_b.done && (_c = _a.return))
                                        _c.call(_a);
                                }
                                finally {
                                    if (e_3)
                                        throw e_3.error;
                                }
                                return [7 /*endfinally*/];
                            case 8: return [2 /*return*/];
                            case 9:
                                prefix_1 = this.prefix;
                                children = root.entries.filter(function (entry) {
                                    return entry.key != prefix_1 && prefix_1.length < entry.key.length;
                                });
                                _loop_2 = function (key) {
                                    var nodeKey;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                nodeKey = key[prefix_1.length];
                                                if (models.isHighSurrogate(nodeKey)) {
                                                    // Merge the other half of an SMP char in!
                                                    nodeKey = nodeKey + key[prefix_1.length + 1];
                                                }
                                                return [4 /*yield*/, {
                                                        char: nodeKey,
                                                        traversal: function () { return new TrieModel.Traversal(root, prefix_1 + nodeKey); }
                                                    }];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                };
                                _e.label = 10;
                            case 10:
                                _e.trys.push([10, 15, 16, 17]);
                                children_1 = __values(children), children_1_1 = children_1.next();
                                _e.label = 11;
                            case 11:
                                if (!!children_1_1.done)
                                    return [3 /*break*/, 14];
                                key = children_1_1.value.key;
                                return [5 /*yield**/, _loop_2(key)];
                            case 12:
                                _e.sent();
                                _e.label = 13;
                            case 13:
                                children_1_1 = children_1.next();
                                return [3 /*break*/, 11];
                            case 14: return [3 /*break*/, 17];
                            case 15:
                                e_4_1 = _e.sent();
                                e_4 = { error: e_4_1 };
                                return [3 /*break*/, 17];
                            case 16:
                                try {
                                    if (children_1_1 && !children_1_1.done && (_d = children_1.return))
                                        _d.call(children_1);
                                }
                                finally {
                                    if (e_4)
                                        throw e_4.error;
                                }
                                return [7 /*endfinally*/];
                            case 17:
                                ;
                                return [2 /*return*/];
                        }
                    });
                };
                Object.defineProperty(class_1.prototype, "entries", {
                    get: function () {
                        if (this.root.type == 'leaf') {
                            var prefix_4 = this.prefix;
                            var matches = this.root.entries.filter(function (entry) {
                                return entry.key == prefix_4;
                            });
                            return matches.map(function (value) { return value.content; });
                        }
                        else {
                            var matchingLeaf = this.root.children[models.SENTINEL_CODE_UNIT];
                            if (matchingLeaf && matchingLeaf.type == 'leaf') {
                                return matchingLeaf.entries.map(function (value) { return value.content; });
                            }
                            else {
                                return [];
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                return class_1;
            }());
            return TrieModel;
        }());
        models.TrieModel = TrieModel;
        ;
        /**
         * Wrapper class for the trie and its nodes.
         */
        var Trie = /** @class */ (function () {
            function Trie(root, totalWeight, wordform2key) {
                this.root = root;
                this.toKey = wordform2key;
                this.totalWeight = totalWeight;
            }
            /**
             * Lookups an arbitrary prefix (a query) in the trie. Returns the top 3
             * results in sorted order.
             *
             * @param prefix
             */
            Trie.prototype.lookup = function (prefix) {
                var searchKey = this.toKey(prefix);
                var lowestCommonNode = findPrefix(this.root, searchKey);
                if (lowestCommonNode === null) {
                    return [];
                }
                return getSortedResults(lowestCommonNode, searchKey, this.totalWeight);
            };
            /**
             * Returns the top N suggestions from the trie.
             * @param n How many suggestions, maximum, to return.
             */
            Trie.prototype.firstN = function (n) {
                return getSortedResults(this.root, '', this.totalWeight, n);
            };
            return Trie;
        }());
        /**
         * Finds the deepest descendent in the trie with the given prefix key.
         *
         * This means that a search in the trie for a given prefix has a best-case
         * complexity of O(m) where m is the length of the prefix.
         *
         * @param key The prefix to search for.
         * @param index The index in the prefix. Initially 0.
         */
        function findPrefix(node, key, index) {
            if (index === void 0) {
                index = 0;
            }
            // An important note - the Trie itself is built on a per-JS-character basis,
            // not on a UTF-8 character-code basis.
            if (node.type === 'leaf' || index === key.length) {
                return node;
            }
            // So, for SMP models, we need to match each char of the supplementary pair
            // in sequence.  Each has its own node in the Trie.
            var char = key[index];
            if (node.children[char]) {
                return findPrefix(node.children[char], key, index + 1);
            }
            return null;
        }
        /**
         * Returns all entries matching the given prefix, in descending order of
         * weight.
         *
         * @param prefix  the prefix to match.
         * @param results the current results
         * @param queue
         */
        function getSortedResults(node, prefix, N, limit) {
            var e_6, _a;
            if (limit === void 0) {
                limit = MAX_SUGGESTIONS;
            }
            var queue = new models.PriorityQueue(function (a, b) {
                // In case of Trie compilation issues that emit `null` or `undefined`
                return (b ? b.weight : 0) - (a ? a.weight : 0);
            });
            var results = [];
            if (node.type === 'leaf') {
                try {
                    // Assuming the values are sorted, we can just add all of the values in the
                    // leaf, until we reach the limit.
                    for (var _b = __values(node.entries), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var item = _c.value;
                        if (item.key.startsWith(prefix)) {
                            var content = item.content, weight = item.weight;
                            results.push({
                                text: content,
                                p: weight / N
                            });
                            if (results.length >= limit) {
                                return results;
                            }
                        }
                    }
                }
                catch (e_6_1) {
                    e_6 = { error: e_6_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_6)
                            throw e_6.error;
                    }
                }
            }
            else {
                queue.enqueue(node);
                var next = void 0;
                var _loop_4 = function () {
                    if (isNode(next)) {
                        // When a node is next up in the queue, that means that next least
                        // likely suggestion is among its decsendants.
                        // So we search all of its descendants!
                        if (next.type === 'leaf') {
                            queue.enqueueAll(next.entries);
                        }
                        else {
                            // XXX: alias `next` so that TypeScript can be SURE that internal is
                            // in fact an internal node. Because of the callback binding to the
                            // original definition of node (i.e., a Node | Entry), this will not
                            // type-check otherwise.
                            var internal_1 = next;
                            queue.enqueueAll(next.values.map(function (char) {
                                return internal_1.children[char];
                            }));
                        }
                    }
                    else {
                        // When an entry is up next in the queue, we just add its contents to
                        // the results!
                        results.push({
                            text: next.content,
                            p: next.weight / N
                        });
                        if (results.length >= limit) {
                            return { value: results };
                        }
                    }
                };
                while (next = queue.dequeue()) {
                    var state_1 = _loop_4();
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            return results;
        }
        /** TypeScript type guard that returns whether the thing is a Node. */
        function isNode(x) {
            return 'type' in x;
        }
        /**
         * Converts wordforms into an indexable form. It does this by
         * normalizing into NFD, removing diacritics, and then converting
         * the result to lowercase.
         *
         * This is a very naïve implementation, that I only think will work on
         * some languages that use the Latin script. As of 2020-04-08, only
         * 4 out of 11 (36%) of published language models use the Latin script,
         * so this might not actually be a great default.
         *
         * This uses String.prototype.normalize() to convert normalize into NFD.
         * NFD is an easy way to separate a Latin character from its diacritics;
         * Even then, some Latin-based orthographies use code points that,
         * under NFD normalization, do NOT decompose into an ASCII letter and a
         * combining diacritical mark (e.g., SENĆOŦEN).
         *
         * Use this only in early iterations of the model. For a production lexical
         * model, you SHOULD write/generate your own key function, tailored to your
         * language.
         */
        function defaultSearchTermToKey(wordform) {
            /**
             * N.B.: this is (slightly) DIFFERENT than the version in
             * keymanapp/lexical-model-compiler/build-trie
             * as this is for compatibility for models built
             * BEFORE the searchTermToKey function was bundled with
             * all models.
             *
             * This compatibility version lowercases AFTER removing diacritics;
             * the new version (bundled in future models) lowercases,
             * NFD normalizes, THEN removes diacritics.
             */
            return wordform
                .normalize('NFD')
                // Remove all combining diacritics (if input is in NFD)
                // common to Latin-orthographies.
                .replace(/[\u0300-\u036f]/g, '')
                .toLowerCase();
        }
        function getDefaultWordBreaker() {
            var namespace;
            // @ts-ignore
            if (typeof wordBreakers !== 'undefined') {
                // @ts-ignore
                namespace = wordBreakers;
            }
            else {
                namespace = require('@keymanapp/models-wordBreakers').wordBreakers;
            }
            return namespace['default'];
        }
    })(models || (models = {}));
    var models;
    (function (models) {
        var QuoteBehavior;
        (function (QuoteBehavior) {
            QuoteBehavior["noQuotes"] = "no-quotes";
            QuoteBehavior["useQuotes"] = "use-quotes";
            QuoteBehavior["default"] = "default-quotes";
        })(QuoteBehavior = models.QuoteBehavior || (models.QuoteBehavior = {}));
        // For an "enum/namespace merge".  See https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces-with-classes
        (function (QuoteBehavior) {
            /**
             * Applies the specified quote behavior to the provided `Transform`, mutating it as appropriate.
             * @param transform    The Transform to be mutated
             * @param punctuation  The active `LexicalModelPunctuation` settings
             * @param defaultTo    The default quote behavior to use (in case the current value is `.default`)
             */
            function apply(behavior, text, punctuation, defaultTo) {
                if (defaultTo == QuoteBehavior.default || !defaultTo) {
                    throw "Specified quote behavior may be ambiguous - default behavior not specified (may not be .default)";
                }
                if (behavior == QuoteBehavior.default) {
                    behavior = defaultTo;
                }
                switch (behavior) {
                    case QuoteBehavior.noQuotes:
                        return text;
                    case QuoteBehavior.useQuotes:
                        var _a = punctuation.quotesForKeepSuggestion, open = _a.open, close_1 = _a.close;
                        // This part's simple enough, at least.
                        return open + text + close_1;
                    default:
                        throw "Unsupported quote behavior state detected; implementation missing!";
                }
            }
            QuoteBehavior.apply = apply;
        })(QuoteBehavior = models.QuoteBehavior || (models.QuoteBehavior = {}));
    })(models || (models = {}));
    /// <reference path="./trie-model.ts" />
    /// <reference path="./quote-behavior.ts" />
    // Add all namespaces defined here to the global scope:
    if (typeof module != 'undefined' && typeof module.exports != 'undefined') {
        module.exports['models'] = models;
    }
    var correction;
    (function (correction) {
        // A semi-optimized 'online'/iterative Damerau-Levenshtein calculator with the following features:
        // - may add new character to the 'input' string or to the 'match' string, reusing all old calculations efficiently.
        // - allows a 'focused' evaluation that seeks if the edit distance is within a specific range.  Designed for use in match-searching,
        //   where we want to find the 'closest' matching strings in a lexicon.
        // - towards such a match-searching algorithm/heuristic: should nothing be found within that range, all prior calculations may be reused
        //   to search across the lexicon with an incremented edit distance.
        // - minimized memory footprint: O(m) memory footprint (where m = length of 'input' string), rather than O(mn) (where n = length of 'match' string)
        //   - guaranteed to use a smaller footprint than DiagonalizedIterativeDamerauLevenshteinCalculation.
        //
        // In short:  Used to optimize calculations for low edit-distance checks, then expanded if/as necessary
        //            if a greater edit distance is requested.
        //
        // Reference: https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm#Possible_modifications
        //    - Motivating statement:  "if we are only interested in the distance if it is smaller than a threshold..."  
        var ClassicalDistanceCalculation = /** @class */ (function () {
            function ClassicalDistanceCalculation(other) {
                /**
                 * Specifies how far off-diagonal calculations should be performed.  A value of 0 only evaluates cells with matching
                 * row and column indicies.
                 *
                 * The resulting value from .getFinalCost() is only guaranteed correct if it is less than or equal to this value.
                 * Otherwise, this object represents a heuristic that _may_ overestimate the true edit distance.  Note that it will
                 * never underestimate.
                 */
                this.diagonalWidth = 2; // TODO: Ideally, should start at 1... but we'll start at 2 for now
                // as a naive workaround for multi-char transform limitations.
                // The sequence of characters input so far.
                this.inputSequence = [];
                this.matchSequence = [];
                if (other) {
                    // Clone class properties.
                    var rowCount = other.resolvedDistances.length;
                    this.resolvedDistances = Array(rowCount);
                    for (var r = 0; r < rowCount; r++) {
                        this.resolvedDistances[r] = Array.from(other.resolvedDistances[r]);
                    }
                    this.inputSequence = Array.from(other.inputSequence);
                    this.matchSequence = Array.from(other.matchSequence);
                    this.diagonalWidth = other.diagonalWidth;
                }
                else {
                    this.resolvedDistances = [];
                }
            }
            ClassicalDistanceCalculation.prototype.getTrueIndex = function (r, c, width) {
                var retVal = {
                    row: r,
                    col: c - r + width,
                    sparse: false
                };
                if (retVal.col < 0 || retVal.col > 2 * width) {
                    retVal.sparse = true;
                }
                return retVal;
            };
            ClassicalDistanceCalculation.prototype.getCostAt = function (i, j, width) {
                if (width === void 0) {
                    width = this.diagonalWidth;
                }
                // Check for and handle the set of fixed-value virtualized indices.
                if (i < 0 || j < 0) {
                    if (i == -1 && j >= -1) {
                        return j + 1;
                    }
                    else if (j == -1 && i >= -1) {
                        return i + 1;
                    }
                    return Number.MAX_VALUE;
                }
                var index = this.getTrueIndex(i, j, width);
                return index.sparse ? Number.MAX_VALUE : this.resolvedDistances[index.row][index.col];
            };
            /**
             * Noting the above link's statement prefixed "By examining diagonals instead of rows, and by using lazy evaluation...",
             * this function will return the actual edit distance between the strings, temporarily increasing the computed
             * diagonal's size if necessary.
             *
             * Does not actually mutate the instance.
             */
            ClassicalDistanceCalculation.prototype.getFinalCost = function () {
                var buffer = this;
                var val = buffer.getHeuristicFinalCost();
                while (val > buffer.diagonalWidth) {
                    // A consequence of treating this class as immutable.
                    buffer = buffer.increaseMaxDistance();
                    val = buffer.getHeuristicFinalCost();
                }
                return val;
            };
            /**
             * Returns this instance's computed edit distance.  If greater than the diagonal's width value, note that it may be an overestimate.
             */
            ClassicalDistanceCalculation.prototype.getHeuristicFinalCost = function () {
                return this.getCostAt(this.inputSequence.length - 1, this.matchSequence.length - 1);
            };
            /**
             * Returns `true` if the represented edit distance is less than or equal to the specified threshold, minimizing the amount of calculations
             * needed to meet the specified limit.
             *
             * Does not mutate the instance.
             * @param threshold
             */
            ClassicalDistanceCalculation.prototype.hasFinalCostWithin = function (threshold) {
                var buffer = this;
                var val = buffer.getHeuristicFinalCost();
                var guaranteedBound = this.diagonalWidth;
                do {
                    // val will never exceed the length of the longer string, no matter how large the threshold.
                    if (val <= threshold) {
                        return true;
                    }
                    else if (guaranteedBound < threshold) {
                        buffer = buffer.increaseMaxDistance();
                        guaranteedBound++;
                        val = buffer.getHeuristicFinalCost();
                    }
                    else {
                        break;
                    }
                } while (true);
                return false;
            };
            /**
             * Determines the edit path used to obtain the optimal cost, distinguishing between zero-cost
             * substitutions ('match' operations) and actual substitutions.
             * @param row
             * @param col
             */
            ClassicalDistanceCalculation.prototype.editPath = function (row, col) {
                if (row === void 0) {
                    row = this.inputSequence.length - 1;
                }
                if (col === void 0) {
                    col = this.matchSequence.length - 1;
                }
                var currentCost = this.getCostAt(row, col);
                var ops = null;
                var parent = null;
                var insertParentCost = this.getCostAt(row, col - 1);
                var deleteParentCost = this.getCostAt(row - 1, col);
                var substitutionParentCost = this.getCostAt(row - 1, col - 1);
                var _a = __read(ClassicalDistanceCalculation.getTransposeParent(this, row, col), 2), lastInputIndex = _a[0], lastMatchIndex = _a[1];
                if (lastInputIndex >= 0 && lastMatchIndex >= 0) {
                    // OK, a transposition source is quite possible.  Still need to do more vetting, to be sure.
                    var expectedCost = 1;
                    // This transposition includes either 'transpose-insert' or 'transpose-delete' operations.
                    ops = ['transpose-start']; // always needs a 'start'.
                    if (lastInputIndex != row - 1) {
                        var count = row - lastInputIndex - 1;
                        ops = ops.concat(Array(count).fill('transpose-delete'));
                        expectedCost += count;
                    }
                    else {
                        var count = col - lastMatchIndex - 1;
                        ops = ops.concat(Array(count).fill('transpose-insert'));
                        expectedCost += count;
                    }
                    ops.push('transpose-end');
                    // Double-check our expectations.
                    if (this.getCostAt(lastInputIndex - 1, lastMatchIndex - 1) != currentCost - expectedCost) {
                        ops = null;
                    }
                    parent = [lastInputIndex - 1, lastMatchIndex - 1];
                }
                if (ops) {
                    // bypass the ladder.
                }
                else if (substitutionParentCost == currentCost - 1) {
                    ops = ['substitute'];
                    parent = [row - 1, col - 1];
                }
                else if (insertParentCost == currentCost - 1) {
                    ops = ['insert'];
                    parent = [row, col - 1];
                }
                else if (deleteParentCost == currentCost - 1) {
                    ops = ['delete'];
                    parent = [row - 1, col];
                }
                else { //if(substitutionParentCost == currentCost) {
                    ops = ['match'];
                    parent = [row - 1, col - 1];
                }
                // Recursively build the edit path.
                if (parent[0] >= 0 && parent[1] >= 0) {
                    return this.editPath(parent[0], parent[1]).concat(ops);
                }
                else {
                    if (parent[0] > -1) {
                        // There are initial deletions.
                        return Array(parent[0] + 1).fill('delete').concat(ops);
                    }
                    else if (parent[1] > -1) {
                        // There are initial insertions.
                        return Array(parent[1] + 1).fill('insert').concat(ops);
                    }
                    else {
                        return ops;
                    }
                }
            };
            ClassicalDistanceCalculation.getTransposeParent = function (buffer, r, c) {
                // Block any transpositions where the tokens are identical.
                // Other operations will be cheaper.  Also, block cases where 'parents' are impossible.
                if (r < 0 || c < 0 || buffer.inputSequence[r].key == buffer.matchSequence[c].key) {
                    return [-1, -1];
                }
                // Transposition checks
                var lastInputIndex = -1;
                for (var i = r - 1; i >= 0; i--) {
                    if (buffer.inputSequence[i].key == buffer.matchSequence[c].key) {
                        lastInputIndex = i;
                        break;
                    }
                }
                var lastMatchIndex = -1;
                for (var i = c - 1; i >= 0; i--) {
                    if (buffer.matchSequence[i].key == buffer.inputSequence[r].key) {
                        lastMatchIndex = i;
                        break;
                    }
                }
                return [lastInputIndex, lastMatchIndex];
            };
            ClassicalDistanceCalculation.initialCostAt = function (buffer, r, c, insertCost, deleteCost) {
                var baseSubstitutionCost = buffer.inputSequence[r].key == buffer.matchSequence[c].key ? 0 : 1;
                var substitutionCost = buffer.getCostAt(r - 1, c - 1) + baseSubstitutionCost;
                var insertionCost = insertCost || buffer.getCostAt(r, c - 1) + 1; // If set meaningfully, will never equal zero.
                var deletionCost = deleteCost || buffer.getCostAt(r - 1, c) + 1; // If set meaningfully, will never equal zero.
                var transpositionCost = Number.MAX_VALUE;
                if (r > 0 && c > 0) { // bypass when transpositions are known to be impossible.
                    var _a = __read(ClassicalDistanceCalculation.getTransposeParent(buffer, r, c), 2), lastInputIndex = _a[0], lastMatchIndex = _a[1];
                    transpositionCost = buffer.getCostAt(lastInputIndex - 1, lastMatchIndex - 1) + (r - lastInputIndex - 1) + 1 + (c - lastMatchIndex - 1);
                }
                return Math.min(substitutionCost, deletionCost, insertionCost, transpositionCost);
            };
            ClassicalDistanceCalculation.prototype.getSubset = function (inputLength, matchLength) {
                var trimmedInstance = new ClassicalDistanceCalculation(this);
                if (inputLength > this.inputSequence.length || matchLength > this.matchSequence.length) {
                    throw "Invalid dimensions specified for trim operation";
                }
                // Trim our tracked input & match sequences.
                trimmedInstance.inputSequence.splice(inputLength);
                trimmedInstance.matchSequence.splice(matchLength);
                // Major index corresponds to input length.
                trimmedInstance.resolvedDistances.splice(inputLength);
                // The real fun:  trimming off columns. (Minor index, corresponds to match length)
                var finalTrueIndex = this.getTrueIndex(inputLength - 1, matchLength - 1, this.diagonalWidth);
                // The diagonal index increases as the row index decreases.
                for (var diagonalIndex = finalTrueIndex.col; diagonalIndex <= 2 * this.diagonalWidth; diagonalIndex++) {
                    var row = finalTrueIndex.row - (diagonalIndex - finalTrueIndex.col);
                    if (row < 0) {
                        break;
                    }
                    if (diagonalIndex < 0) {
                        trimmedInstance.resolvedDistances[row] = Array(2 * trimmedInstance.diagonalWidth + 1).fill(Number.MAX_VALUE);
                    }
                    else {
                        var newCount = 2 * this.diagonalWidth - diagonalIndex;
                        var keptEntries = trimmedInstance.resolvedDistances[row].splice(0, diagonalIndex + 1);
                        var newEntries = Array(newCount).fill(Number.MAX_VALUE);
                        trimmedInstance.resolvedDistances[row] = keptEntries.concat(newEntries);
                    }
                }
                return trimmedInstance;
            };
            ClassicalDistanceCalculation.forDiagonalOfAxis = function (diagonalWidth, centerIndex, axisCap, closure) {
                var diagonalCap = axisCap - centerIndex < diagonalWidth ? axisCap - centerIndex + diagonalWidth : 2 * diagonalWidth;
                var startOffset = centerIndex - diagonalWidth; // The axis's index for diagonal entry 0.  May be negative.
                var diagonalStart = startOffset < 0 ? 0 : startOffset;
                for (var diagonalIndex = diagonalStart - startOffset; diagonalIndex <= diagonalCap; diagonalIndex++) {
                    closure(startOffset + diagonalIndex, diagonalIndex);
                }
            };
            // Inputs add an extra row / first index entry.
            ClassicalDistanceCalculation.prototype.addInputChar = function (token) {
                var returnBuffer = new ClassicalDistanceCalculation(this);
                var r = returnBuffer.inputSequence.length;
                returnBuffer.inputSequence.push(token);
                // Insert a row, even if we don't actually do anything with it yet.
                // Initialize all entries with Number.MAX_VALUE, as `undefined` use leads to JS math issues.
                var row = Array(2 * returnBuffer.diagonalWidth + 1).fill(Number.MAX_VALUE);
                returnBuffer.resolvedDistances[r] = row;
                // If there isn't a 'match' entry yet, there are no values to compute.  Exit immediately.
                if (returnBuffer.matchSequence.length == 0) {
                    return returnBuffer;
                }
                ClassicalDistanceCalculation.forDiagonalOfAxis(returnBuffer.diagonalWidth, r, returnBuffer.matchSequence.length - 1, function (c, diagIndex) {
                    row[diagIndex] = ClassicalDistanceCalculation.initialCostAt(returnBuffer, r, c);
                });
                return returnBuffer;
            };
            ClassicalDistanceCalculation.prototype.addMatchChar = function (token) {
                var returnBuffer = new ClassicalDistanceCalculation(this);
                var c = returnBuffer.matchSequence.length;
                returnBuffer.matchSequence.push(token);
                // If there isn't a 'match' entry yet, there are no values to compute.  Exit immediately.
                if (returnBuffer.inputSequence.length == 0) {
                    return returnBuffer;
                }
                ClassicalDistanceCalculation.forDiagonalOfAxis(returnBuffer.diagonalWidth, c, returnBuffer.inputSequence.length - 1, function (r, diagIndex) {
                    var row = returnBuffer.resolvedDistances[r];
                    // Since diagIndex is from the perspective of the row, it must be inverted to properly index the column.
                    row[2 * returnBuffer.diagonalWidth - diagIndex] = ClassicalDistanceCalculation.initialCostAt(returnBuffer, r, c);
                });
                return returnBuffer;
            };
            ClassicalDistanceCalculation.prototype.increaseMaxDistance = function () {
                var returnBuffer = new ClassicalDistanceCalculation(this);
                returnBuffer.diagonalWidth++;
                if (returnBuffer.inputSequence.length < 1 || returnBuffer.matchSequence.length < 1) {
                    return returnBuffer;
                }
                // An abstraction of the common aspects of transposition handling during diagonal extensions.
                function forPossibleTranspositionsInDiagonal(startPos, fixedChar, lookupString, closure) {
                    var diagonalCap = 2 * (returnBuffer.diagonalWidth - 1); // The maximum diagonal index permitted
                    var axisCap = lookupString.length - 1; // The maximum index supported by the axis of iteration
                    // Ensures that diagonal iteration only occurs within the axis's supported range
                    diagonalCap = diagonalCap < axisCap - startPos ? diagonalCap : axisCap - startPos;
                    // Iterate within the diagonal and call our closure for any potential transpositions.
                    for (var diagonalIndex = 0; diagonalIndex <= diagonalCap; diagonalIndex++) {
                        if (fixedChar == lookupString[startPos + diagonalIndex].key) {
                            closure(startPos + diagonalIndex, diagonalIndex);
                        }
                    }
                }
                var _loop_5 = function (r) {
                    var leftCell = Number.MAX_VALUE;
                    var c = r - returnBuffer.diagonalWidth; // External index of the left-most entry, which we will now calculate.
                    if (c >= 0) {
                        // If c == 0, cell is at edge, thus a known value for insertions exists.
                        // Base cost: r+1, +1 for inserting.
                        var insertionCost_1 = c == 0 ? r + 2 : Number.MAX_VALUE;
                        // compute new left cell
                        leftCell = ClassicalDistanceCalculation.initialCostAt(returnBuffer, r, c, insertionCost_1, undefined);
                        var addedCost_1 = leftCell;
                        // daisy-chain possible updates
                        // cell (r, c+1):  new insertion source
                        if (c < returnBuffer.matchSequence.length - 1) {
                            // We propagate the new added cost (via insertion) to the old left-most cell, which is one to our right.
                            ClassicalDistanceCalculation.propagateUpdateFrom(returnBuffer, r, c + 1, addedCost_1 + 1, 0);
                            // Only possible if insertions are also possible AND more conditions are met.
                            // cells (r+2, * > c+2):  new transposition source
                            var transposeRow_1 = r + 2;
                            if (r + 2 < this_2.inputSequence.length) { // Row to check for transposes must exist.
                                var rowChar = returnBuffer.inputSequence[r + 1].key;
                                // First possible match in input could be at index c + 2, which adjusts col c+2's cost.  Except that entry in r+2
                                // doesn't exist yet - so we start with c+3 instead.
                                forPossibleTranspositionsInDiagonal(c + 3, rowChar, returnBuffer.matchSequence, function (axisIndex, diagIndex) {
                                    // Because (r+2, c+3) is root, not (r+2, c+2).  Min cost of 2.
                                    ClassicalDistanceCalculation.propagateUpdateFrom(returnBuffer, transposeRow_1, axisIndex, addedCost_1 + diagIndex + 2, diagIndex);
                                });
                            }
                        }
                    }
                    var rightCell = Number.MAX_VALUE;
                    c = r + returnBuffer.diagonalWidth;
                    if (c < returnBuffer.matchSequence.length) {
                        // If r == 0, cell is at edge, thus a known value for insertions exists.
                        // Base cost: c+1, +1 for inserting.
                        var deletionCost = r == 0 ? c + 2 : Number.MAX_VALUE;
                        // the current row wants to use adjusted diagonal width; we must specify use of the old width & its mapping instead.
                        insertionCost = returnBuffer.getCostAt(r, c - 1, this_2.diagonalWidth) + 1;
                        // compute new right cell
                        rightCell = ClassicalDistanceCalculation.initialCostAt(returnBuffer, r, c, insertionCost, deletionCost);
                        var addedCost_2 = rightCell;
                        // daisy-chain possible updates
                        // cell (r+1, c):  new deletion source
                        if (r < returnBuffer.inputSequence.length - 1) {
                            // We propagate the new added cost (via deletion) to the old right-most cell, which is one to our right.
                            ClassicalDistanceCalculation.propagateUpdateFrom(returnBuffer, r + 1, c, addedCost_2 + 1, 2 * this_2.diagonalWidth);
                            // Only possible if deletions are also possible AND more conditions are met.
                            // cells(* > r+2, c+2): new transposition source
                            var transposeCol_1 = c + 2;
                            if (c + 2 < this_2.matchSequence.length) { // Row to check for transposes must exist.
                                var colChar = returnBuffer.matchSequence[r + 1].key;
                                // First possible match in input could be at index r + 2, which adjusts row r+2's cost.  Except that entry in c+2
                                // doesn't exist yet - so we start with r+3 instead.
                                forPossibleTranspositionsInDiagonal(r + 3, colChar, returnBuffer.inputSequence, function (axisIndex, diagIndex) {
                                    var diagColIndex = 2 * (returnBuffer.diagonalWidth - 1) - diagIndex;
                                    // Because (r+3, c+2) is root, not (r+2, c+2).  Min cost of 2.
                                    ClassicalDistanceCalculation.propagateUpdateFrom(returnBuffer, axisIndex, transposeCol_1, addedCost_2 + diagIndex + 2, diagColIndex);
                                });
                            }
                        }
                    }
                    // Constructs the final expanded diagonal for the row.
                    returnBuffer.resolvedDistances[r] = [leftCell].concat(returnBuffer.resolvedDistances[r], rightCell);
                };
                var this_2 = this, insertionCost;
                for (var r = 0; r < returnBuffer.inputSequence.length; r++) {
                    _loop_5(r);
                }
                return returnBuffer;
            };
            ClassicalDistanceCalculation.propagateUpdateFrom = function (buffer, r, c, value, diagonalIndex) {
                // Note:  this function does not actually need the `c` parameter!
                //        That said, it's very useful when tracing stack traces & debugging.
                if (value < buffer.resolvedDistances[r][diagonalIndex]) {
                    buffer.resolvedDistances[r][diagonalIndex] = value;
                }
                else {
                    return;
                }
                var internalRow = r < buffer.inputSequence.length - 1;
                var internalCol = c < buffer.matchSequence.length - 1;
                // We have to compensate for the current & following rows not having been expanded yet.
                if (diagonalIndex < 2 * (buffer.diagonalWidth - 1) && internalCol) {
                    // We've inserted to the left of an existing calculation - check for propagation via insertion.
                    var updateCost = value + 1;
                    this.propagateUpdateFrom(buffer, r, c + 1, updateCost, diagonalIndex + 1);
                }
                if (diagonalIndex > 0 && internalRow) {
                    // We've inserted above an existing calculation - check for propagation via deletion
                    var updateCost = value + 1;
                    this.propagateUpdateFrom(buffer, r + 1, c, updateCost, diagonalIndex - 1);
                }
                // If both, check for propagation via substitution and possible transpositions
                if (internalRow && internalCol) {
                    var updateCost = value + (buffer.inputSequence[r + 1].key == buffer.matchSequence[c + 1].key ? 0 : 1);
                    this.propagateUpdateFrom(buffer, r + 1, c + 1, updateCost, diagonalIndex);
                    // Propagating transpositions (only possible if 'internal'.)
                    var nextInputIndex = -1;
                    for (var i = r + 2; i < buffer.inputSequence.length; i++) {
                        if (buffer.inputSequence[i].key == buffer.matchSequence[c + 1].key) {
                            nextInputIndex = i;
                            break;
                        }
                    }
                    var nextMatchIndex = -1;
                    for (var i = c + 2; i < buffer.matchSequence.length; i++) {
                        if (buffer.matchSequence[i].key == buffer.inputSequence[r + 1].key) {
                            nextMatchIndex = i;
                            break;
                        }
                    }
                    if (nextInputIndex > 0 && nextMatchIndex > 0) {
                        var transpositionCost = value + (nextInputIndex - r - 2) + 1 + (nextMatchIndex - c - 2);
                        this.propagateUpdateFrom(buffer, nextInputIndex, nextMatchIndex, transpositionCost, (buffer.diagonalWidth - 1) + nextMatchIndex - nextInputIndex);
                    }
                }
            };
            Object.defineProperty(ClassicalDistanceCalculation.prototype, "mapKey", {
                get: function () {
                    var inputString = this.inputSequence.map(function (value) { return value.key; }).join('');
                    var matchString = this.matchSequence.map(function (value) { return value.key; }).join('');
                    return inputString + models.SENTINEL_CODE_UNIT + matchString + models.SENTINEL_CODE_UNIT + this.diagonalWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ClassicalDistanceCalculation.prototype, "lastInputEntry", {
                get: function () {
                    return this.inputSequence[this.inputSequence.length - 1];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ClassicalDistanceCalculation.prototype, "lastMatchEntry", {
                get: function () {
                    return this.matchSequence[this.matchSequence.length - 1];
                },
                enumerable: true,
                configurable: true
            });
            ClassicalDistanceCalculation.computeDistance = function (input, match, bandSize) {
                if (bandSize === void 0) {
                    bandSize = 1;
                }
                // Initialize the calculation buffer, setting the diagonal width (as appropriate) in advance.
                var buffer = new ClassicalDistanceCalculation();
                bandSize = bandSize || 1;
                buffer.diagonalWidth = bandSize;
                for (var i = 0; i < input.length; i++) {
                    buffer = buffer.addInputChar(input[i]);
                }
                for (var j = 0; j < match.length; j++) {
                    buffer = buffer.addMatchChar(match[j]);
                }
                return buffer;
            };
            return ClassicalDistanceCalculation;
        }());
        correction.ClassicalDistanceCalculation = ClassicalDistanceCalculation;
    })(correction || (correction = {}));
    /// <reference path="classical-calculation.ts" />
    var correction;
    (function (correction) {
        correction.QUEUE_NODE_COMPARATOR = function (arg1, arg2) {
            return arg1.currentCost - arg2.currentCost;
        };
        // Represents a processed node for the correction-search's search-space's tree-like graph.  May represent
        // internal and 'leaf' nodes on said graph, as well as the overall root of the search.  Also used to represent
        // edges on the graph TO said nodes - there's a bit of overloading here.  Either way, it stores the cost of the 
        // optimum path used to reach the ndoe.
        //
        // The stored path cost may be an overestimate when the edit distance is greater than the current search threshold.  The
        // first version of the node to be dequeued from SearchSpace's priority queue hierarchy 'wins' and is taken as the absolute
        // minimum; subsequent versions are ignored as suboptimal.
        //
        // Provides functions usable to enumerate across the node's outward edges to new nodes for continued search.
        // Most of the actual calculations occur as part of this process.
        //
        // For nodes with raw edit-distance cost within the current threshold for correction searches, we do have admissibility.
        // If not enough nodes are available within that threshold, however, admissibility may be lost, leaving our search as a
        // heuristic.
        //
        var SearchNode = /** @class */ (function () {
            function SearchNode(rootTraversal, toKey) {
                this.toKey = function (str) { return str; };
                toKey = toKey || (function (x) { return x; });
                if (rootTraversal instanceof SearchNode) {
                    var priorNode = rootTraversal;
                    this.calculation = priorNode.calculation;
                    this.currentTraversal = priorNode.currentTraversal;
                    this.priorInput = priorNode.priorInput;
                    this.toKey = priorNode.toKey;
                }
                else {
                    this.calculation = new correction.ClassicalDistanceCalculation();
                    this.currentTraversal = rootTraversal;
                    this.priorInput = [];
                    this.toKey = toKey;
                }
            }
            Object.defineProperty(SearchNode.prototype, "knownCost", {
                get: function () {
                    return this.calculation.getHeuristicFinalCost();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SearchNode.prototype, "inputSamplingCost", {
                get: function () {
                    if (this._inputCost !== undefined) {
                        return this._inputCost;
                    }
                    else {
                        var MIN_P_1 = SearchSpace.MIN_KEYSTROKE_PROBABILITY;
                        // Should technically re-normalize the sampling distribution.
                        // -ln(p) is smaller for larger probabilities, as ln(p) is always <= 0.  Approaches infinity as p => 0.
                        // TODO:  probably more efficient to instead use actual 'probability space'... but that'll involve extra changes.
                        this._inputCost = this.priorInput.map(function (mass) { return mass.p > MIN_P_1 ? mass.p : MIN_P_1; }).reduce(function (previous, current) { return previous - Math.log(current); }, 0);
                        return this._inputCost;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SearchNode.prototype, "currentCost", {
                // The part used to prioritize our search.
                get: function () {
                    // - We reintrepret 'known cost' as a psuedo-probability.
                    //   - Noting that 1/e = 0.367879441, an edit-distance cost of 1 may be intepreted as -ln(1/e) - a log-space 'likelihood'.
                    //     - Not exactly normalized, though.
                    // That's a really, really high likelihood, thoough.
                    //
                    // At any rate, we can linearly scale the known-cost to have about whatever probability we want.
                    // If we can state it as p = 1 / (c * e), note then that ln(c * e) = ln(c) + 1.  So, scale * (ln(c) + 1).
                    // If we can state it as e^x, note that ln(e^x) = x * ln(e) = x - just scale by 'x'!
                    // p = 1 / (e^4) = 0.01831563888.  This still exceeds many neighboring keys!
                    // p = 1 / (e^5) = 0.00673794699.  Strikes a good balance.
                    // Should easily give priority to neighboring keys before edit-distance kicks in (when keys are a bit ambiguous)
                    return SearchSpace.EDIT_DISTANCE_COST_SCALE * this.knownCost + this.inputSamplingCost;
                },
                enumerable: true,
                configurable: true
            });
            SearchNode.prototype.buildInsertionEdges = function () {
                var e_7, _a;
                var edges = [];
                try {
                    for (var _b = __values(this.currentTraversal.children()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var lexicalChild = _c.value;
                        var traversal = lexicalChild.traversal();
                        var matchToken = {
                            key: lexicalChild.char,
                            traversal: traversal
                        };
                        var childCalc = this.calculation.addMatchChar(matchToken);
                        var searchChild = new SearchNode(this);
                        searchChild.calculation = childCalc;
                        searchChild.priorInput = this.priorInput;
                        searchChild.currentTraversal = traversal;
                        edges.push(searchChild);
                    }
                }
                catch (e_7_1) {
                    e_7 = { error: e_7_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_7)
                            throw e_7.error;
                    }
                }
                return edges;
            };
            SearchNode.prototype.buildDeletionEdges = function (inputDistribution) {
                var e_8, _a;
                var edges = [];
                try {
                    /*
                     * If the probability of an input is less than the highest probability * the base edit-distance likelihood,
                     * don't build an edge for it; just rely on edits from the highest-probability edge.
                     *
                     * We may be able to be stricter, but this should be a decent start.
                     *
                     * Note:  thanks to ModelCompositor.predict, we know the distribution is pre-sorted.
                     */
                    for (var inputDistribution_1 = __values(inputDistribution), inputDistribution_1_1 = inputDistribution_1.next(); !inputDistribution_1_1.done; inputDistribution_1_1 = inputDistribution_1.next()) {
                        var probMass = inputDistribution_1_1.value;
                        if (probMass.p < inputDistribution[0].p * Math.exp(-SearchSpace.EDIT_DISTANCE_COST_SCALE)) {
                            // Again, we're pre-sorted.  All further entries will be too low-cost to consider.
                            break;
                        }
                        var edgeCalc = this.calculation;
                        var transform = probMass.sample;
                        if (transform.deleteLeft) {
                            edgeCalc = edgeCalc.getSubset(edgeCalc.inputSequence.length - transform.deleteLeft, edgeCalc.matchSequence.length);
                        }
                        // TODO:  transform.deleteRight currently not supported.
                        var inputPath = Array.from(this.priorInput);
                        inputPath.push(probMass);
                        // Tokenize and iterate over input chars, adding them into the calc.
                        for (var i = 0; i < transform.insert.length; i++) {
                            var char = transform.insert[i];
                            if (models.isHighSurrogate(char)) {
                                i++;
                                char = char + transform.insert[i];
                            }
                            // In case of NFD input, filter out any empty-strings that may arise
                            // when 'keying' raw diacritics.
                            var keyedChar = this.toKey(char);
                            if (keyedChar) {
                                edgeCalc = edgeCalc.addInputChar({ key: keyedChar });
                            }
                        }
                        var childEdge = new SearchNode(this);
                        childEdge.calculation = edgeCalc;
                        childEdge.priorInput = inputPath;
                        edges.push(childEdge);
                    }
                }
                catch (e_8_1) {
                    e_8 = { error: e_8_1 };
                }
                finally {
                    try {
                        if (inputDistribution_1_1 && !inputDistribution_1_1.done && (_a = inputDistribution_1.return))
                            _a.call(inputDistribution_1);
                    }
                    finally {
                        if (e_8)
                            throw e_8.error;
                    }
                }
                return edges;
            };
            // While this may SEEM to be unnecessary, note that sometimes substitutions (which are computed
            // via insert + delete) may be lower cost than both just-insert and just-delete.
            SearchNode.prototype.buildSubstitutionEdges = function (inputDistribution) {
                var e_9, _a, e_10, _b;
                // Handles the 'input' component.
                var intermediateEdges = this.buildDeletionEdges(inputDistribution);
                var edges = [];
                try {
                    for (var _c = __values(this.currentTraversal.children()), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var lexicalChild = _d.value;
                        try {
                            for (var intermediateEdges_1 = (e_10 = void 0, __values(intermediateEdges)), intermediateEdges_1_1 = intermediateEdges_1.next(); !intermediateEdges_1_1.done; intermediateEdges_1_1 = intermediateEdges_1.next()) {
                                var edge = intermediateEdges_1_1.value;
                                var traversal = lexicalChild.traversal();
                                var matchToken = {
                                    key: lexicalChild.char,
                                    traversal: traversal
                                };
                                var childCalc = edge.calculation.addMatchChar(matchToken);
                                var searchChild = new SearchNode(this);
                                searchChild.calculation = childCalc;
                                searchChild.priorInput = edge.priorInput;
                                searchChild.currentTraversal = traversal;
                                edges.push(searchChild);
                            }
                        }
                        catch (e_10_1) {
                            e_10 = { error: e_10_1 };
                        }
                        finally {
                            try {
                                if (intermediateEdges_1_1 && !intermediateEdges_1_1.done && (_b = intermediateEdges_1.return))
                                    _b.call(intermediateEdges_1);
                            }
                            finally {
                                if (e_10)
                                    throw e_10.error;
                            }
                        }
                    }
                }
                catch (e_9_1) {
                    e_9 = { error: e_9_1 };
                }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                    }
                    finally {
                        if (e_9)
                            throw e_9.error;
                    }
                }
                return edges;
            };
            Object.defineProperty(SearchNode.prototype, "mapKey", {
                get: function () {
                    var inputString = this.priorInput.map(function (value) { return '+' + value.sample.insert + '-' + value.sample.deleteLeft; }).join('');
                    var matchString = this.calculation.matchSequence.map(function (value) { return value.key; }).join('');
                    // TODO:  might should also track diagonalWidth.
                    return inputString + models.SENTINEL_CODE_UNIT + matchString;
                },
                enumerable: true,
                configurable: true
            });
            return SearchNode;
        }());
        correction.SearchNode = SearchNode;
        var SearchSpaceTier = /** @class */ (function () {
            function SearchSpaceTier(index, initialEdges) {
                this.processed = [];
                this.index = index;
                this.correctionQueue = new models.PriorityQueue(correction.QUEUE_NODE_COMPARATOR, initialEdges);
            }
            SearchSpaceTier.prototype.increaseMaxEditDistance = function () {
                // By extracting the entries from the priority queue and increasing distance outside of it as a batch job,
                // we get an O(N) implementation, rather than the O(N log N) that would result from maintaining the original queue.
                var entries = this.correctionQueue.toArray();
                entries.forEach(function (edge) { edge.calculation = edge.calculation.increaseMaxDistance(); });
                // Since we just modified the stored instances, and the costs may have shifted, we need to re-heapify.
                this.correctionQueue = new models.PriorityQueue(correction.QUEUE_NODE_COMPARATOR, entries);
            };
            return SearchSpaceTier;
        }());
        var SearchResult = /** @class */ (function () {
            function SearchResult(node) {
                this.resultNode = node;
            }
            Object.defineProperty(SearchResult.prototype, "inputSequence", {
                get: function () {
                    return this.resultNode.priorInput;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SearchResult.prototype, "matchSequence", {
                get: function () {
                    return this.resultNode.calculation.matchSequence;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(SearchResult.prototype, "matchString", {
                get: function () {
                    return this.matchSequence.map(function (value) { return value.key; }).join('');
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SearchResult.prototype, "knownCost", {
                get: function () {
                    return this.resultNode.knownCost;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SearchResult.prototype, "inputSamplingCost", {
                get: function () {
                    return this.resultNode.inputSamplingCost;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SearchResult.prototype, "totalCost", {
                get: function () {
                    return this.resultNode.currentCost;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SearchResult.prototype, "finalTraversal", {
                get: function () {
                    return this.resultNode.currentTraversal;
                },
                enumerable: true,
                configurable: true
            });
            return SearchResult;
        }());
        correction.SearchResult = SearchResult;
        // The set of search spaces corresponding to the same 'context' for search.
        // Whenever a wordbreak boundary is crossed, a new instance should be made.
        var SearchSpace = /** @class */ (function () {
            function SearchSpace(model) {
                this.tierOrdering = [];
                this.inputSequence = [];
                this.minInputCost = [];
                // Marks all results that have already been returned since the last input was received.
                this.returnedValues = {};
                // Signals that the edge has already been processed.
                this.processedEdgeSet = {};
                if (!model) {
                    throw "The LexicalModel parameter must not be null / undefined.";
                }
                else if (!model.traverseFromRoot) {
                    throw "The provided model does not implement the `traverseFromRoot` function, which is needed to support robust correction searching.";
                }
                // Constructs the comparator needed for the following line.
                this.buildQueueSpaceComparator();
                this.selectionQueue = new models.PriorityQueue(this.QUEUE_SPACE_COMPARATOR);
                this.rootNode = new SearchNode(model.traverseFromRoot(), model.toKey ? model.toKey.bind(model) : null);
                this.completedPaths = [this.rootNode];
                // Adds a base level queue to handle initial insertions.
                // Start with _just_ the root node.  Necessary for proper empty-token, empty-input handling!
                var baseTier = new SearchSpaceTier(0, [this.rootNode]);
                this.tierOrdering.push(baseTier);
                this.selectionQueue.enqueue(baseTier);
            }
            SearchSpace.prototype.buildQueueSpaceComparator = function () {
                var searchSpace = this;
                this.QUEUE_SPACE_COMPARATOR = function (space1, space2) {
                    var node1 = space1.correctionQueue.peek();
                    var node2 = space2.correctionQueue.peek();
                    var index1 = space1.index;
                    var index2 = space2.index;
                    var tierMinCost = 0;
                    var sign = 1;
                    if (index2 < index1) {
                        var temp = index2;
                        index2 = index1;
                        index1 = temp;
                        sign = -1;
                    }
                    // Boost the cost of the lower tier by the minimum cost possible for the missing inputs between them.
                    // In essence, compare the nodes as if the lower tier had the most likely input appended for each such 
                    // input missing at the lower tier.
                    //
                    // A 100% admissible heuristic to favor a deeper search, since the added cost is guaranteed if the path
                    // is traversed further.
                    //
                    // Remember, tier index i's last used input was from input index i-1.  
                    // As a result, i is the first needed input index, with index2 - 1 the last entry needed to match them.
                    for (var i = index1; i < index2; i++) {
                        tierMinCost = tierMinCost + searchSpace.minInputCost[i];
                    }
                    // Guards, just in case one of the search spaces ever has an empty node.
                    if (node1 && node2) {
                        // If node1 is lower-tier, node1 is the one in need of boosted cost.
                        // `sign` flips it when node2 is lower tier.
                        return node1.currentCost - node2.currentCost + sign * tierMinCost;
                    }
                    else if (node2) {
                        return 1;
                    }
                    else {
                        return -1;
                    }
                };
            };
            SearchSpace.prototype.increaseMaxEditDistance = function () {
                this.tierOrdering.forEach(function (tier) { tier.increaseMaxEditDistance(); });
            };
            SearchSpace.prototype.addInput = function (inputDistribution) {
                this.inputSequence.push(inputDistribution);
                // Assumes that `inputDistribution` is already sorted.
                this.minInputCost.push(-Math.log(inputDistribution[0].p));
                // With a newly-available input, we can extend new input-dependent paths from 
                // our previously-reached 'extractedResults' nodes.
                var newlyAvailableEdges = [];
                var batches = this.completedPaths.map(function (node) {
                    var deletions = node.buildDeletionEdges(inputDistribution);
                    var substitutions = node.buildSubstitutionEdges(inputDistribution);
                    return deletions.concat(substitutions);
                });
                // Don't forget to reset the array; the contained nodes no longer reach the search's end.
                this.completedPaths = [];
                this.returnedValues = {};
                batches.forEach(function (batch) {
                    newlyAvailableEdges = newlyAvailableEdges.concat(batch);
                });
                // Now that we've built the new edges, we can efficiently construct the new search tier.
                var tier = new SearchSpaceTier(this.tierOrdering.length, newlyAvailableEdges);
                this.tierOrdering.push(tier);
                this.selectionQueue.enqueue(tier);
            };
            // TODO: will want eventually for reversions and/or backspaces
            SearchSpace.prototype.removeLastInput = function () {
                // 1.  truncate all entries from that search tier; we need to 'restore' extractedResults to match
                //     the state that would have existed without the last search tier.
                // 2.  remove the last search tier.  Which may necessitate reconstructing the tier queue, but oh well.
            };
            SearchSpace.prototype.hasNextMatchEntry = function () {
                var topQueue = this.selectionQueue.peek();
                if (topQueue) {
                    return topQueue.correctionQueue.count > 0;
                }
                else {
                    return false;
                }
            };
            SearchSpace.prototype.handleNextNode = function () {
                if (!this.hasNextMatchEntry()) {
                    return { type: 'none' };
                }
                var bestTier = this.selectionQueue.dequeue();
                var currentNode = bestTier.correctionQueue.dequeue();
                var unmatchedResult = {
                    type: 'intermediate',
                    cost: currentNode.currentCost
                };
                // Have we already processed a matching edge?  If so, skip it.
                // We already know the previous edge is of lower cost.
                if (this.processedEdgeSet[currentNode.mapKey]) {
                    this.selectionQueue.enqueue(bestTier);
                    return unmatchedResult;
                }
                else {
                    this.processedEdgeSet[currentNode.mapKey] = true;
                }
                // Stage 1:  filter out nodes/edges we want to prune
                // Forbid a raw edit-distance of greater than 2.
                // Note:  .knownCost is not scaled, while its contribution to .currentCost _is_ scaled.
                var substitutionsOnly = false;
                if (currentNode.knownCost > 2) {
                    return unmatchedResult;
                }
                else if (currentNode.knownCost == 2) {
                    // Hard restriction:  no further edits will be supported.  This helps keep the search
                    // more narrowly focused.
                    substitutionsOnly = true;
                }
                var tierMinCost = 0;
                for (var i = 0; i <= bestTier.index; i++) {
                    tierMinCost += this.minInputCost[i];
                }
                // Thresholds _any_ path, partially based on currently-traversed distance.
                // Allows a little 'wiggle room' + 2 "hard" edits.
                // Can be important if needed characters don't actually exist on the keyboard 
                // ... or even just not the then-current layer of the keyboard.
                if (currentNode.currentCost > tierMinCost + 2.5 * SearchSpace.EDIT_DISTANCE_COST_SCALE) {
                    return unmatchedResult;
                }
                // Stage 2:  build remaining edges
                // Always possible, as this does not require any new input.
                if (!substitutionsOnly) {
                    var insertionEdges = currentNode.buildInsertionEdges();
                    bestTier.correctionQueue.enqueueAll(insertionEdges);
                }
                if (bestTier.index == this.tierOrdering.length - 1) {
                    // It was the final tier - store the node for future reference.
                    this.completedPaths.push(currentNode);
                    // Since we don't modify any other tier, we may simply reinsert the removed tier.
                    this.selectionQueue.enqueue(bestTier);
                    return {
                        type: 'complete',
                        cost: currentNode.currentCost,
                        finalNode: currentNode
                    };
                }
                else {
                    // Time to construct new edges for the next tier!
                    var nextTier = this.tierOrdering[bestTier.index + 1];
                    var inputIndex = nextTier.index;
                    var deletionEdges = [];
                    if (!substitutionsOnly) {
                        deletionEdges = currentNode.buildDeletionEdges(this.inputSequence[inputIndex - 1]);
                    }
                    var substitutionEdges = currentNode.buildSubstitutionEdges(this.inputSequence[inputIndex - 1]);
                    // Note:  we're live-modifying the tier's cost here!  The priority queue loses its guarantees as a result.
                    nextTier.correctionQueue.enqueueAll(deletionEdges.concat(substitutionEdges));
                    // So, we simply rebuild the selection queue.
                    this.selectionQueue = new models.PriorityQueue(this.QUEUE_SPACE_COMPARATOR, this.tierOrdering);
                    // We didn't reach an end-node, so we just end the iteration and continue the search.
                }
                // If we've somehow fully exhausted all search options, indicate that none remain.
                return unmatchedResult;
            };
            // Current best guesstimate of how compositor will retrieve ideal corrections.
            SearchSpace.prototype.getBestMatches = function (waitMillis) {
                var searchSpace, currentReturns, timeStart, maxTime, BatchingAssistant, batcher, returnedValues, preprocessedQueue, entry, batch_1, batch_2, timedOut, newResult, now, batch_3, batch;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            searchSpace = this;
                            currentReturns = {};
                            timeStart = Date.now();
                            if (waitMillis == 0) {
                                maxTime = Infinity;
                            }
                            else if (waitMillis == undefined || Number.isNaN(waitMillis)) { // also covers null.
                                maxTime = SearchSpace.DEFAULT_ALLOTTED_CORRECTION_TIME_INTERVAL;
                            }
                            else {
                                maxTime = waitMillis;
                            }
                            BatchingAssistant = /** @class */ (function () {
                                function BatchingAssistant() {
                                    this.currentCost = Number.MIN_SAFE_INTEGER;
                                    this.entries = [];
                                }
                                BatchingAssistant.prototype.checkAndAdd = function (entry) {
                                    var result = null;
                                    if (entry.currentCost > this.currentCost) {
                                        result = this.tryFinalize();
                                        this.currentCost = entry.currentCost;
                                    }
                                    // Filter out any duplicated match sequences.  The same match sequence may be reached via
                                    // different input sequences, after all.
                                    var outputMapKey = entry.calculation.matchSequence.map(function (value) { return value.key; }).join('');
                                    // First, ensure the edge has an existing 'shared' cache entry.
                                    if (!searchSpace.returnedValues[outputMapKey]) {
                                        searchSpace.returnedValues[outputMapKey] = entry;
                                    }
                                    // Check the generator's local returned-value cache - this determines whether or not we
                                    // need to add a new 'return' to the batch.
                                    if (!currentReturns[outputMapKey]) {
                                        this.entries.push(new SearchResult(entry));
                                        currentReturns[outputMapKey] = entry;
                                    }
                                    return result;
                                };
                                BatchingAssistant.prototype.tryFinalize = function () {
                                    var result = null;
                                    if (this.entries.length > 0) {
                                        result = this.entries;
                                        this.entries = [];
                                    }
                                    return result;
                                };
                                return BatchingAssistant;
                            }());
                            batcher = new BatchingAssistant();
                            returnedValues = Object.values(this.returnedValues);
                            if (!(returnedValues.length > 0))
                                return [3 /*break*/, 6];
                            preprocessedQueue = new models.PriorityQueue(correction.QUEUE_NODE_COMPARATOR, returnedValues);
                            _a.label = 1;
                        case 1:
                            if (!(preprocessedQueue.count > 0))
                                return [3 /*break*/, 4];
                            entry = preprocessedQueue.dequeue();
                            batch_1 = batcher.checkAndAdd(entry);
                            if (!batch_1)
                                return [3 /*break*/, 3];
                            return [4 /*yield*/, batch_1];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [3 /*break*/, 1];
                        case 4:
                            batch_2 = batcher.tryFinalize();
                            if (!batch_2)
                                return [3 /*break*/, 6];
                            return [4 /*yield*/, batch_2];
                        case 5:
                            _a.sent();
                            _a.label = 6;
                        case 6:
                            timedOut = false;
                            _a.label = 7;
                        case 7:
                            newResult = void 0;
                            // Search for a 'complete' path, skipping all partial paths as long as time remains.
                            do {
                                newResult = this.handleNextNode();
                                now = Date.now();
                                if (now - timeStart > maxTime) {
                                    timedOut = true;
                                }
                            } while (!timedOut && newResult.type == 'intermediate');
                            batch_3 = void 0;
                            if (newResult.type == 'none') {
                                return [3 /*break*/, 10];
                            }
                            else if (newResult.type == 'complete') {
                                batch_3 = batcher.checkAndAdd(newResult.finalNode);
                            }
                            if (!batch_3)
                                return [3 /*break*/, 9];
                            return [4 /*yield*/, batch_3];
                        case 8:
                            _a.sent();
                            _a.label = 9;
                        case 9:
                            if (!timedOut && this.hasNextMatchEntry())
                                return [3 /*break*/, 7];
                            _a.label = 10;
                        case 10:
                            batch = batcher.tryFinalize();
                            if (!batch)
                                return [3 /*break*/, 12];
                            return [4 /*yield*/, batch];
                        case 11:
                            _a.sent();
                            _a.label = 12;
                        case 12: return [2 /*return*/, null];
                    }
                });
            };
            // p = 1 / (e^4) = 0.01831563888.  This still exceeds many neighboring keys!
            // p = 1 / (e^5) = 0.00673794699.  Strikes a good balance.
            // Should easily give priority to neighboring keys before edit-distance kicks in (when keys are a bit ambiguous)
            SearchSpace.EDIT_DISTANCE_COST_SCALE = 5;
            SearchSpace.MIN_KEYSTROKE_PROBABILITY = 0.0001;
            SearchSpace.DEFAULT_ALLOTTED_CORRECTION_TIME_INTERVAL = 33; // in milliseconds.
            return SearchSpace;
        }());
        correction.SearchSpace = SearchSpace;
    })(correction || (correction = {}));
    /// <reference path="distance-modeler.ts" />
    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b)
                    if (b.hasOwnProperty(p))
                        d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var correction;
    (function (correction) {
        function textToCharTransforms(text, transformId) {
            var perCharTransforms = [];
            for (var i = 0; i < text.kmwLength(); i++) {
                var char = text.kmwCharAt(i); // is SMP-aware
                var transform = {
                    insert: char,
                    deleteLeft: 0,
                    id: transformId
                };
                perCharTransforms.push(transform);
            }
            return perCharTransforms;
        }
        var TrackedContextSuggestion = /** @class */ (function () {
            function TrackedContextSuggestion() {
            }
            return TrackedContextSuggestion;
        }());
        correction.TrackedContextSuggestion = TrackedContextSuggestion;
        var TrackedContextToken = /** @class */ (function () {
            function TrackedContextToken() {
                this.transformDistributions = [];
                this.activeReplacementId = -1;
            }
            Object.defineProperty(TrackedContextToken.prototype, "isNew", {
                get: function () {
                    return this.transformDistributions.length == 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TrackedContextToken.prototype, "currentText", {
                get: function () {
                    if (this.replacementText === undefined || this.replacementText === null) {
                        return this.raw;
                    }
                    else {
                        return this.replacementText;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TrackedContextToken.prototype, "replacement", {
                get: function () {
                    var replacementId = this.activeReplacementId;
                    return this.replacements.find(function (replacement) {
                        return replacement.suggestion.id == replacementId;
                    });
                },
                enumerable: true,
                configurable: true
            });
            TrackedContextToken.prototype.revert = function () {
                delete this.activeReplacementId;
            };
            return TrackedContextToken;
        }());
        correction.TrackedContextToken = TrackedContextToken;
        var TrackedContextState = /** @class */ (function () {
            function TrackedContextState(obj) {
                // Tracks all search spaces starting at the current token.
                // In the lm-layer's current form, this should only ever have one entry.
                // Leaves 'design space' for if/when we add support for phrase-level corrections/predictions.
                this.searchSpace = [];
                if (obj instanceof TrackedContextState) {
                    var source = obj;
                    // Be sure to deep-copy the tokens!  Pointer-aliasing is bad here.
                    this.tokens = source.tokens.map(function (token) {
                        var copy = new TrackedContextToken();
                        copy.raw = token.raw;
                        copy.replacements = token.replacements;
                        copy.activeReplacementId = token.activeReplacementId;
                        copy.transformDistributions = token.transformDistributions;
                        if (token.replacementText) {
                            copy.replacementText = token.replacementText;
                        }
                        return copy;
                    });
                    this.searchSpace = obj.searchSpace;
                    this.indexOffset = 0;
                    this.model = obj.model;
                }
                else {
                    var lexicalModel = obj;
                    this.tokens = [];
                    this.indexOffset = Number.MIN_SAFE_INTEGER;
                    this.model = lexicalModel;
                    if (lexicalModel && lexicalModel.traverseFromRoot) {
                        this.searchSpace = [new correction.SearchSpace(lexicalModel)];
                    }
                }
            }
            Object.defineProperty(TrackedContextState.prototype, "head", {
                get: function () {
                    return this.tokens[0];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TrackedContextState.prototype, "tail", {
                get: function () {
                    return this.tokens[this.tokens.length - 1];
                },
                enumerable: true,
                configurable: true
            });
            TrackedContextState.prototype.popHead = function () {
                this.tokens.splice(0, 2);
                this.indexOffset -= 1;
            };
            TrackedContextState.prototype.pushTail = function (token) {
                if (this.model && this.model.traverseFromRoot) {
                    this.searchSpace = [new correction.SearchSpace(this.model)]; // yeah, need to update SearchSpace for compatibility
                }
                else {
                    this.searchSpace = [];
                }
                this.tokens.push(token);
                var state = this;
                if (state.searchSpace.length > 0) {
                    token.transformDistributions.forEach(function (distrib) { return state.searchSpace[0].addInput(distrib); });
                }
            };
            TrackedContextState.prototype.pushWhitespaceToTail = function (transformDistribution) {
                if (transformDistribution === void 0) {
                    transformDistribution = null;
                }
                var whitespaceToken = new TrackedContextToken();
                // Track the Transform that resulted in the whitespace 'token'.
                // Will be needed for phrase-level correction/prediction.
                whitespaceToken.transformDistributions = [transformDistribution];
                whitespaceToken.raw = null;
                this.tokens.push(whitespaceToken);
            };
            /**
             * Used for 14.0's backspace workaround, which flattens all previous Distribution<Transform>
             * entries because of limitations with direct use of backspace transforms.
             * @param tokenText
             * @param transformId
             */
            TrackedContextState.prototype.replaceTailForBackspace = function (tokenText, transformId) {
                this.tokens.pop();
                // It's a backspace transform; time for special handling!
                //
                // For now, with 14.0, we simply compress all remaining Transforms for the token into 
                // multiple single-char transforms.  Probabalistically modeling BKSP is quite complex, 
                // so we simplify by assuming everything remaining after a BKSP is 'true' and 'intended' text.
                //
                // Note that we cannot just use a single, monolithic transform at this point b/c
                // of our current edit-distance optimization strategy; diagonalization is currently... 
                // not very compatible with that.
                var backspacedTokenContext = textToCharTransforms(tokenText, transformId).map(function (transform) {
                    return [{ sample: transform, p: 1.0 }];
                });
                var compactedToken = new TrackedContextToken();
                compactedToken.raw = tokenText;
                compactedToken.transformDistributions = backspacedTokenContext;
                this.pushTail(compactedToken);
            };
            TrackedContextState.prototype.updateTail = function (transformDistribution, tokenText) {
                var editedToken = this.tail;
                // Preserve existing text if new text isn't specified.
                tokenText = tokenText || (tokenText === '' ? '' : editedToken.raw);
                if (transformDistribution && transformDistribution.length > 0) {
                    editedToken.transformDistributions.push(transformDistribution);
                    if (this.searchSpace) {
                        this.searchSpace.forEach(function (space) { return space.addInput(transformDistribution); });
                    }
                }
                // Replace old token's raw-text with new token's raw-text.
                editedToken.raw = tokenText;
            };
            TrackedContextState.prototype.toRawTokenization = function () {
                var e_11, _a;
                var sequence = [];
                try {
                    for (var _b = __values(this.tokens), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var token = _c.value;
                        // Hide any tokens representing wordbreaks.  (Thinking ahead to phrase-level possibilities)
                        if (token.currentText !== null) {
                            sequence.push(token.currentText);
                        }
                    }
                }
                catch (e_11_1) {
                    e_11 = { error: e_11_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_11)
                            throw e_11.error;
                    }
                }
                return sequence;
            };
            return TrackedContextState;
        }());
        correction.TrackedContextState = TrackedContextState;
        var CircularArray = /** @class */ (function () {
            function CircularArray(size) {
                if (size === void 0) {
                    size = CircularArray.DEFAULT_ARRAY_SIZE;
                }
                this.currentHead = 0;
                this.currentTail = 0;
                this.circle = Array(size);
            }
            Object.defineProperty(CircularArray.prototype, "count", {
                get: function () {
                    var diff = this.currentHead - this.currentTail;
                    if (diff < 0) {
                        diff = diff + this.circle.length;
                    }
                    return diff;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CircularArray.prototype, "maxCount", {
                get: function () {
                    return this.circle.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CircularArray.prototype, "oldest", {
                get: function () {
                    if (this.count == 0) {
                        return undefined;
                    }
                    return this.item(0);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CircularArray.prototype, "newest", {
                get: function () {
                    if (this.count == 0) {
                        return undefined;
                    }
                    return this.item(this.count - 1);
                },
                enumerable: true,
                configurable: true
            });
            CircularArray.prototype.enqueue = function (item) {
                var prevItem = null;
                var nextHead = (this.currentHead + 1) % this.maxCount;
                if (nextHead == this.currentTail) {
                    prevItem = this.circle[this.currentTail];
                    this.currentTail = (this.currentTail + 1) % this.maxCount;
                }
                this.circle[this.currentHead] = item;
                this.currentHead = nextHead;
                return prevItem;
            };
            CircularArray.prototype.dequeue = function () {
                if (this.currentTail == this.currentHead) {
                    return null;
                }
                else {
                    var item = this.circle[this.currentTail];
                    this.currentTail = (this.currentTail + 1) % this.maxCount;
                    return item;
                }
            };
            CircularArray.prototype.popNewest = function () {
                if (this.currentTail == this.currentHead) {
                    return null;
                }
                else {
                    var item = this.circle[this.currentHead];
                    this.currentHead = (this.currentHead - 1 + this.maxCount) % this.maxCount;
                    return item;
                }
            };
            /**
             * Returns items contained within the circular array, ordered from 'oldest' to 'newest' -
             * the same order in which the items will be dequeued.
             * @param index
             */
            CircularArray.prototype.item = function (index) {
                if (index >= this.count) {
                    throw "Invalid array index";
                }
                var mappedIndex = (this.currentTail + index) % this.maxCount;
                return this.circle[mappedIndex];
            };
            CircularArray.DEFAULT_ARRAY_SIZE = 5;
            return CircularArray;
        }());
        var ContextTracker = /** @class */ (function (_super) {
            __extends(ContextTracker, _super);
            function ContextTracker() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ContextTracker.attemptMatchContext = function (tokenizedContext, matchState, transformDistribution) {
                // Map the previous tokenized state to an edit-distance friendly version.
                var matchContext = matchState.toRawTokenization();
                // Inverted order, since 'match' existed before our new context.
                var mapping = correction.ClassicalDistanceCalculation.computeDistance(matchContext.map(function (value) { return ({ key: value }); }), tokenizedContext.map(function (value) { return ({ key: value }); }), 1);
                var editPath = mapping.editPath();
                var poppedHead = false;
                var pushedTail = false;
                // Matters greatly when starting from a nil context.
                if (editPath.length > 1) {
                    // First entry:  may not be an 'insert' or a 'transpose' op.
                    // 'insert' allowed if the next token is 'substitute', as this may occur with an edit path of length 2.
                    if ((editPath[0] == 'insert' && !(editPath[1] == 'substitute' && editPath.length == 2)) || editPath[0].indexOf('transpose') >= 0) {
                        return null;
                    }
                    else if (editPath[0] == 'delete') {
                        poppedHead = true; // a token from the previous state has been wholly removed.
                    }
                }
                // Last entry:  may not be a 'delete' or a 'transpose' op.
                var tailIndex = editPath.length - 1;
                var ignorePenultimateMatch = false;
                if (editPath[tailIndex] == 'delete' || editPath[0].indexOf('transpose') >= 0) {
                    return null;
                }
                else if (editPath[tailIndex] == 'insert') {
                    pushedTail = true;
                }
                else if (tailIndex > 0 && editPath[tailIndex - 1] == 'insert' && editPath[tailIndex] == 'substitute') {
                    // Tends to happen when accepting suggestions.
                    pushedTail = true;
                    ignorePenultimateMatch = true;
                }
                // Now to check everything in-between:  should be exclusively 'match'es.
                for (var index = 1; index < editPath.length - (ignorePenultimateMatch ? 2 : 1); index++) {
                    if (editPath[index] != 'match') {
                        return null;
                    }
                }
                // If we've made it here... success!  We have a context match!
                var state;
                if (pushedTail) {
                    // On suggestion acceptance, we should update the previous final token.
                    // We do it first so that the acceptance is replicated in the new TrackedContextState
                    // as well.
                    if (ignorePenultimateMatch) {
                        // For this case, we were likely called by ModelCompositor.acceptSuggestion(), which
                        // would have marked the accepted suggestion.
                        matchState.tail.replacementText = tokenizedContext[tokenizedContext.length - 2];
                    }
                    state = new TrackedContextState(matchState);
                }
                else {
                    // Since we're continuing a previously-cached context, we can reuse the same SearchSpace
                    // to continue making predictions.
                    state = matchState;
                }
                var hasDistribution = transformDistribution && Array.isArray(transformDistribution);
                var primaryInput = hasDistribution ? transformDistribution[0].sample : null;
                if (primaryInput && primaryInput.insert == "" && primaryInput.deleteLeft == 0 && !primaryInput.deleteRight) {
                    primaryInput = null;
                }
                var isBackspace = primaryInput && primaryInput.insert == "" && primaryInput.deleteLeft > 0 && !primaryInput.deleteRight;
                var finalToken = tokenizedContext[tokenizedContext.length - 1];
                /* Assumption:  This is an adequate check for its two sub-branches.
                 *
                 * Basis:
                 * - Assumption: one keystroke may only cause a single token to rotate out of context.
                 *   - That is, no "reasonable" keystroke would emit enough code points to 'bump' two words simultaneously.
                 *   - ... This one may need to be loosened a bit... but it should be enough for initial correction testing as-is.
                 * - Assumption:  one keystroke may only cause a single token to be appended to the context
                 *   - That is, no "reasonable" keystroke would emit a Transform adding two separate word tokens
                 *     - For languages using whitespace to word-break, said keystroke would have to include said whitespace to break the assumption.
                 */
                // If there is/was more than one context token available...
                if (editPath.length > 1) {
                    // We're removing a context token, but at least one remains.
                    if (poppedHead) {
                        state.popHead();
                    }
                    // We're adding an additional context token.
                    if (pushedTail) {
                        // ASSUMPTION:  any transform that triggers this case is a pure-whitespace Transform, as we
                        //              need a word-break before beginning a new word's context.
                        //              Worth note:  when invalid, the lm-layer already has problems in other aspects too.
                        state.pushWhitespaceToTail(transformDistribution);
                        var emptyToken = new TrackedContextToken();
                        emptyToken.raw = '';
                        // Continuing the earlier assumption, that 'pure-whitespace Transform' does not emit any initial characters
                        // for the new word (token), so the input keystrokes do not correspond to the new text token.
                        emptyToken.transformDistributions = [];
                        state.pushTail(emptyToken);
                    }
                    else { // We're editing the final context token.
                        // TODO:  Assumption:  we didn't 'miss' any inputs somehow.
                        //        As is, may be prone to fragility should the lm-layer's tracked context 'desync' from its host's.
                        if (isBackspace) {
                            state.replaceTailForBackspace(finalToken, primaryInput.id);
                        }
                        else {
                            state.updateTail(primaryInput ? transformDistribution : null, finalToken);
                        }
                    }
                    // There is only one word in the context.
                }
                else {
                    // TODO:  Assumption:  we didn't 'miss' any inputs somehow.
                    //        As is, may be prone to fragility should the lm-layer's tracked context 'desync' from its host's.
                    if (editPath[tailIndex] == 'insert') {
                        // Construct appropriate initial token.
                        var token = new TrackedContextToken();
                        token.raw = tokenizedContext[0];
                        token.transformDistributions = [transformDistribution];
                        state.pushTail(token);
                    }
                    else { // Edit the lone context token.
                        // Consider backspace entry for this case?
                        if (isBackspace) {
                            state.replaceTailForBackspace(finalToken, primaryInput.id);
                        }
                        else {
                            state.updateTail(primaryInput ? transformDistribution : null, finalToken);
                        }
                    }
                }
                return state;
            };
            ContextTracker.modelContextState = function (tokenizedContext, lexicalModel) {
                var baseTokens = tokenizedContext.map(function (entry) {
                    var token = new TrackedContextToken();
                    token.raw = entry;
                    if (token.raw) {
                        token.transformDistributions = textToCharTransforms(token.raw).map(function (transform) {
                            return [{ sample: transform, p: 1.0 }];
                        });
                    }
                    else {
                        // Helps model context-final wordbreaks.
                        token.transformDistributions = [];
                    }
                    return token;
                });
                // And now build the final context state object, which includes whitespace 'tokens'.
                var state = new TrackedContextState(lexicalModel);
                if (baseTokens.length > 0) {
                    state.pushTail(baseTokens.splice(0, 1)[0]);
                }
                while (baseTokens.length > 0) {
                    state.pushWhitespaceToTail();
                    state.pushTail(baseTokens.splice(0, 1)[0]);
                }
                if (state.tokens.length == 0) {
                    var token = new TrackedContextToken();
                    token.raw = '';
                    state.pushTail(token);
                }
                return state;
            };
            /**
             * Compares the current, post-input context against the most recently-seen contexts from previous prediction calls, returning
             * the most information-rich `TrackedContextState` possible.  If a match is found, the state will be annotated with the
             * input information provided to previous prediction calls and persisted correction-search calculations for re-use.
             *
             * @param model
             * @param context
             * @param mainTransform
             * @param transformDistribution
             */
            ContextTracker.prototype.analyzeState = function (model, context, transformDistribution) {
                if (!model.traverseFromRoot) {
                    // Assumption:  LexicalModel provides a valid traverseFromRoot function.  (Is technically optional)
                    // Without it, no 'corrections' may be made; the model can only be used to predict, not correct.
                    throw "This lexical model does not provide adequate data for correction algorithms and context reuse";
                }
                var tokenizedContext = models.tokenize(model.wordbreaker || wordBreakers.default, context);
                if (tokenizedContext.left.length > 0) {
                    for (var i = this.count - 1; i >= 0; i--) {
                        var resultState = ContextTracker.attemptMatchContext(tokenizedContext.left, this.item(i), transformDistribution);
                        if (resultState) {
                            resultState.taggedContext = context;
                            if (resultState != this.item(i)) {
                                this.enqueue(resultState);
                            }
                            return resultState;
                        }
                    }
                }
                // Else:  either empty OR we've detected a 'new context'.  Initialize from scratch; no prior input information is
                // available.  Only the results of the prior inputs are known.
                //
                // Assumption:  as a caret needs to move to context before any actual transform distributions occur,
                // this state is only reached on caret moves; thus, transformDistribution is actually just a single null transform.
                var state = ContextTracker.modelContextState(tokenizedContext.left, model);
                state.taggedContext = context;
                this.enqueue(state);
                return state;
            };
            return ContextTracker;
        }(CircularArray));
        correction.ContextTracker = ContextTracker;
    })(correction || (correction = {}));
    /// <reference path="../node_modules/@keymanapp/models-templates/src/index.ts" />
    /// <reference path="correction/context-tracker.ts" />
    var __assign = (this && this.__assign) || function () {
        __assign = Object.assign || function (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var ModelCompositor = /** @class */ (function () {
        function ModelCompositor(lexicalModel) {
            this.SUGGESTION_ID_SEED = 0;
            this.lexicalModel = lexicalModel;
            if (lexicalModel.traverseFromRoot) {
                this.contextTracker = new correction.ContextTracker();
            }
            this.punctuation = ModelCompositor.determinePunctuationFromModel(lexicalModel);
        }
        ModelCompositor.prototype.isWhitespace = function (transform) {
            // Matches prefixed text + any instance of a character with Unicode general property Z* or the following: CR, LF, and Tab.
            var whitespaceRemover = /.*[\u0009\u000A\u000D\u0020\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000]/i;
            // Filter out null-inserts; their high probability can cause issues.
            if (transform.insert == '') { // Can actually register as 'whitespace'.
                return false;
            }
            var insert = transform.insert;
            insert = insert.replace(whitespaceRemover, '');
            return insert == '';
        };
        ModelCompositor.prototype.isBackspace = function (transform) {
            return transform.insert == "" && transform.deleteLeft > 0;
        };
        ModelCompositor.prototype.isEmpty = function (transform) {
            return transform.insert == '' && transform.deleteLeft == 0;
        };
        ModelCompositor.prototype.predictFromCorrections = function (corrections, context) {
            var e_12, _a;
            var returnedPredictions = [];
            var _loop_6 = function (correction_1) {
                var predictions = this_3.lexicalModel.predict(correction_1.sample, context);
                var predictionSet = predictions.map(function (pair) {
                    var transform = correction_1.sample;
                    var inputProb = correction_1.p;
                    // Let's not rely on the model to copy transform IDs.
                    // Only bother is there IS an ID to copy.
                    if (transform.id !== undefined) {
                        pair.sample.transformId = transform.id;
                    }
                    var prediction = { sample: pair.sample, p: pair.p * inputProb };
                    return prediction;
                }, this_3);
                returnedPredictions = returnedPredictions.concat(predictionSet);
            };
            var this_3 = this;
            try {
                for (var corrections_1 = __values(corrections), corrections_1_1 = corrections_1.next(); !corrections_1_1.done; corrections_1_1 = corrections_1.next()) {
                    var correction_1 = corrections_1_1.value;
                    _loop_6(correction_1);
                }
            }
            catch (e_12_1) {
                e_12 = { error: e_12_1 };
            }
            finally {
                try {
                    if (corrections_1_1 && !corrections_1_1.done && (_a = corrections_1.return))
                        _a.call(corrections_1);
                }
                finally {
                    if (e_12)
                        throw e_12.error;
                }
            }
            return returnedPredictions;
        };
        ModelCompositor.prototype.predict = function (transformDistribution, context) {
            var e_13, _a, e_14, _b;
            var suggestionDistribution = [];
            var lexicalModel = this.lexicalModel;
            var punctuation = this.punctuation;
            if (!(transformDistribution instanceof Array)) {
                transformDistribution = [{ sample: transformDistribution, p: 1.0 }];
            }
            else if (transformDistribution.length == 0) {
                /*
                   Robust stop-gap: if our other filters somehow fail, this fixes the
                   zero-length array by making it match the form of the array that
                   would result if it were instead called with the other legal
                   parameter type - a single Transform.
          
                   Unfortunately, the method will lack all data about even
                   the original keystroke that resulted in the call... but this way,
                   we can at least get some predictions rather than shortcutting
                   and producing none whatsoever.
                */
                transformDistribution.push({
                    sample: {
                        insert: '',
                        deleteLeft: 0
                    },
                    p: 1.0
                });
            }
            var inputTransform = transformDistribution.sort(function (a, b) {
                return b.p - a.p;
            })[0].sample;
            // Only allow new-word suggestions if space was the most likely keypress.
            var allowSpace = this.isWhitespace(inputTransform);
            var allowBksp = this.isBackspace(inputTransform);
            var postContext = models.applyTransform(inputTransform, context);
            var keepOptionText = this.wordbreak(postContext);
            var keepOption = null;
            var rawPredictions = [];
            // Used to restore whitespaces if operations would remove them.
            var prefixTransform;
            var contextState = null;
            // Section 1:  determining 'prediction roots'.
            if (!this.contextTracker) {
                var predictionRoots = void 0;
                // Generates raw prediction distributions for each valid input.  Can only 'correct'
                // against the final input.
                //
                // This is the old, 12.0-13.0 'correction' style.
                if (allowSpace) {
                    // Detect start of new word; prevent whitespace loss here.
                    predictionRoots = [{ sample: inputTransform, p: 1.0 }];
                    prefixTransform = inputTransform;
                }
                else {
                    predictionRoots = transformDistribution.map(function (alt) {
                        var transform = alt.sample;
                        // Filter out special keys unless they're expected.
                        if (this.isWhitespace(transform) && !allowSpace) {
                            return null;
                        }
                        else if (this.isBackspace(transform) && !allowBksp) {
                            return null;
                        }
                        return alt;
                    }, this);
                }
                // Remove `null` entries.
                predictionRoots = predictionRoots.filter(function (tuple) { return !!tuple; });
                // Running in bulk over all suggestions, duplicate entries may be possible.
                rawPredictions = this.predictFromCorrections(predictionRoots, context);
            }
            else {
                contextState = this.contextTracker.analyzeState(this.lexicalModel, postContext, !this.isEmpty(inputTransform) ?
                    transformDistribution :
                    null);
                // TODO:  Should we filter backspaces & whitespaces out of the transform distribution?
                //        Ideally, the answer (in the future) will be no, but leaving it in right now may pose an issue.
                // Rather than go "full hog" and make a priority queue out of the eventual, future competing search spaces...
                // let's just note that right now, there will only ever be one.
                //
                // The 'eventual' logic will be significantly more complex, though still manageable.
                var searchSpace = contextState.searchSpace[0];
                var newEmptyToken_1 = false;
                // Detect if we're starting a new context state.
                var contextTokens = contextState.tokens;
                if (contextTokens.length == 0 || contextTokens[contextTokens.length - 1].isNew) {
                    if (this.isEmpty(inputTransform) || this.isWhitespace(inputTransform)) {
                        newEmptyToken_1 = true;
                        prefixTransform = inputTransform;
                        context = postContext; // Ensure the whitespace token is preapplied!
                    }
                }
                // TODO:  whitespace, backspace filtering.  Do it here.
                //        Whitespace is probably fine, actually.  Less sure about backspace.
                var bestCorrectionCost = void 0;
                try {
                    for (var _c = __values(searchSpace.getBestMatches()), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var matches = _d.value;
                        // Corrections obtained:  now to predict from them!
                        var predictionRoots = matches.map(function (match) {
                            var correction = match.matchString;
                            // Worth considering:  extend Traversal to allow direct prediction lookups?
                            // let traversal = match.finalTraversal;
                            // Find a proper Transform ID to map the correction to.
                            // Without it, we can't apply the suggestion.
                            var finalInput;
                            if (match.inputSequence.length > 0) {
                                finalInput = match.inputSequence[match.inputSequence.length - 1].sample;
                            }
                            else {
                                finalInput = inputTransform; // A fallback measure.  Greatly matters for empty contexts.
                            }
                            var deleteLeft = 0;
                            // remove actual token string.  If new token, there should be nothing to delete.
                            if (!newEmptyToken_1) {
                                // If this is triggered from a backspace, make sure to use its results
                                // and also include its left-deletions!  It's the one post-input context case.
                                if (allowBksp) {
                                    deleteLeft = this.wordbreak(postContext).kmwLength() + inputTransform.deleteLeft;
                                }
                                else {
                                    // Normal case - use the pre-input context.
                                    deleteLeft = this.wordbreak(context).kmwLength();
                                }
                            }
                            // Replace the existing context with the correction.
                            var correctionTransform = {
                                insert: correction,
                                deleteLeft: deleteLeft,
                                id: inputTransform.id // The correction should always be based on the most recent external transform/transcription ID.
                            };
                            return {
                                sample: correctionTransform,
                                p: Math.exp(-match.totalCost)
                            };
                        }, this);
                        // Running in bulk over all suggestions, duplicate entries may be possible.
                        var predictions = this.predictFromCorrections(predictionRoots, context);
                        // Only set 'best correction' cost when a correction ACTUALLY YIELDS predictions.
                        if (predictions.length > 0 && bestCorrectionCost === undefined) {
                            bestCorrectionCost = -Math.log(predictionRoots[0].p);
                        }
                        rawPredictions = rawPredictions.concat(predictions);
                        // TODO:  We don't currently de-duplicate predictions at this point quite yet, so
                        // it's technically possible that we return too few.
                        var correctionCost = matches[0].totalCost;
                        // Searching a bit longer is permitted when no predictions have been found.
                        if (correctionCost >= bestCorrectionCost + 8) {
                            break;
                            // If enough have been found, we're safe to terminate earlier.
                        }
                        else if (rawPredictions.length >= ModelCompositor.MAX_SUGGESTIONS) {
                            if (correctionCost >= bestCorrectionCost + 4) { // e^-4 = 0.0183156388.  Allows "80%" of an extra edit.
                                // Very useful for stopping 'sooner' when words reach a sufficient length.
                                break;
                            }
                            else {
                                // Sort the prediction list; we need them in descending order for the next check.
                                rawPredictions.sort(function (a, b) {
                                    return b.p - a.p;
                                });
                                // If the best suggestion from the search's current tier fails to beat the worst
                                // pending suggestion from previous tiers, assume all further corrections will 
                                // similarly fail to win; terminate the search-loop.
                                if (rawPredictions[ModelCompositor.MAX_SUGGESTIONS - 1].p > Math.exp(-correctionCost)) {
                                    break;
                                }
                            }
                        }
                    }
                }
                catch (e_13_1) {
                    e_13 = { error: e_13_1 };
                }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return))
                            _a.call(_c);
                    }
                    finally {
                        if (e_13)
                            throw e_13.error;
                    }
                }
            }
            // Section 2 - post-analysis for our generated predictions, managing 'keep'.
            // Assumption:  Duplicated 'displayAs' properties indicate duplicated Suggestions.
            // When true, we can use an 'associative array' to de-duplicate everything.
            var suggestionDistribMap = {};
            var currentCasing = null;
            if (lexicalModel.languageUsesCasing) {
                currentCasing = this.detectCurrentCasing(postContext);
            }
            var baseWord = this.wordbreak(context);
            try {
                // Deduplicator + annotator of 'keep' suggestions.
                for (var rawPredictions_1 = __values(rawPredictions), rawPredictions_1_1 = rawPredictions_1.next(); !rawPredictions_1_1.done; rawPredictions_1_1 = rawPredictions_1.next()) {
                    var prediction = rawPredictions_1_1.value;
                    // Combine duplicate samples.
                    var displayText = prediction.sample.displayAs;
                    var preserveAsKeep = displayText == keepOptionText;
                    // De-duplication should be case-insensitive, but NOT
                    // diacritic-insensitive.
                    if (this.lexicalModel.languageUsesCasing) {
                        preserveAsKeep = preserveAsKeep || displayText == this.lexicalModel.applyCasing('lower', keepOptionText);
                    }
                    if (preserveAsKeep) {
                        // Preserve the original, pre-keyed version of the text.
                        if (!keepOption) {
                            var baseTransform = prediction.sample.transform;
                            var keepTransform = {
                                insert: keepOptionText,
                                deleteLeft: baseTransform.deleteLeft,
                                deleteRight: baseTransform.deleteRight,
                                id: baseTransform.id
                            };
                            var intermediateKeep = models.transformToSuggestion(keepTransform, prediction.p);
                            keepOption = this.toAnnotatedSuggestion(intermediateKeep, 'keep', models.QuoteBehavior.noQuotes);
                            keepOption.matchesModel = true;
                            // Since we replaced the original Suggestion with a keep-annotated one,
                            // we must manually preserve the transform ID.
                            keepOption.transformId = prediction.sample.transformId;
                        }
                        else if (keepOption.p && prediction.p) {
                            keepOption.p += prediction.p;
                        }
                    }
                    else {
                        // Apply capitalization rules now; facilitates de-duplication of suggestions
                        // that may be caused as a result.
                        //
                        // Example:  "apple" and "Apple" are separate when 'lower', but identical for 'initial' and 'upper'.
                        if (currentCasing && currentCasing != 'lower') {
                            this.applySuggestionCasing(prediction.sample, baseWord, currentCasing);
                            // update the mapping string, too.
                            displayText = prediction.sample.displayAs;
                        }
                        var existingSuggestion = suggestionDistribMap[displayText];
                        if (existingSuggestion) {
                            existingSuggestion.p += prediction.p;
                        }
                        else {
                            suggestionDistribMap[displayText] = prediction;
                        }
                    }
                }
            }
            catch (e_14_1) {
                e_14 = { error: e_14_1 };
            }
            finally {
                try {
                    if (rawPredictions_1_1 && !rawPredictions_1_1.done && (_b = rawPredictions_1.return))
                        _b.call(rawPredictions_1);
                }
                finally {
                    if (e_14)
                        throw e_14.error;
                }
            }
            // Generate a default 'keep' option if one was not otherwise produced.
            if (!keepOption && keepOptionText != '') {
                // IMPORTANT:  duplicate the original transform.  Causes nasty side-effects
                // for context-tracking otherwise!
                var keepTransform = __assign({}, inputTransform);
                // 1 is a filler value; goes unused b/c is for a 'keep'.
                var keepSuggestion = models.transformToSuggestion(keepTransform, 1);
                // This is the one case where the transform doesn't insert the full word; we need to override the displayAs param.
                keepSuggestion.displayAs = keepOptionText;
                keepOption = this.toAnnotatedSuggestion(keepSuggestion, 'keep');
                keepOption.matchesModel = false;
            }
            // Section 3:  Finalize suggestions, truncate list to the N (MAX_SUGGESTIONS) most optimal, return.
            // Now that we've calculated a unique set of probability masses, time to make them into a proper
            // distribution and prep for return.
            for (var key in suggestionDistribMap) {
                var pair = suggestionDistribMap[key];
                suggestionDistribution.push(pair);
            }
            suggestionDistribution = suggestionDistribution.sort(function (a, b) {
                return b.p - a.p; // Use descending order - we want the largest probabilty suggestions first!
            });
            var suggestions = suggestionDistribution.splice(0, ModelCompositor.MAX_SUGGESTIONS).map(function (value) {
                if (value.sample['p']) {
                    // For analysis / debugging
                    value.sample['lexical-p'] = value.sample['p'];
                    value.sample['correction-p'] = value.p / value.sample['p'];
                    // Use of the Trie model always exposed the lexical model's probability for a word to KMW.
                    // It's useful for debugging right now, so may as well repurpose it as the posterior.
                    //
                    // We still condition on 'p' existing so that test cases aren't broken.
                    value.sample['p'] = value.p;
                }
                //
                return value.sample;
            });
            if (keepOption) {
                suggestions = [keepOption].concat(suggestions);
            }
            // Apply 'after word' punctuation and casing (when applicable).  Also, set suggestion IDs.  
            // We delay until now so that utility functions relying on the unmodified Transform may execute properly.
            var compositor = this;
            suggestions.forEach(function (suggestion) {
                // Valid 'keep' suggestions may have zero length; we still need to evaluate the following code
                // for such cases.
                // Do we need to manipulate the suggestion's transform based on the current state of the context?
                if (!context.right) {
                    suggestion.transform.insert += punctuation.insertAfterWord;
                }
                else {
                    // If we're mid-word, delete its original post-caret text.
                    var tokenization = compositor.tokenize(context);
                    if (tokenization && tokenization.caretSplitsToken) {
                        // While we wait on the ability to provide a more 'ideal' solution, let's at least
                        // go with a more stable, if slightly less ideal, solution for now.
                        // 
                        // A predictive text default (on iOS, at least) - immediately wordbreak 
                        // on suggestions accepted mid-word.
                        suggestion.transform.insert += punctuation.insertAfterWord;
                    }
                }
                // If this is a suggestion after wordbreak input, make sure we preserve the wordbreak transform!
                if (prefixTransform) {
                    var mergedTransform = models.buildMergedTransform(prefixTransform, suggestion.transform);
                    mergedTransform.id = suggestion.transformId;
                    // Temporarily and locally drops 'readonly' semantics so that we can reassign the transform.
                    // See https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#improved-control-over-mapped-type-modifiers
                    var mutableSuggestion = suggestion;
                    // Assignment via by-reference behavior, as suggestion is an object
                    mutableSuggestion.transform = mergedTransform;
                }
                suggestion.id = compositor.SUGGESTION_ID_SEED;
                compositor.SUGGESTION_ID_SEED++;
            });
            // Store the suggestions on the final token of the current context state (if it exists).
            // Or, once phrase-level suggestions are possible, on whichever token serves as each prediction's root.
            if (contextState) {
                contextState.tail.replacements = suggestions.map(function (suggestion) {
                    return {
                        suggestion: suggestion,
                        tokenWidth: 1
                    };
                });
            }
            return suggestions;
        };
        // Responsible for applying casing rules to suggestions.
        ModelCompositor.prototype.applySuggestionCasing = function (suggestion, baseWord, casingForm) {
            // Step 1:  does the suggestion replace the whole word?  If not, we should extend the suggestion to do so.
            var unchangedLength = baseWord.kmwLength() - suggestion.transform.deleteLeft;
            if (unchangedLength > 0) {
                suggestion.transform.deleteLeft += unchangedLength;
                suggestion.transform.insert = baseWord.kmwSubstr(0, unchangedLength) + suggestion.transform.insert;
            }
            // Step 2: Now that the transform affects the whole word, we may safely apply casing rules.
            suggestion.transform.insert = this.lexicalModel.applyCasing(casingForm, suggestion.transform.insert);
            suggestion.displayAs = this.lexicalModel.applyCasing(casingForm, suggestion.displayAs);
        };
        ModelCompositor.prototype.toAnnotatedSuggestion = function (suggestion, annotationType, quoteBehavior) {
            if (quoteBehavior === void 0) {
                quoteBehavior = models.QuoteBehavior.default;
            }
            // A method-internal 'import' of the enum.
            var QuoteBehavior = models.QuoteBehavior;
            var defaultQuoteBehavior = QuoteBehavior.noQuotes;
            if (annotationType == 'keep' || annotationType == 'revert') {
                defaultQuoteBehavior = QuoteBehavior.useQuotes;
            }
            return {
                transform: suggestion.transform,
                transformId: suggestion.transformId,
                displayAs: QuoteBehavior.apply(quoteBehavior, suggestion.displayAs, this.punctuation, defaultQuoteBehavior),
                tag: annotationType,
                p: suggestion.p
            };
        };
        /**
         * Returns the punctuation used for this model, filling out unspecified fields
         */
        ModelCompositor.determinePunctuationFromModel = function (model) {
            var defaults = DEFAULT_PUNCTUATION;
            // Use the defaults of the model does not provide any punctuation at all.
            if (!model.punctuation)
                return defaults;
            var specifiedPunctuation = model.punctuation;
            var insertAfterWord = specifiedPunctuation.insertAfterWord;
            if (insertAfterWord !== '' && !insertAfterWord) {
                insertAfterWord = defaults.insertAfterWord;
            }
            var quotesForKeepSuggestion = specifiedPunctuation.quotesForKeepSuggestion;
            if (!quotesForKeepSuggestion) {
                quotesForKeepSuggestion = defaults.quotesForKeepSuggestion;
            }
            var isRTL = specifiedPunctuation.isRTL;
            // Default:  false / undefined, so no need to directly specify it.
            return {
                insertAfterWord: insertAfterWord, quotesForKeepSuggestion: quotesForKeepSuggestion, isRTL: isRTL
            };
        };
        ModelCompositor.prototype.acceptSuggestion = function (suggestion, context, postTransform) {
            // Step 1:  generate and save the reversion's Transform.
            var sourceTransform = suggestion.transform;
            var deletedLeftChars = context.left.kmwSubstr(-sourceTransform.deleteLeft, sourceTransform.deleteLeft);
            var insertedLength = sourceTransform.insert.kmwLength();
            var reversionTransform = {
                insert: deletedLeftChars,
                deleteLeft: insertedLength
            };
            // Step 2:  building the proper 'displayAs' string for the Reversion
            var postContext = context;
            if (postTransform) {
                // The code above restores the state to the context at the time the `Suggestion` was created.
                // `postTransform` handles any missing context that came later.
                reversionTransform = models.buildMergedTransform(reversionTransform, postTransform);
                // Now that we've built the reversion based upon the Suggestion's original context,
                // we manipulate it in order to get a proper 'displayAs' string.
                postContext = models.applyTransform(postTransform, postContext);
            }
            var revertedPrefix;
            var postContextTokenization = this.tokenize(postContext);
            if (postContextTokenization) {
                // Handles display string for reversions triggered by accepting a suggestion mid-token.
                if (postContextTokenization.left.length > 0) {
                    revertedPrefix = postContextTokenization.left[postContextTokenization.left.length - 1];
                }
                else {
                    revertedPrefix = '';
                }
                revertedPrefix += postContextTokenization.caretSplitsToken ? postContextTokenization.right[0] : '';
            }
            else {
                revertedPrefix = this.wordbreak(postContext);
            }
            var firstConversion = models.transformToSuggestion(reversionTransform);
            firstConversion.displayAs = revertedPrefix;
            // Build the actual Reversion, which is technically an annotated Suggestion.
            // Since we're outside of the standard `predict` control path, we'll need to
            // set the Reversion's ID directly.
            var reversion = this.toAnnotatedSuggestion(firstConversion, 'revert');
            if (suggestion.transformId != null) {
                reversion.transformId = -suggestion.transformId;
            }
            if (suggestion.id != null) {
                // Since a reversion inverts its source suggestion, we set its ID to be the 
                // additive inverse of the source suggestion's ID.  Makes easy mapping /
                // verification later.
                reversion.id = -suggestion.id;
            }
            else {
                reversion.id = -this.SUGGESTION_ID_SEED;
                this.SUGGESTION_ID_SEED++;
            }
            // Step 3:  if we track Contexts, update the tracking data as appropriate.
            if (this.contextTracker) {
                var contextState = this.contextTracker.newest;
                if (!contextState) {
                    contextState = this.contextTracker.analyzeState(this.lexicalModel, context);
                }
                contextState.tail.activeReplacementId = suggestion.id;
                var acceptedContext = models.applyTransform(suggestion.transform, context);
                this.contextTracker.analyzeState(this.lexicalModel, acceptedContext);
            }
            return reversion;
        };
        ModelCompositor.prototype.applyReversion = function (reversion, context) {
            // If we are unable to track context (because the model does not support LexiconTraversal),
            // we need a "fallback" strategy.
            var compositor = this;
            var fallbackSuggestions = function () {
                var revertedContext = models.applyTransform(reversion.transform, context);
                var suggestions = compositor.predict({ insert: '', deleteLeft: 0 }, revertedContext);
                suggestions.forEach(function (suggestion) {
                    // A reversion's transform ID is the additive inverse of its original suggestion;
                    // we revert to the state of said original suggestion.
                    suggestion.transformId = -reversion.transformId;
                });
                return suggestions;
            };
            if (!this.contextTracker) {
                return fallbackSuggestions();
            }
            // When the context is tracked, we prefer the tracked information.
            var contextMatchFound = false;
            for (var c = this.contextTracker.count - 1; c >= 0; c--) {
                var contextState = this.contextTracker.item(c);
                if (contextState.tail.activeReplacementId == -reversion.id) {
                    contextMatchFound = true;
                    break;
                }
            }
            if (!contextMatchFound) {
                return fallbackSuggestions();
            }
            // Remove all contexts more recent than the one we're reverting to.
            while (this.contextTracker.newest.tail.activeReplacementId != -reversion.id) {
                this.contextTracker.popNewest();
            }
            this.contextTracker.newest.tail.revert();
            // Will need to be modified a bit if/when phrase-level suggestions are implemented.
            // Those will be tracked on the first token of the phrase, which won't be the tail
            // if they cover multiple tokens.
            var suggestions = this.contextTracker.newest.tail.replacements.map(function (trackedSuggestion) {
                return trackedSuggestion.suggestion;
            });
            suggestions.forEach(function (suggestion) {
                // A reversion's transform ID is the additive inverse of its original suggestion;
                // we revert to the state of said original suggestion.
                suggestion.transformId = -reversion.transformId;
            });
            return suggestions;
        };
        ModelCompositor.prototype.wordbreak = function (context) {
            var model = this.lexicalModel;
            if (model.wordbreaker || !model.wordbreak) {
                // We don't need a 12.0 / 13.0 compatibility mode here.
                // We're either relying on defaults or on the 14.0+ wordbreaker spec.
                var wordbreaker = model.wordbreaker || wordBreakers.default;
                return models.wordbreak(wordbreaker, context);
            }
            else {
                // 1.  This model does not provide a model following the 14.0+ wordbreaking spec
                // 2.  This model DOES define a custom wordbreaker following the 12.0-13.0 spec.
                // Since the model relies on custom wordbreaking behavior, we need to use the
                // old, deprecated wordbreaking pattern.
                return model.wordbreak(context);
            }
        };
        ModelCompositor.prototype.tokenize = function (context) {
            var model = this.lexicalModel;
            if (model.wordbreaker) {
                return models.tokenize(model.wordbreaker, context);
            }
            else {
                return null;
            }
        };
        ModelCompositor.prototype.resetContext = function (context) {
            // Force-resets the context, throwing out any previous fat-finger data, etc.
            // Designed for use when the caret has been directly moved and/or the context sourced from a different control
            // than before.
            if (this.contextTracker) {
                var tokenizedContext = models.tokenize(this.lexicalModel.wordbreaker || wordBreakers.default, context);
                var contextState = correction.ContextTracker.modelContextState(tokenizedContext.left, this.lexicalModel);
                this.contextTracker.enqueue(contextState);
            }
        };
        ModelCompositor.prototype.detectCurrentCasing = function (context) {
            var model = this.lexicalModel;
            var text = this.wordbreak(context);
            if (!model.languageUsesCasing) {
                throw "Invalid attempt to detect casing: languageUsesCasing is set to false";
            }
            if (!model.applyCasing) {
                // The worker should automatically 'sub in' default behavior during the model's load if that
                // function isn't defined explicitly as part of the model.
                throw "Invalid LMLayer state:  languageUsesCasing is set to true, but no applyCasing function exists";
            }
            if (model.applyCasing('lower', text) == text) {
                return 'lower';
            }
            else if (model.applyCasing('upper', text) == text) {
                // If only a single character has been input, assume we're in 'initial' mode.
                return text.kmwLength() > 1 ? 'upper' : 'initial';
            }
            else if (model.applyCasing('initial', text) == text) {
                // We check 'initial' last, as upper-case input is indistinguishable.
                return 'initial';
            }
            else {
                // 'null' is returned when no casing pattern matches the input.
                return null;
            }
        };
        ModelCompositor.MAX_SUGGESTIONS = 12;
        return ModelCompositor;
    }());
    /**
     * The default punctuation and spacing produced by the model.
     */
    var DEFAULT_PUNCTUATION = {
        quotesForKeepSuggestion: { open: "\u201C", close: "\u201D" },
        insertAfterWord: " ",
    };
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    /**
     * @file index.ts
     *
     * The main LMLayerWorker class, the top-level class within the Web Worker.
     * The LMLayerWorker handles the keyboard/worker communication
     * protocol, delegating prediction requests to the language
     * model implementations.
     */
    /// <reference path="../message.d.ts" />
    /// <reference path="models/dummy-model.ts" />
    /// <reference path="../node_modules/@keymanapp/models-wordbreakers/src/index.ts" />
    /// <reference path="./model-compositor.ts" />
    /**
     * Encapsulates all the state required for the LMLayer's worker thread.
     *
     * Implements the state pattern. There are three states:
     *
     *  - `unconfigured`  (initial state before configuration)
     *  - `modelless`     (state without model loaded)
     *  - `ready`         (state with model loaded, accepts prediction requests)
     *
     * Transitions are initiated by valid messages. Invalid
     * messages are errors, and do not lead to transitions.
     *
     *          +-------------+    load    +---------+
     *   config |             |----------->|         |
     *  +------->  modelless  +            +  ready  +---+
     *          |             |<-----------|         |   |
     *          +-------------+   unload   +----^----+   | predict
     *                                          |        |
     *                                          +--------+
     *
     * The model and the configuration are ONLY relevant in the `ready` state;
     * as such, they are NOT direct properties of the LMLayerWorker.
     */
    var LMLayerWorker = /** @class */ (function () {
        function LMLayerWorker(options) {
            if (options === void 0) {
                options = {
                    importScripts: null,
                    postMessage: null
                };
            }
            this._postMessage = options.postMessage || postMessage;
            this._importScripts = options.importScripts || importScripts;
            this.setupConfigState();
        }
        LMLayerWorker.prototype.error = function (message, error) {
            // error isn't a fan of being cloned across the worker boundary.
            this.cast('error', {
                log: message,
                error: (error && error.stack) ? error.stack : undefined
            });
        };
        /**
         * A function that can be set as self.onmessage (the Worker
         * message handler).
         * NOTE! You must bind it to a specific instance, e.g.:
         *
         *   // Do this!
         *   self.onmessage = worker.onMessage.bind(worker);
         *
         * Incorrect:
         *
         *   // Don't do this!
         *   self.onmessage = worker.onMessage;
         *
         * See: .install();
         */
        LMLayerWorker.prototype.onMessage = function (event) {
            var message = event.data.message;
            // Ensure the message is tagged with a valid message tag.
            if (!message) {
                throw new Error("Missing required 'message' property: " + event.data);
            }
            // If last load was for this exact model file, squash the message.
            // (Though not if we've had an unload since.)
            var im = event.data;
            if (im.message == 'load') {
                var data = im;
                var duplicated = false;
                if (this._currentModelSource && data.source.type == this._currentModelSource.type) {
                    if (data.source.type == 'file' && data.source.file == this._currentModelSource.file) {
                        duplicated = true;
                    }
                    else if (data.source.type == 'raw' && data.source.code == this._currentModelSource.code) {
                        duplicated = true;
                    }
                }
                if (duplicated) {
                    // Some JS implementations don't allow web workers access to the console.
                    if (typeof console !== 'undefined') {
                        console.warn("Duplicate model load message detected - squashing!");
                    }
                    return;
                }
                else {
                    this._currentModelSource = data.source;
                }
            }
            else if (im.message == 'unload') {
                this._currentModelSource = null;
            }
            // We got a message! Delegate to the current state.
            this.state.handleMessage(im);
        };
        /**
         * Sends back a message structured according to the protocol.
         * @param message A message type.
         * @param payload The message's payload. Can have any properties, except 'message'.
         */
        LMLayerWorker.prototype.cast = function (message, payload) {
            // Chrome raises "TypeError: invalid invocation" if postMessage is called
            // with any non-default value for `this`, i.e., this won't work:
            //
            //  this._postMessage({ foo: 'bar' });
            //
            // Yank it postMessage() off of `this` so that it's called on the
            // "global" context, and everything works again.
            var postMessage = this._postMessage;
            postMessage(__assign({ message: message }, payload));
        };
        /**
         * Loads a model by executing the given source code, and
         * passing in the appropriate configuration.
         *
         * @param desc         Type of the model to instantiate and its parameters.
         * @param capabilities Capabilities on offer from the keyboard.
         */
        LMLayerWorker.prototype.loadModel = function (model) {
            // TODO:  pass _platformConfig to model so that it can self-configure to the platform,
            // returning a Configuration.
            /* Note that this function is typically called from within an `importScripts` call.
             * For meaningful error messages to be successfully logged, we must catch what we can here
             * and pass a message to outside the worker - otherwise a generic "Script error" occurs.
             */
            try {
                var configuration = model.configure(this._platformCapabilities);
                // Handle deprecations.
                if (!configuration.leftContextCodePoints) {
                    configuration.leftContextCodePoints = configuration.leftContextCodeUnits;
                }
                if (!configuration.rightContextCodePoints) {
                    configuration.rightContextCodePoints = configuration.rightContextCodeUnits;
                }
                // Set reasonable defaults for the configuration.
                if (!configuration.leftContextCodePoints) {
                    configuration.leftContextCodePoints = this._platformCapabilities.maxLeftContextCodePoints;
                }
                if (!configuration.rightContextCodePoints) {
                    configuration.rightContextCodePoints = this._platformCapabilities.maxRightContextCodePoints || 0;
                }
                // Ensures that default casing rules exist for custom models that request casing rules but don't define them.
                if (model.languageUsesCasing && !model.applyCasing) {
                    model.applyCasing = models.defaultApplyCasing;
                }
                var compositor = this.transitionToReadyState(model);
                // This test allows models to directly specify the property without it being auto-overridden by
                // this default.
                if (configuration.wordbreaksAfterSuggestions === undefined) {
                    configuration.wordbreaksAfterSuggestions = (compositor.punctuation.insertAfterWord != '');
                }
                this.cast('ready', { configuration: configuration });
            }
            catch (err) {
                this.error("loadModel failed!", err);
            }
        };
        LMLayerWorker.prototype.loadModelFile = function (url) {
            // The self/global WebWorker method, allowing us to directly import another script file into WebWorker scope.
            // If built correctly, the model's script file will auto-register the model with loadModel() above.
            try {
                this._importScripts(url);
            }
            catch (err) {
                this.error("Error occurred when attempting to load dictionary", err);
            }
        };
        LMLayerWorker.prototype.unloadModel = function () {
            // Right now, this seems sufficient to clear out the old model.
            // The only existing reference to a loaded model is held by 
            // transitionToReadyState's `handleMessage` closure. (The `model` var)
            this.transitionToLoadingState();
        };
        /**
         * Sets the initial state, i.e., `unconfigured`.
         * This state only handles `config` messages, and will
         * transition to the `modelless` state once it receives
         * the config data from the host platform.
         */
        LMLayerWorker.prototype.setupConfigState = function () {
            var _this_1 = this;
            this.state = {
                name: 'unconfigured',
                handleMessage: function (payload) {
                    // ... that message must have been 'config'!
                    if (payload.message !== 'config') {
                        throw new Error("invalid message; expected 'config' but got " + payload.message);
                    }
                    _this_1._platformCapabilities = payload.capabilities;
                    _this_1.transitionToLoadingState();
                }
            };
        };
        /**
         * Sets the model-loading state, i.e., `modelless`.
         * This state only handles `load` messages, and will
         * transition to the `ready` state once it receives a model
         * description and capabilities.
         */
        LMLayerWorker.prototype.transitionToLoadingState = function () {
            var _this = this;
            this.state = {
                name: 'modelless',
                handleMessage: function (payload) {
                    // ...that message must have been 'load'!
                    if (payload.message !== 'load') {
                        throw new Error("invalid message; expected 'load' but got " + payload.message);
                    }
                    // TODO: validate configuration?
                    if (payload.source.type == 'file') {
                        _this.loadModelFile(payload.source.file);
                    }
                    else {
                        // Creates a closure capturing all top-level names that the model must be able to reference.
                        // `eval` runs by scope rules; our virtualized worker needs a special scope for this to work.
                        //
                        // Reference: https://stackoverflow.com/a/40108685
                        // Note that we don't need `this`, but we do need the namespaces seen below. 
                        var code_1 = payload.source.code;
                        var evalInContext = function (LMLayerWorker, models, correction, wordBreakers) {
                            eval(code_1);
                        };
                        evalInContext(_this, models, correction, wordBreakers);
                    }
                }
            };
        };
        /**
         * Sets the state to `ready`. This requires a
         * fully-instantiated model. The `ready` state only responds
         * to `predict` message, and is an accepting state.
         *
         * @param model The loaded language model.
         */
        LMLayerWorker.prototype.transitionToReadyState = function (model) {
            var _this_1 = this;
            var compositor = new ModelCompositor(model);
            this.state = {
                name: 'ready',
                handleMessage: function (payload) {
                    switch (payload.message) {
                        case 'predict':
                            var transform = payload.transform, context = payload.context;
                            var suggestions = compositor.predict(transform, context);
                            // Now that the suggestions are ready, send them out!
                            _this_1.cast('suggestions', {
                                token: payload.token,
                                suggestions: suggestions
                            });
                            break;
                        case 'wordbreak':
                            var brokenWord = models.wordbreak(model.wordbreaker || wordBreakers.default, payload.context);
                            _this_1.cast('currentword', {
                                token: payload.token,
                                word: brokenWord
                            });
                            break;
                        case 'unload':
                            _this_1.unloadModel();
                            break;
                        case 'accept':
                            var suggestion = payload.suggestion, context = payload.context, postTransform = payload.postTransform;
                            var reversion = compositor.acceptSuggestion(suggestion, context, postTransform);
                            _this_1.cast('postaccept', {
                                token: payload.token,
                                reversion: reversion
                            });
                            break;
                        case 'revert':
                            var reversion = payload.reversion, context = payload.context;
                            var suggestions = compositor.applyReversion(reversion, context);
                            _this_1.cast('postrevert', {
                                token: payload.token,
                                suggestions: suggestions
                            });
                            break;
                        case 'reset-context':
                            var context = payload.context;
                            compositor.resetContext(context);
                            break;
                        default:
                            throw new Error("invalid message; expected one of {'predict', 'wordbreak', 'accept', 'revert', 'reset-context', 'unload'} but got " + payload.message);
                    }
                },
                compositor: compositor
            };
            return compositor;
        };
        /**
         * Creates a new instance of the LMLayerWorker, and installs all its
         * functions within the provided Worker global scope.
         *
         * In production, this is called within the Worker's scope as:
         *
         *    LMLayerWorker.install(self);
         *
         * ...and this will setup onmessage and postMessage() appropriately.
         *
         * During testing, this method is useful to mock an entire global scope,
         *
         *    var fakeScope = { postMessage: ... };
         *    LMLayerWorker.install(fakeScope);
         *    // now we can spy on methods in fakeScope!
         *
         * @param scope A global scope to install upon.
         */
        LMLayerWorker.install = function (scope) {
            var worker = new LMLayerWorker({ postMessage: scope.postMessage, importScripts: scope.importScripts.bind(scope) });
            scope.onmessage = worker.onMessage.bind(worker);
            worker.self = scope;
            // Ensures that the worker instance is accessible for loaded model scripts.
            // Assists unit-testing.
            scope['LMLayerWorker'] = worker;
            scope['models'] = models;
            scope['correction'] = correction;
            scope['wordBreakers'] = wordBreakers;
            return worker;
        };
        return LMLayerWorker;
    }());
    // Let LMLayerWorker be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = LMLayerWorker;
        module.exports['correction'] = correction;
        module.exports['models'] = models;
        module.exports['wordBreakers'] = wordBreakers;
        /// XXX: export the ModelCompositor for testing.
        module.exports['ModelCompositor'] = ModelCompositor;
    }
    else if (typeof self !== 'undefined' && 'postMessage' in self) {
        // Automatically install if we're in a Web Worker.
        LMLayerWorker.install(self); // really, 'as typeof globalThis', but we're currently getting TS errors from use of that.
    }
    else {
        //@ts-ignore
        window.LMLayerWorker = LMLayerWorker;
    }
    /*
     * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
     * Copyright (c) 2018 SIL International
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of
     * this software and associated documentation files (the "Software"), to deal in
     * the Software without restriction, including without limitation the rights to
     * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
     * the Software, and to permit persons to whom the Software is furnished to do so,
     * subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
    //# sourceMappingURL=index.js.map
}
/// <reference path="embedded_worker.d.ts" />
/// <reference path="worker-interface.d.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                // Unfortunately, importing like this loses all type information for the modules.
                // It's that, or massively overhaul lm-layer to be module-based instead of
                // namespace-based.
                var fs = require("fs");
                var vm = require("vm");
                var VirtualizedWorkerContext = /** @class */ (function () {
                    function VirtualizedWorkerContext() {
                        this.self = this;
                    }
                    VirtualizedWorkerContext.prototype.importScripts = function () {
                        var scriptNames = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            scriptNames[_i] = arguments[_i];
                        }
                        /* Use of vm.createContext and script.runInContext allow us to avoid
                          * polluting the global scope with imports.  When we throw away the
                          * context object, imported scripts will be automatically GC'd.
                          */
                        for (var _a = 0, scriptNames_1 = scriptNames; _a < scriptNames_1.length; _a++) {
                            var script = scriptNames_1[_a];
                            this.__importScriptString(fs.readFileSync(script, "UTF-8"));
                        }
                    };
                    VirtualizedWorkerContext.prototype.__importScriptString = function (scriptStr) {
                        var context = vm.createContext(this);
                        var script = new vm.Script(scriptStr);
                        script.runInContext(context);
                    };
                    return VirtualizedWorkerContext;
                }());
                /**
                 * Note:  this does not create an actual Worker, separate process, or thread.  Everything will
                 *        be executed in-line on a virtualized context.
                 *
                 *        In the future, it might be nice to use Node's Worker Threads implementation.
                 */
                var VirtualizedWorker = /** @class */ (function () {
                    function VirtualizedWorker(scriptStr) {
                        this._workerContext = new VirtualizedWorkerContext();
                        // Needs to exist before setting up the worker; must exist by `.install()`.
                        this._workerContext.postMessage = this.workerPostMessage.bind(this);
                        // Initialize the "worker".
                        this._workerContext.__importScriptString(scriptStr);
                    }
                    // Sends the worker's postMessage messages to the appropriate `onmessage` handler.
                    VirtualizedWorker.prototype.workerPostMessage = function (message) {
                        if (this.onmessage) {
                            this.onmessage({ data: message });
                        }
                    };
                    VirtualizedWorker.prototype.postMessage = function (message) {
                        var msgObj = { data: message };
                        var msgJSON = JSON.stringify(msgObj);
                        /*
                         * Execute the command within the virtualized worker's scope.  The worker's returned
                         * `postMessage` calls will still reach outside, as they have a reference to `this` via
                         * `postMessage` (which we've set to a bound `this.workerPostMessage`).
                         *
                         * Among other things, this will allow the worker to use its internal namespaces without issue.
                         */
                        var msgCommand = "onmessage(" + msgJSON + ")";
                        this._workerContext.__importScriptString(msgCommand);
                    };
                    VirtualizedWorker.prototype.terminate = function () {
                        this._workerContext = null;
                    };
                    return VirtualizedWorker;
                }());
                prediction.VirtualizedWorker = VirtualizedWorker;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
///<reference path="virtualizedWorker.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                var DefaultWorker = /** @class */ (function () {
                    function DefaultWorker() {
                    }
                    DefaultWorker.constructInstance = function () {
                        var scriptStr = prediction.LMLayer.unwrap(LMLayerWorkerCode);
                        var worker = new prediction.VirtualizedWorker(scriptStr);
                        return worker;
                    };
                    return DefaultWorker;
                }());
                prediction.DefaultWorker = DefaultWorker;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var has = Object.prototype.hasOwnProperty, prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() { }
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__)
        prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
    else
        emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
        emitter._events = new Events();
    else
        delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
        return names;
    for (name in (events = this._events)) {
        if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
        return [];
    if (handlers.fn)
        return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
    }
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
        return 0;
    if (listeners.fn)
        return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
        return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once)
            this.removeListener(event, listeners.fn, undefined, true);
        switch (len) {
            case 1: return listeners.fn.call(listeners.context), true;
            case 2: return listeners.fn.call(listeners.context, a1), true;
            case 3: return listeners.fn.call(listeners.context, a1, a2), true;
            case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
    }
    else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
            if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, undefined, true);
            switch (len) {
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args)
                        for (j = 1, args = new Array(len - 1); j < len; j++) {
                            args[j - 1] = arguments[j];
                        }
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
        return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn &&
            (!once || listeners.once) &&
            (!context || listeners.context === context)) {
            clearEvent(this, evt);
        }
    }
    else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn ||
                (once && !listeners[i].once) ||
                (context && listeners[i].context !== context)) {
                events.push(listeners[i]);
            }
        }
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
        else
            clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
            clearEvent(this, evt);
    }
    else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
//
// Expose the module.
//
if ('undefined' !== typeof module) {
    module.exports = EventEmitter;
}
// Implements Node's EventEmitter class and related module components in a near
// browser-compatible way.  (Just requires a blank 'module' object on the window.)
///<reference path="../../node_modules/eventemitter3/index.js" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            text.Codes = {
                // Define Keyman Developer modifier bit-flags (exposed for use by other modules)
                // Compare against /common/core/desktop/src/kmx/kmx_file.h.  CTRL+F "#define LCTRLFLAG" to find the secton.
                modifierCodes: {
                    "LCTRL": 0x0001,
                    "RCTRL": 0x0002,
                    "LALT": 0x0004,
                    "RALT": 0x0008,
                    "SHIFT": 0x0010,
                    "CTRL": 0x0020,
                    "ALT": 0x0040,
                    // TENTATIVE:  Represents command keys, which some OSes use for shortcuts we don't
                    // want to block.  No rule will ever target a modifier set with this bit set to 1. 
                    "META": 0x0080,
                    "CAPS": 0x0100,
                    "NO_CAPS": 0x0200,
                    "NUM_LOCK": 0x0400,
                    "NO_NUM_LOCK": 0x0800,
                    "SCROLL_LOCK": 0x1000,
                    "NO_SCROLL_LOCK": 0x2000,
                    "VIRTUAL_KEY": 0x4000,
                    "VIRTUAL_CHAR_KEY": 0x8000 // VIRTUALCHARKEY // Unused by KMW, but reserved for use by other Keyman engines.
                },
                modifierBitmasks: {
                    "ALL": 0x007F,
                    "ALT_GR_SIM": (0x0001 | 0x0004),
                    "CHIRAL": 0x001F,
                    "IS_CHIRAL": 0x000F,
                    "NON_CHIRAL": 0x0070 // The default bitmask, for non-chiral keyboards
                },
                stateBitmasks: {
                    "ALL": 0x3F00,
                    "CAPS": 0x0300,
                    "NUM_LOCK": 0x0C00,
                    "SCROLL_LOCK": 0x3000
                },
                // Define standard keycode numbers (exposed for use by other modules)
                keyCodes: {
                    "K_BKSP": 8, "K_TAB": 9, "K_ENTER": 13,
                    "K_SHIFT": 16, "K_CONTROL": 17, "K_ALT": 18, "K_PAUSE": 19, "K_CAPS": 20,
                    "K_ESC": 27, "K_SPACE": 32, "K_PGUP": 33,
                    "K_PGDN": 34, "K_END": 35, "K_HOME": 36, "K_LEFT": 37, "K_UP": 38,
                    "K_RIGHT": 39, "K_DOWN": 40, "K_SEL": 41, "K_PRINT": 42, "K_EXEC": 43,
                    "K_INS": 45, "K_DEL": 46, "K_HELP": 47, "K_0": 48,
                    "K_1": 49, "K_2": 50, "K_3": 51, "K_4": 52, "K_5": 53, "K_6": 54, "K_7": 55,
                    "K_8": 56, "K_9": 57, "K_A": 65, "K_B": 66, "K_C": 67, "K_D": 68, "K_E": 69,
                    "K_F": 70, "K_G": 71, "K_H": 72, "K_I": 73, "K_J": 74, "K_K": 75, "K_L": 76,
                    "K_M": 77, "K_N": 78, "K_O": 79, "K_P": 80, "K_Q": 81, "K_R": 82, "K_S": 83,
                    "K_T": 84, "K_U": 85, "K_V": 86, "K_W": 87, "K_X": 88, "K_Y": 89, "K_Z": 90,
                    "K_NP0": 96, "K_NP1": 97, "K_NP2": 98,
                    "K_NP3": 99, "K_NP4": 100, "K_NP5": 101, "K_NP6": 102,
                    "K_NP7": 103, "K_NP8": 104, "K_NP9": 105, "K_NPSTAR": 106,
                    "K_NPPLUS": 107, "K_SEPARATOR": 108, "K_NPMINUS": 109, "K_NPDOT": 110,
                    "K_NPSLASH": 111, "K_F1": 112, "K_F2": 113, "K_F3": 114, "K_F4": 115,
                    "K_F5": 116, "K_F6": 117, "K_F7": 118, "K_F8": 119, "K_F9": 120,
                    "K_F10": 121, "K_F11": 122, "K_F12": 123, "K_NUMLOCK": 144, "K_SCROLL": 145,
                    "K_LSHIFT": 160, "K_RSHIFT": 161, "K_LCONTROL": 162, "K_RCONTROL": 163,
                    "K_LALT": 164, "K_RALT": 165,
                    "K_COLON": 186, "K_EQUAL": 187, "K_COMMA": 188, "K_HYPHEN": 189,
                    "K_PERIOD": 190, "K_SLASH": 191, "K_BKQUOTE": 192,
                    "K_LBRKT": 219, "K_BKSLASH": 220, "K_RBRKT": 221,
                    "K_QUOTE": 222, "K_oE2": 226, "K_OE2": 226,
                    "K_LOPT": 50001, "K_ROPT": 50002,
                    "K_NUMERALS": 50003, "K_SYMBOLS": 50004, "K_CURRENCIES": 50005,
                    "K_UPPER": 50006, "K_LOWER": 50007, "K_ALPHA": 50008,
                    "K_SHIFTED": 50009, "K_ALTGR": 50010,
                    "K_TABBACK": 50011, "K_TABFWD": 50012
                },
                codesUS: [
                    ['0123456789', ';=,-./`', '[\\]\''],
                    [')!@#$%^&*(', ':+<_>?~', '{|}"']
                ]
            };
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            // Defines the base Deadkey-tracking object.
            var Deadkey = /** @class */ (function () {
                function Deadkey(pos, id) {
                    this.p = pos;
                    this.d = id;
                    this.o = Deadkey.ordinalSeed++;
                }
                Deadkey.prototype.match = function (p, d) {
                    var result = (this.p == p && this.d == d);
                    return result;
                };
                Deadkey.prototype.set = function () {
                    this.matched = 1;
                };
                Deadkey.prototype.reset = function () {
                    this.matched = 0;
                };
                Deadkey.prototype.before = function (other) {
                    return this.o < other.o;
                };
                Deadkey.prototype.clone = function () {
                    var dk = new Deadkey(this.p, this.d);
                    dk.o = this.o;
                    return dk;
                };
                Deadkey.ordinalSeed = 0;
                /**
                 * Sorts the deadkeys in reverse order.
                 */
                Deadkey.sortFunc = function (a, b) {
                    // We want descending order, so we want 'later' deadkeys first.
                    if (a.p != b.p) {
                        return b.p - a.p;
                    }
                    else {
                        return b.o - a.o;
                    }
                };
                return Deadkey;
            }());
            text.Deadkey = Deadkey;
            // Object-orients deadkey management.
            var DeadkeyTracker = /** @class */ (function () {
                function DeadkeyTracker() {
                    this.dks = [];
                }
                DeadkeyTracker.prototype.toSortedArray = function () {
                    this.dks = this.dks.sort(Deadkey.sortFunc);
                    return [].concat(this.dks);
                };
                DeadkeyTracker.prototype.clone = function () {
                    var dkt = new DeadkeyTracker();
                    var dks = this.toSortedArray();
                    // Make sure to clone the deadkeys themselves - the Deadkey object is mutable.
                    dkt.dks = [];
                    dks.forEach(function (value) {
                        dkt.dks.push(value.clone());
                    });
                    return dkt;
                };
                /**
                 * Function     isMatch
                 * Scope        Public
                 * @param       {number}      caretPos  current cursor position
                 * @param       {number}      n         expected offset of deadkey from cursor
                 * @param       {number}      d         deadkey
                 * @return      {boolean}               True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                DeadkeyTracker.prototype.isMatch = function (caretPos, n, d) {
                    if (this.dks.length == 0) {
                        return false; // I3318
                    }
                    var sp = caretPos;
                    n = sp - n;
                    for (var i = 0; i < this.dks.length; i++) {
                        // Don't re-match an already-matched deadkey.  It's possible to have two identical 
                        // entries, and they should be kept separately.
                        if (this.dks[i].match(n, d) && !this.dks[i].matched) {
                            this.dks[i].set();
                            // Assumption:  since we match the first possible entry in the array, we
                            // match the entry with the lower ordinal - the 'first' deadkey in the position.
                            return true; // I3318
                        }
                    }
                    this.resetMatched(); // I3318
                    return false;
                };
                DeadkeyTracker.prototype.add = function (dk) {
                    this.dks = this.dks.concat(dk);
                };
                DeadkeyTracker.prototype.remove = function (dk) {
                    var index = this.dks.indexOf(dk);
                    this.dks.splice(index, 1);
                };
                DeadkeyTracker.prototype.clear = function () {
                    this.dks = [];
                };
                DeadkeyTracker.prototype.resetMatched = function () {
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        dk.reset();
                    }
                };
                DeadkeyTracker.prototype.deleteMatched = function () {
                    for (var Li = 0; Li < this.dks.length; Li++) {
                        if (this.dks[Li].matched) {
                            this.dks.splice(Li--, 1); // Don't forget to decrement!
                        }
                    }
                };
                /**
                 * Function     adjustPositions (formerly _DeadkeyAdjustPos)
                 * Scope        Private
                 * @param       {number}      Lstart      start position in context
                 * @param       {number}      Ldelta      characters to adjust by
                 * Description  Adjust saved positions of deadkeys in context
                 */
                DeadkeyTracker.prototype.adjustPositions = function (Lstart, Ldelta) {
                    if (Ldelta == 0) {
                        return;
                    }
                    for (var _i = 0, _a = this.dks; _i < _a.length; _i++) {
                        var dk = _a[_i];
                        if (dk.p > Lstart) {
                            dk.p += Ldelta;
                        }
                    }
                };
                DeadkeyTracker.prototype.count = function () {
                    return this.dks.length;
                };
                return DeadkeyTracker;
            }());
            text.DeadkeyTracker = DeadkeyTracker;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines deadkey management in a manner attachable to each element interface.
///<reference path="../text/deadkeys.ts" />
// Defines the KeyEvent type.
///<reference path="keyEvent.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// Also relies on string-extensions provided by the web-utils package.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text_1) {
            var TextTransform = /** @class */ (function () {
                function TextTransform(insert, deleteLeft, deleteRight) {
                    this.insert = insert;
                    this.deleteLeft = deleteLeft;
                    this.deleteRight = deleteRight || 0;
                }
                TextTransform.nil = new TextTransform('', 0, 0);
                return TextTransform;
            }());
            text_1.TextTransform = TextTransform;
            var Transcription = /** @class */ (function () {
                function Transcription(keystroke, transform, preInput, alternates /*, removedDks: Deadkey[], insertedDks: Deadkey[]*/) {
                    var token = this.token = Transcription.tokenSeed++;
                    this.keystroke = keystroke;
                    this.transform = transform;
                    this.alternates = alternates;
                    this.preInput = preInput;
                    this.transform.id = this.token;
                    // Assign the ID to each alternate, as well.
                    if (alternates) {
                        alternates.forEach(function (alt) {
                            alt.sample.id = token;
                        });
                    }
                }
                Transcription.tokenSeed = 0;
                return Transcription;
            }());
            text_1.Transcription = Transcription;
            var OutputTarget = /** @class */ (function () {
                function OutputTarget() {
                    this._dks = new text.DeadkeyTracker();
                }
                Object.defineProperty(OutputTarget.prototype, "isSynthetic", {
                    /**
                     * Signifies that this OutputTarget has no default key processing behaviors.  This should be false
                     * for OutputTargets backed by web elements like HTMLInputElement or HTMLTextAreaElement.
                     */
                    get: function () {
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                OutputTarget.prototype.resetContext = function () {
                    this.deadkeys().clear();
                };
                OutputTarget.prototype.deadkeys = function () {
                    return this._dks;
                };
                OutputTarget.prototype.hasDeadkeyMatch = function (n, d) {
                    return this.deadkeys().isMatch(this.getDeadkeyCaret(), n, d);
                };
                OutputTarget.prototype.insertDeadkeyBeforeCaret = function (d) {
                    var dk = new text_1.Deadkey(this.getDeadkeyCaret(), d);
                    this.deadkeys().add(dk);
                };
                /**
                 * Should be called by each output target immediately before text mutation operations occur.
                 *
                 * Maintains solutions to old issues:  I3318,I3319
                 * @param {number} delta  Use negative values if characters were deleted, positive if characters were added.
                 */
                OutputTarget.prototype.adjustDeadkeys = function (delta) {
                    this.deadkeys().adjustPositions(this.getDeadkeyCaret(), delta);
                };
                /**
                 * Needed to properly clone deadkeys for use with Mock element interfaces toward predictive text purposes.
                 * @param {object}  dks   An existing set of deadkeys to deep-copy for use by this element interface.
                 */
                OutputTarget.prototype.setDeadkeys = function (dks) {
                    this._dks = dks.clone();
                };
                /**
                 * Determines the basic operations needed to reconstruct the current OutputTarget's text from the prior state specified
                 * by another OutputTarget based on their text and caret positions.
                 *
                 * This is designed for use as a "before and after" comparison to determine the effect of a single keyboard rule at a time.
                 * As such, it assumes that the caret is immediately after any inserted text.
                 * @param from An output target (preferably a Mock) representing the prior state of the input/output system.
                 */
                OutputTarget.prototype.buildTransformFrom = function (original) {
                    var to = this.getText();
                    var from = original.getText();
                    var fromCaret = original.getDeadkeyCaret();
                    var toCaret = this.getDeadkeyCaret();
                    // Step 1:  Determine the number of left-deletions.
                    var maxSMPLeftMatch = fromCaret < toCaret ? fromCaret : toCaret;
                    // We need the corresponding non-SMP caret location in order to binary-search efficiently.
                    // (Examining code units is much more computationally efficient.)
                    var maxLeftMatch = to._kmwCodePointToCodeUnit(maxSMPLeftMatch);
                    // 1.1:  use a non-SMP-aware binary search to determine the divergence point.
                    var start = 0;
                    var end = maxLeftMatch; // the index AFTER the last possible matching char.
                    // This search is O(maxLeftMatch).  1/2 + 1/4 + 1/8 + ... converges to = 1.
                    while (start < end) {
                        var mid = Math.floor((end + start + 1) / 2); // round up (compare more)
                        var fromLeft = from.substr(start, mid - start);
                        var toLeft = to.substr(start, mid - start);
                        if (fromLeft == toLeft) {
                            start = mid;
                        }
                        else {
                            end = mid - 1;
                        }
                    }
                    // At the loop's end:  `end` now holds the non-SMP-aware divergence point.
                    // The 'caret' is after the last matching code unit.
                    // 1.2:  detect a possible surrogate-pair split scenario, correcting for it
                    //       (by moving the split before the high-surrogate) if detected.
                    // If the split location is precisely on either end of the context, we can't
                    // have split a surrogate pair.
                    if (end > 0 && end < maxLeftMatch) {
                        var potentialHigh = from.charCodeAt(end - 1);
                        var potentialFromLow = from.charCodeAt(end);
                        var potentialToLow = to.charCodeAt(end);
                        // if potentialHigh is a possible high surrogate...
                        if (potentialHigh >= 0xD800 && potentialHigh <= 0xDBFF) {
                            // and at least one potential 'low' is a possible low surrogate...
                            var flag = potentialFromLow >= 0xDC00 && potentialFromLow <= 0xDFFF;
                            flag = flag || (potentialToLow >= 0XDC00 && potentialToLow <= 0xDFFF);
                            // Correct the split location, moving it 'before' the high surrogate.
                            if (flag) {
                                end = end - 1;
                            }
                        }
                    }
                    // 1.3:  take substring from start to the split point; determine SMP-aware length.
                    //       This yields the SMP-aware divergence index, which gives the number of left-deletes.
                    var newCaret = from._kmwCodeUnitToCodePoint(end);
                    var deletedLeft = fromCaret - newCaret;
                    // Step 2:  Determine the other properties.
                    // Since the 'after' OutputTarget's caret indicates the end of any inserted text, we
                    // can easily calculate the rest.
                    var insertedLength = toCaret - newCaret;
                    var delta = to._kmwSubstr(newCaret, insertedLength);
                    var undeletedRight = to._kmwLength() - toCaret;
                    var originalRight = from._kmwLength() - fromCaret;
                    var deletedRight = originalRight - undeletedRight;
                    // May occur when reverting a suggestion that had been applied mid-word.
                    if (deletedRight < 0) {
                        // Restores deleteRight characters.
                        delta = delta + to._kmwSubstr(toCaret, -deletedRight);
                        deletedRight = 0;
                    }
                    return new TextTransform(delta, deletedLeft, deletedRight);
                };
                OutputTarget.prototype.buildTranscriptionFrom = function (original, keyEvent, alternates) {
                    var transform = this.buildTransformFrom(original);
                    // If we ever decide to re-add deadkey tracking, this is the place for it.
                    return new Transcription(keyEvent, transform, Mock.from(original), alternates);
                };
                /**
                 * Restores the `OutputTarget` to the indicated state.  Designed for use with `Transcription.preInput`.
                 * @param original An `OutputTarget` (usually a `Mock`).
                 */
                OutputTarget.prototype.restoreTo = function (original) {
                    //
                    this.setTextBeforeCaret(original.getTextBeforeCaret());
                    this.setTextAfterCaret(original.getTextAfterCaret());
                    // Also, restore the deadkeys!
                    this._dks = original._dks.clone();
                };
                OutputTarget.prototype.apply = function (transform) {
                    if (transform.deleteRight) {
                        this.setTextAfterCaret(this.getTextAfterCaret()._kmwSubstr(transform.deleteRight));
                    }
                    if (transform.deleteLeft) {
                        this.deleteCharsBeforeCaret(transform.deleteLeft);
                    }
                    if (transform.insert) {
                        this.insertTextBeforeCaret(transform.insert);
                    }
                    // We assume that all deadkeys are invalidated after applying a Transform, since
                    // prediction implies we'll be completing a word, post-deadkeys.
                    this._dks.clear();
                };
                /**
                 * Helper to `restoreTo` - allows directly setting the 'before' context to that of another
                 * `OutputTarget`.
                 * @param s
                 */
                OutputTarget.prototype.setTextBeforeCaret = function (s) {
                    // This one's easy enough to provide a default implementation for.
                    this.deleteCharsBeforeCaret(this.getTextBeforeCaret()._kmwLength());
                    this.insertTextBeforeCaret(s);
                };
                /**
                 * Saves element-specific state properties prone to mutation, enabling restoration after
                 * text-output operations.
                 */
                OutputTarget.prototype.saveProperties = function () {
                    // Most element interfaces won't need anything here.
                };
                /**
                 * Restores previously-saved element-specific state properties.  Designed for use after text-output
                 * ops to facilitate more-seamless web-dev and user interactions.
                 */
                OutputTarget.prototype.restoreProperties = function () {
                    // Most element interfaces won't need anything here. 
                };
                return OutputTarget;
            }());
            text_1.OutputTarget = OutputTarget;
            // Due to some interesting requirements on compile ordering in TS,
            // this needs to be in the same file as OutputTarget now.
            var Mock = /** @class */ (function (_super) {
                __extends(Mock, _super);
                function Mock(text, caretPos) {
                    var _this = _super.call(this) || this;
                    _this.text = text ? text : "";
                    var defaultLength = _this.text._kmwLength();
                    // Ensures that `caretPos == 0` is handled correctly.
                    _this.caretIndex = typeof caretPos == "number" ? caretPos : defaultLength;
                    return _this;
                }
                // Clones the state of an existing EditableElement, creating a Mock version of its state.
                Mock.from = function (outputTarget) {
                    var clone;
                    if (outputTarget instanceof Mock) {
                        // Avoids the need to run expensive kmwstring.ts / `_kmwLength()`
                        // calculations when deep-copying Mock instances.
                        var priorMock = outputTarget;
                        clone = new Mock(priorMock.text, priorMock.caretIndex);
                    }
                    else {
                        // If we're 'cloning' a different OutputTarget type, we don't have a
                        // guaranteed way to more efficiently get these values; these are the
                        // best methods specified by the abstraction.
                        var preText = outputTarget.getTextBeforeCaret();
                        var caretIndex = preText._kmwLength();
                        // We choose to ignore (rather, pre-emptively remove) any actively-selected text,
                        // as since it's always removed instantly during any text mutation operations.
                        clone = new Mock(preText + outputTarget.getTextAfterCaret(), caretIndex);
                    }
                    // Also duplicate deadkey state!  (Needed for fat-finger ops.)
                    clone.setDeadkeys(outputTarget.deadkeys());
                    return clone;
                };
                Mock.prototype.clearSelection = function () {
                    return;
                };
                Mock.prototype.invalidateSelection = function () {
                    return;
                };
                Mock.prototype.hasSelection = function () {
                    return true;
                };
                Mock.prototype.getDeadkeyCaret = function () {
                    return this.caretIndex;
                };
                Mock.prototype.setDeadkeyCaret = function (index) {
                    if (index < 0 || index > this.text._kmwLength()) {
                        throw new Error("Provided caret index is out of range.");
                    }
                    this.caretIndex = index;
                };
                Mock.prototype.getTextBeforeCaret = function () {
                    return this.text.kmwSubstr(0, this.caretIndex);
                };
                Mock.prototype.getTextAfterCaret = function () {
                    return this.text.kmwSubstr(this.caretIndex);
                };
                Mock.prototype.getText = function () {
                    return this.text;
                };
                Mock.prototype.deleteCharsBeforeCaret = function (dn) {
                    if (dn >= 0) {
                        if (dn > this.caretIndex) {
                            dn = this.caretIndex;
                        }
                        this.text = this.text.kmwSubstr(0, this.caretIndex - dn) + this.getTextAfterCaret();
                        this.caretIndex -= dn;
                    }
                };
                Mock.prototype.insertTextBeforeCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s + this.getTextAfterCaret();
                    this.caretIndex += s.kmwLength();
                };
                Mock.prototype.handleNewlineAtCaret = function () {
                    this.insertTextBeforeCaret('\n');
                };
                Mock.prototype.setTextAfterCaret = function (s) {
                    this.text = this.getTextBeforeCaret() + s;
                };
                Mock.prototype.doInputEvent = function () {
                    // Mock isn't backed by an element, so it won't have any event listeners.
                };
                return Mock;
            }(OutputTarget));
            text_1.Mock = Mock;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="outputTarget.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * This class is defined within its own file so that it can be loaded by code outside of KMW without
             * having to actually load the entirety of KMW.
             */
            var KeyEvent = /** @class */ (function () {
                function KeyEvent() {
                    /**
                     * `true` if this event was produced by sources other than a DOM-based KeyboardEvent.
                     */
                    this.isSynthetic = true;
                }
                return KeyEvent;
            }());
            text.KeyEvent = KeyEvent;
            ;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * Represents the commands and state changes that result from a matched keyboard rule.
             */
            var RuleBehavior = /** @class */ (function () {
                function RuleBehavior() {
                    /**
                     * The before-and-after Transform from matching a keyboard rule.  May be `null`
                     * if no keyboard rules were matched for the keystroke.
                     */
                    this.transcription = null;
                    /**
                     * A set of changed store values triggered by the matched keyboard rule.
                     */
                    this.setStore = {};
                    /**
                     * A set of variable stores with save requests triggered by the matched keyboard rule
                     */
                    this.saveStore = {};
                    /**
                     * A set of variable stores with possible changes to be applied during finalization.
                     */
                    this.variableStores = {};
                    /**
                     * Denotes a non-output default behavior; this should be evaluated later, against the true keystroke.
                     */
                    this.triggersDefaultCommand = false;
                }
                RuleBehavior.prototype.finalize = function (processor, outputTarget) {
                    if (!this.transcription) {
                        throw "Cannot finalize a RuleBehavior with no transcription.";
                    }
                    if (processor.beepHandler && this.beep) {
                        processor.beepHandler(outputTarget);
                    }
                    for (var storeID in this.setStore) {
                        var sysStore = processor.keyboardInterface.systemStores[storeID];
                        if (sysStore) {
                            try {
                                sysStore.set(this.setStore[storeID]);
                            }
                            catch (error) {
                                if (processor.errorLogger) {
                                    processor.errorLogger("Rule attempted to perform illegal operation - 'platform' may not be changed.");
                                }
                            }
                        }
                        else if (processor.warningLogger) {
                            processor.warningLogger("Unknown store affected by keyboard rule: " + storeID);
                        }
                    }
                    processor.keyboardInterface.applyVariableStores(this.variableStores);
                    if (processor.keyboardInterface.variableStoreSerializer) {
                        for (var storeID in this.saveStore) {
                            processor.keyboardInterface.variableStoreSerializer.saveStore(processor.activeKeyboard.id, storeID, this.saveStore[storeID]);
                        }
                    }
                    if (this.triggersDefaultCommand) {
                        var keyEvent = this.transcription.keystroke;
                        text.DefaultOutput.applyCommand(keyEvent, outputTarget);
                    }
                    if (processor.warningLogger && this.warningLog) {
                        processor.warningLogger(this.warningLog);
                    }
                    else if (processor.errorLogger && this.errorLog) {
                        processor.errorLogger(this.errorLog);
                    }
                };
                /**
                 * Merges default-related behaviors from another RuleBehavior into this one.  Assumes that the current instance
                 * "came first" chronologically.  Both RuleBehaviors must be sourced from the same keystroke.
                 *
                 * Intended use:  merging rule-based behavior with default key behavior during scenarios like those described
                 * at https://github.com/keymanapp/keyman/pull/4350#issuecomment-768753852.
                 *
                 * This function does not attempt a "complete" merge for two fully-constructed RuleBehaviors!  Things
                 * WILL break for unintended uses.
                 * @param other
                 */
                RuleBehavior.prototype.mergeInDefaults = function (other) {
                    var keystroke = this.transcription.keystroke;
                    var keyFromOther = other.transcription.keystroke;
                    if (keystroke.Lcode != keyFromOther.Lcode || keystroke.Lmodifiers != keyFromOther.Lmodifiers) {
                        throw "RuleBehavior default-merge not supported unless keystrokes are identical!";
                    }
                    this.triggersDefaultCommand = this.triggersDefaultCommand || other.triggersDefaultCommand;
                    var mergingMock = text.Mock.from(this.transcription.preInput);
                    mergingMock.apply(this.transcription.transform);
                    mergingMock.apply(other.transcription.transform);
                    this.transcription = mergingMock.buildTranscriptionFrom(this.transcription.preInput, keystroke, this.transcription.alternates);
                };
                return RuleBehavior;
            }());
            text.RuleBehavior = RuleBehavior;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Establishes key-code definitions.
/// <reference path="codes.ts" />
// Defines our generalized "KeyEvent" class.
/// <reference path="keyEvent.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var EmulationKeystrokes;
            (function (EmulationKeystrokes) {
                EmulationKeystrokes["Enter"] = "\n";
                EmulationKeystrokes["Backspace"] = "\b";
            })(EmulationKeystrokes = text.EmulationKeystrokes || (text.EmulationKeystrokes = {}));
            /**
             * Defines a collection of static library functions that define KeymanWeb's default (implied) keyboard rule behaviors.
             */
            var DefaultOutput = /** @class */ (function () {
                function DefaultOutput() {
                }
                DefaultOutput.codeForEvent = function (Lkc) {
                    return text.Codes.keyCodes[Lkc.kName] || Lkc.Lcode;
                    ;
                };
                /**
                 * Serves as a default keycode lookup table.  This may be referenced safely by mnemonic handling without fear of side-effects.
                 * Also used by Processor.defaultRuleBehavior to generate output after filtering for special cases.
                 */
                DefaultOutput.forAny = function (Lkc, isMnemonic, ruleBehavior) {
                    var char = '';
                    // A pretty simple table of lookups, corresponding VERY closely to the original defaultKeyOutput.
                    if ((char = DefaultOutput.forSpecialEmulation(Lkc, ruleBehavior)) != null) {
                        return char;
                    }
                    else if (!isMnemonic && ((char = DefaultOutput.forNumpadKeys(Lkc, ruleBehavior)) != null)) {
                        return char;
                    }
                    else if ((char = DefaultOutput.forUnicodeKeynames(Lkc, ruleBehavior)) != null) {
                        return char;
                    }
                    else if ((char = DefaultOutput.forBaseKeys(Lkc, ruleBehavior)) != null) {
                        return char;
                    }
                    else {
                        // // For headless and embeddded, we may well allow '\t'.  It's DOM mode that has other uses.
                        // // Not originally defined for text output within defaultKeyOutput.
                        // // We can't enable it yet, as it'll cause hardware keystrokes in the DOM to output '\t' rather
                        // // than rely on the browser-default handling.
                        var code = DefaultOutput.codeForEvent(Lkc);
                        switch (code) {
                            //   case Codes.keyCodes['K_TAB']:
                            //   case Codes.keyCodes['K_TABBACK']:
                            //   case Codes.keyCodes['K_TABFWD']:
                            //     return '\t';
                            default:
                                return null;
                        }
                    }
                };
                /**
                 * isCommand - returns a boolean indicating if a non-text event should be triggered by the keystroke.
                 */
                DefaultOutput.isCommand = function (Lkc) {
                    var code = DefaultOutput.codeForEvent(Lkc);
                    switch (code) {
                        // Should we ever implement them:
                        // case Codes.keyCodes['K_LEFT']:  // would not output text, but would alter the caret's position in the context.
                        // case Codes.keyCodes['K_RIGHT']:
                        //   return true;
                        default:
                            return false;
                    }
                };
                /**
                 * Used when a RuleBehavior represents a non-text "command" within the Engine.  This will generally
                 * trigger events that require context reset - often by moving the caret or by moving what OutputTarget
                 * the caret is in.  However, we let those events perform the actual context reset.
                 *
                 * Note:  is extended by DOM-aware KeymanWeb code.
                 */
                DefaultOutput.applyCommand = function (Lkc, outputTarget) {
                    // Notes for potential default-handling extensions:
                    //
                    // switch(code) {
                    // // Problem:  clusters, and doing them right.
                    // // The commented-out code below should be a decent starting point, but clusters make it complex.
                    // // Mostly based on pre-12.0 code, but the general idea should be relatively clear.
                    //
                    // case Codes.keyCodes['K_LEFT']:
                    //   if(touchAlias) {
                    //     var caretPos = keymanweb.getTextCaret(Lelem);
                    //     keymanweb.setTextCaret(Lelem, caretPos - 1 >= 0 ? caretPos - 1 : 0);
                    //   }
                    //   break;
                    // case Codes.keyCodes['K_RIGHT']:
                    //   if(touchAlias) {
                    //     var caretPos = keymanweb.getTextCaret(Lelem);
                    //     keymanweb.setTextCaret(Lelem, caretPos + 1);
                    //   }
                    //   if(code == VisualKeyboard.keyCodes['K_RIGHT']) {
                    //     break;
                    //   }
                    // }
                    //
                    // Note that these would be useful even outside of a DOM context.
                };
                /**
                 * Codes matched here generally have default implementations when in a browser but require emulation
                 * for 'synthetic' `OutputTarget`s like `Mock`s, which have no default text handling.
                 */
                DefaultOutput.forSpecialEmulation = function (Lkc, ruleBehavior) {
                    var code = DefaultOutput.codeForEvent(Lkc);
                    switch (code) {
                        case text.Codes.keyCodes['K_BKSP']:
                            return EmulationKeystrokes.Backspace;
                        case text.Codes.keyCodes['K_ENTER']:
                            return EmulationKeystrokes.Enter;
                        // case Codes.keyCodes['K_DEL']:
                        //   return '\u007f'; // 127, ASCII / Unicode control code for DEL.
                        default:
                            return null;
                    }
                };
                // Should not be used for mnenomic keyboards.  forAny()'s use of this method checks first.
                DefaultOutput.forNumpadKeys = function (Lkc, ruleBehavior) {
                    // Translate numpad keystrokes into their non-numpad equivalents
                    if (Lkc.Lcode >= text.Codes.keyCodes["K_NP0"] && Lkc.Lcode <= text.Codes.keyCodes["K_NPSLASH"]) {
                        // Number pad, numlock on
                        if (Lkc.Lcode < 106) {
                            var Lch = Lkc.Lcode - 48;
                        }
                        else {
                            Lch = Lkc.Lcode - 64;
                        }
                        var ch = String._kmwFromCharCode(Lch); //I3319
                        return ch;
                    }
                    else {
                        return null;
                    }
                };
                // Test for fall back to U_xxxxxx key id
                // For this first test, we ignore the keyCode and use the keyName
                DefaultOutput.forUnicodeKeynames = function (Lkc, ruleBehavior) {
                    var keyName = Lkc.kName;
                    // Test for fall back to U_xxxxxx key id
                    // For this first test, we ignore the keyCode and use the keyName
                    if (!keyName || keyName.substr(0, 2) != 'U_') {
                        return null;
                    }
                    var result = '';
                    var codePoints = keyName.substr(2).split('_');
                    for (var _i = 0, codePoints_1 = codePoints; _i < codePoints_1.length; _i++) {
                        var codePoint = codePoints_1[_i];
                        var codePointValue = parseInt(codePoint, 16);
                        if (((0x0 <= codePointValue) && (codePointValue <= 0x1F)) || ((0x80 <= codePointValue) && (codePointValue <= 0x9F))) {
                            // Code points [U_0000 - U_001F] and [U_0080 - U_009F] refer to Unicode C0 and C1 control codes.
                            // Check the codePoint number and do not allow output of these codes via U_xxxxxx shortcuts.
                            if (ruleBehavior) {
                                ruleBehavior.errorLog = ("Suppressing Unicode control code in " + keyName);
                            }
                            // We'll attempt to add valid chars
                            continue;
                        }
                        else {
                            // String.fromCharCode() is inadequate to handle the entire range of Unicode
                            // Someday after upgrading to ES2015, can use String.fromCodePoint()
                            result += String.kmwFromCharCode(codePointValue);
                        }
                    }
                    return result ? result : null;
                };
                // Test for otherwise unimplemented keys on the the base default & shift layers.
                // Those keys must be blocked by keyboard rules if intentionally unimplemented; otherwise, this function will trigger.
                DefaultOutput.forBaseKeys = function (Lkc, ruleBehavior) {
                    var n = Lkc.Lcode;
                    var keyShiftState = Lkc.Lmodifiers;
                    // check if exact match to SHIFT's code.  Only the 'default' and 'shift' layers should have default key outputs.
                    // TODO:  Extend to allow AltGr as well - better mnemonic support.
                    if (keyShiftState == text.Codes.modifierCodes['SHIFT']) {
                        keyShiftState = 1;
                    }
                    else if (keyShiftState != 0) {
                        if (ruleBehavior) {
                            ruleBehavior.warningLog = "KMW only defines default key output for the 'default' and 'shift' layers!";
                        }
                        return null;
                    }
                    // Now that keyShiftState is either 0 or 1, we can use the following structure to determine the default output.
                    try {
                        if (n == text.Codes.keyCodes['K_SPACE']) {
                            return ' ';
                        }
                        else if (n >= text.Codes.keyCodes['K_0'] && n <= text.Codes.keyCodes['K_9']) { // The number keys.
                            return text.Codes.codesUS[keyShiftState][0][n - text.Codes.keyCodes['K_0']];
                        }
                        else if (n >= text.Codes.keyCodes['K_A'] && n <= text.Codes.keyCodes['K_Z']) { // The base letter keys
                            return String.fromCharCode(n + (keyShiftState ? 0 : 32)); // 32 is the offset from uppercase to lowercase.
                        }
                        else if (n >= text.Codes.keyCodes['K_COLON'] && n <= text.Codes.keyCodes['K_BKQUOTE']) {
                            return text.Codes.codesUS[keyShiftState][1][n - text.Codes.keyCodes['K_COLON']];
                        }
                        else if (n >= text.Codes.keyCodes['K_LBRKT'] && n <= text.Codes.keyCodes['K_QUOTE']) {
                            return text.Codes.codesUS[keyShiftState][2][n - text.Codes.keyCodes['K_LBRKT']];
                        }
                    }
                    catch (e) {
                        if (ruleBehavior) {
                            ruleBehavior.errorLog = "Error detected with default mapping for key:  code = " + n + ", shift state = " + (keyShiftState == 1 ? 'shift' : 'default');
                        }
                    }
                    return null;
                };
                return DefaultOutput;
            }());
            text.DefaultOutput = DefaultOutput;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 10.0
   Copyright 2017 SIL International
***/
// Relies on web-utils for version and deep-copy functionality.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            var Codes = com.keyman.text.Codes;
            // This class manages default layout construction for consumption by OSKs without a specified layout.
            var Layouts = /** @class */ (function () {
                function Layouts() {
                }
                /**
                * Build a default layout for keyboards with no explicit layout
                *
                * @param   {Object}  PVK         raw specifications
                * @param   {Keyboard} keyboard   keyboard object (as loaded)
                * @param   {string} formFactor   (really utils.FormFactor)
                * @return  {LayoutFormFactor}
                */
                Layouts.buildDefaultLayout = function (PVK, keyboard, formFactor) {
                    // Build a layout using the default for the device
                    var layoutType = formFactor;
                    if (typeof Layouts.dfltLayout[layoutType] != 'object') {
                        layoutType = 'desktop';
                    }
                    var kbdBitmask = Codes.modifierBitmasks['NON_CHIRAL'];
                    // An unfortunate dependency there.  Should probably also set a version within web-core for use.
                    var kbdDevVersion = keyman.utils.Version.CURRENT;
                    if (keyboard) {
                        kbdBitmask = keyboard.modifierBitmask;
                        kbdDevVersion = keyboard.compilerVersion;
                    }
                    if (!PVK) {
                        PVK = this.DEFAULT_RAW_SPEC;
                    }
                    // Clone the default layout object for this device
                    var layout = keyman.utils.deepCopy(Layouts.dfltLayout[layoutType]);
                    var n, layers = layout['layer'], keyLabels = PVK['KLS'], key102 = PVK['K102'];
                    var i, j, k, m, row, rows, key, keys;
                    var chiral = (kbdBitmask & Codes.modifierBitmasks.IS_CHIRAL) != 0;
                    var kmw10Plus = !(typeof keyLabels == 'undefined' || !keyLabels);
                    if (!kmw10Plus) {
                        // Save the processed key label information to the keyboard's general data.
                        // Makes things more efficient elsewhere and for reloading after keyboard swaps.
                        keyLabels = PVK['KLS'] = Layouts.processLegacyDefinitions(PVK['BK']);
                    }
                    // Identify key labels (e.g. *Shift*) that require the special OSK font
                    var specialLabel = /\*\w+\*/;
                    // *** Step 1:  instantiate the layer objects. ***
                    // Get the list of valid layers, enforcing that the 'default' layer must be the first one processed.
                    var validIdList = Object.getOwnPropertyNames(keyLabels), invalidIdList = [];
                    validIdList.splice(validIdList.indexOf('default'), 1);
                    validIdList = ['default'].concat(validIdList);
                    // Automatic AltGr emulation if the 'leftctrl-leftalt' layer is otherwise undefined.
                    if (keyboard && keyboard.emulatesAltGr) {
                        // We insert only the layers that need to be emulated.
                        if ((validIdList.indexOf('leftctrl-leftalt') == -1) && validIdList.indexOf('rightalt') != -1) {
                            validIdList.push('leftctrl-leftalt');
                            keyLabels['leftctrl-leftalt'] = keyLabels['rightalt'];
                        }
                        if ((validIdList.indexOf('leftctrl-leftalt-shift') == -1) && validIdList.indexOf('rightalt-shift') != -1) {
                            validIdList.push('leftctrl-leftalt-shift');
                            keyLabels['leftctrl-leftalt-shift'] = keyLabels['rightalt-shift'];
                        }
                    }
                    // If there is no predefined layout, even touch layouts will follow the desktop's
                    // setting for the displayUnderlying flag.  As the desktop layout uses a different
                    // format for its layout spec, that's found at the field referenced below.
                    layout["displayUnderlying"] = keyboard ? !!keyboard.scriptObject['KDU'] : false;
                    // For desktop devices, we must create all layers, even if invalid.
                    if (formFactor == 'desktop') {
                        invalidIdList = Layouts.generateLayerIds(chiral);
                        // Filter out all ids considered valid.  (We also don't want duplicates in the following list...)
                        for (n = 0; n < invalidIdList.length; n++) {
                            if (validIdList.indexOf(invalidIdList[n]) != -1) {
                                invalidIdList.splice(n--, 1);
                            }
                        }
                    }
                    // This ensures all 'valid' layers are at the front of the layer array and managed by the main loop below.
                    // 'invalid' layers aren't handled by the loop and thus remain blank after it.
                    var idList = validIdList.concat(invalidIdList);
                    if (kmw10Plus && formFactor != 'desktop') { // KLS exists, so we know the exact layer set.
                        // Find the SHIFT key...
                        var shiftKey = null;
                        rows = layers[0]['row'];
                        for (var r = 0; r < rows.length; r++) {
                            keys = rows[r]['key'];
                            for (var c = 0; c < keys.length; c++) {
                                key = keys[c];
                                if (key['id'] == 'K_SHIFT') {
                                    shiftKey = key;
                                }
                            }
                        }
                        if (shiftKey) {
                            // Erase the legacy shifted subkey array.
                            shiftKey['sk'] = [];
                            for (var layerID in keyLabels) {
                                if (layerID == 'default' || layerID == 'shift') {
                                    // These two are accessible from the layer without subkeys.
                                    continue;
                                }
                                // Create a new subkey for the specified layer so that it will be accessible via OSK.
                                var specialChar = Layouts.modifierSpecials[layerID];
                                var subkey = {
                                    id: "K_" + specialChar,
                                    text: specialChar,
                                    sp: "1",
                                    nextlayer: layerID
                                };
                                shiftKey['sk'].push(subkey);
                            }
                        }
                        else {
                            // Seriously, this should never happen.  It's here for the debugging log only.
                            console.warn("Error in default layout - cannot find default Shift key!");
                        }
                    }
                    for (n = 0; n < idList.length; n++) {
                        // Populate non-default (shifted) keygroups
                        if (n > 0) {
                            layers[n] = keyman.utils.deepCopy(layers[0]);
                        }
                        layers[n]['id'] = idList[n];
                        layers[n]['nextlayer'] = idList[n]; // This would only be different for a dynamic keyboard
                        // Extraced into a helper method to improve readability.
                        Layouts.formatDefaultLayer(layers[n], chiral, formFactor, !!key102);
                    }
                    // *** Step 2: Layer objects now exist; time to fill them with the appropriate key labels and key styles ***
                    for (n = 0; n < layers.length; n++) {
                        var layer = layers[n], kx, shiftKey = null, nextKey = null, allText = '';
                        var capsKey = null, numKey = null, scrollKey = null; // null if not in the OSK layout.
                        var layerSpec = keyLabels[layer['id']];
                        var isShift = layer['id'] == 'shift' ? 1 : 0;
                        var isDefault = layer['id'] == 'default' || isShift ? 1 : 0;
                        rows = layer['row'];
                        for (i = 0; i < rows.length; i++) {
                            keys = rows[i]['key'];
                            for (j = 0; j < keys.length; j++) {
                                key = keys[j];
                                kx = Layouts.dfltCodes.indexOf(key['id']);
                                // Only create keys for defined layers.  ('default' and 'shift' are always defined.)
                                if (layerSpec || isDefault) {
                                    // Get keycap text from visual keyboard array, if defined in keyboard
                                    if (layerSpec) {
                                        if (kx >= 0 && kx < layerSpec.length)
                                            key['text'] = layerSpec[kx];
                                    }
                                    // Legacy (pre 12.0) behavior:  fall back to US English keycap text as default for the base two layers
                                    // if a key cap is not otherwise defined. (Any intentional 'ghost' keys must be explicitly defined.)
                                    if (isDefault && kbdDevVersion.precedes(keyman.utils.Version.NO_DEFAULT_KEYCAPS)) {
                                        if (key['id'] != 'K_SPACE' && kx + 65 * isShift < Layouts.dfltText.length && key['text'] !== null) {
                                            key['text'] = key['text'] || Layouts.dfltText[kx + 65 * isShift];
                                        }
                                    }
                                }
                                // Leave any unmarked key caps as null strings
                                if (key['text'] !== null) {
                                    key['text'] = key['text'] || '';
                                }
                                // Detect important tracking keys.
                                switch (key['id']) {
                                    case "K_SHIFT":
                                        shiftKey = key;
                                        break;
                                    case "K_TAB":
                                        nextKey = key;
                                        break;
                                    case "K_CAPS":
                                        capsKey = key;
                                        break;
                                    case "K_NUMLOCK":
                                        numKey = key;
                                        break;
                                    case "K_SCROLL":
                                        scrollKey = key;
                                        break;
                                }
                                // Remove pop-up shift keys referencing invalid layers (Build 349)
                                if (key['sk'] != null) {
                                    for (k = 0; k < key['sk'].length; k++) {
                                        if (validIdList.indexOf(key['sk'][k]['nextlayer']) == -1) {
                                            key['sk'].splice(k--, 1);
                                        }
                                    }
                                    if (key['sk'].length == 0) {
                                        key['sk'] = null;
                                    }
                                }
                            }
                        }
                        // We're done with the layer keys initialization pass.  Time to do post-analysis layer-level init where necessary.
                        layer.shiftKey = shiftKey;
                        layer.capsKey = capsKey;
                        layer.numKey = numKey;
                        layer.scrollKey = scrollKey;
                        // Set modifier key appearance and behaviour for non-desktop devices using the default layout
                        if (formFactor != 'desktop') {
                            if (n > 0 && shiftKey != null) {
                                shiftKey['sp'] = Layouts.buttonClasses['SHIFT-ON'];
                                shiftKey['sk'] = null;
                                shiftKey['text'] = Layouts.modifierSpecials[layers[n].id] ? Layouts.modifierSpecials[layers[n].id] : "*Shift*";
                            }
                        }
                    }
                    return layout;
                };
                /**
             * Function     getLayerId
             * Scope        Private
             * @param       {number}      m     shift modifier code
             * @return      {string}            layer string from shift modifier code (desktop keyboards)
             * Description  Get name of layer from code, where the modifer order is determined by ascending bit-flag value.
             */
                Layouts.getLayerId = function (m) {
                    var modifierCodes = Codes.modifierCodes;
                    var s = '';
                    if (m == 0) {
                        return 'default';
                    }
                    else {
                        if (m & modifierCodes['LCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftctrl';
                        }
                        if (m & modifierCodes['RCTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightctrl';
                        }
                        if (m & modifierCodes['LALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'leftalt';
                        }
                        if (m & modifierCodes['RALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'rightalt';
                        }
                        if (m & modifierCodes['SHIFT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'shift';
                        }
                        if (m & modifierCodes['CTRL']) {
                            s = (s.length > 0 ? s + '-' : '') + 'ctrl';
                        }
                        if (m & modifierCodes['ALT']) {
                            s = (s.length > 0 ? s + '-' : '') + 'alt';
                        }
                        return s;
                    }
                };
                /**
                 * Generates a list of potential layer ids for the specified chirality mode.
                 *
                 * @param   {boolean}   chiral    // Does the keyboard use chiral modifiers or not?
                 */
                Layouts.generateLayerIds = function (chiral) {
                    var layerCnt, offset;
                    if (chiral) {
                        layerCnt = 32;
                        offset = 0x01;
                    }
                    else {
                        layerCnt = 8;
                        offset = 0x10;
                    }
                    var layerIds = [];
                    for (var i = 0; i < layerCnt; i++) {
                        layerIds.push(Layouts.getLayerId(i * offset));
                    }
                    return layerIds;
                };
                /**
                 * Sets a formatting property for the modifier keys when constructing a default layout for a keyboard.
                 *
                 * @param   {Object}    layer   // One layer specification
                 * @param   {boolean}   chiral  // Whether or not the keyboard uses chiral modifier information.
                 * @param   {string}    formFactor  // The form factor of the device the layout is being constructed for.
                 * @param   {boolean}   key102      // Whether or not the extended key 102 should be hidden.
                 */
                Layouts.formatDefaultLayer = function (layer, chiral, formFactor, key102) {
                    var layerId = layer['id'];
                    var buttonClasses = Layouts.buttonClasses;
                    // Correct appearance of state-dependent modifier keys according to group
                    for (var i = 0; i < layer['row'].length; i++) {
                        var row = layer['row'][i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            switch (key['id']) {
                                case 'K_SHIFT':
                                case 'K_LSHIFT':
                                case 'K_RSHIFT':
                                    if (layerId.indexOf('shift') != -1) {
                                        key['sp'] = buttonClasses['SHIFT-ON'];
                                    }
                                    if (formFactor != 'desktop') {
                                        if (layerId != 'default') {
                                            key['nextlayer'] = 'default';
                                        }
                                        else {
                                            key['nextlayer'] = 'shift';
                                        }
                                    }
                                    break;
                                case 'K_LCTRL':
                                case 'K_LCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('leftctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RCTRL':
                                case 'K_RCONTROL':
                                    if (chiral) {
                                        if (layerId.indexOf('rightctrl') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_CONTROL':
                                    if (layerId.indexOf('ctrl') != -1) {
                                        if (!chiral || (layerId.indexOf('leftctrl') != -1 && layerId.indexOf('rightctrl') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_LALT':
                                    if (chiral) {
                                        if (layerId.indexOf('leftalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_RALT':
                                    if (chiral) {
                                        if (layerId.indexOf('rightalt') != -1) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                        break;
                                    }
                                case 'K_ALT':
                                    if (layerId.indexOf('alt') != -1) {
                                        if (!chiral || (layerId.indexOf('leftalt') != -1 && layerId.indexOf('rightalt') != -1)) {
                                            key['sp'] = buttonClasses['SHIFT-ON'];
                                        }
                                    }
                                    break;
                                case 'K_oE2':
                                    if (typeof key102 == 'undefined' || !key102) {
                                        if (formFactor == 'desktop') {
                                            keys.splice(j--, 1);
                                            keys[0]['width'] = '200';
                                        }
                                        else {
                                            keys[j]['sp'] = buttonClasses['HIDDEN'];
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                };
                /**
                 * Converts the legacy BK property from pre 10.0 into the KLS keyboard layer spec format,
                 * sparsifying it as possible to pre-emptively check invalid layers.
                 *
                 * @param   {Array}   BK      keyboard object (as loaded)
                 * @return  {Object}
                 */
                Layouts.processLegacyDefinitions = function (BK) {
                    //['default','shift','ctrl','shiftctrl','alt','shiftalt','ctrlalt','shiftctrlalt'];
                    var idList = Layouts.generateLayerIds(false); // Non-chiral.
                    var KLS = {};
                    // The old default:  eight auto-managed layers...
                    for (var n = 0; n < idList.length; n++) {
                        var id = idList[n], arr = [], valid = false;
                        // ... with keycode mappings in blocks of 65.
                        for (var k = 0; k < 65; k++) {
                            var index = k + 65 * n;
                            arr.push(BK[index]);
                            // The entry for K_SPACE's keycode tends to hold ' ' instead of '', which causes
                            // the whole layer to be treated as 'valid' if not included in the conditional.
                            if (index < BK.length && BK[index] != '' && k != Layouts.dfltCodes.indexOf('K_SPACE')) {
                                valid = true;
                            }
                        }
                        if (valid) {
                            KLS[id] = arr;
                        }
                    }
                    // There must always be at least a plain 'default' layer.  Array(65).fill('') would be preferable but isn't supported on IE,
                    // but buildDefaultLayer will set the defaults for these layers if no entry exists for them in the array due to length.
                    if (typeof KLS['default'] == 'undefined' || !KLS['default']) {
                        KLS['default'] = [''];
                    }
                    // There must always be at least a plain 'shift' layer.
                    if (typeof KLS['shift'] == 'undefined' || !KLS['shift']) {
                        KLS['shift'] = [''];
                    }
                    return KLS;
                };
                Layouts.dfltCodes = [
                    "K_BKQUOTE", "K_1", "K_2", "K_3", "K_4", "K_5", "K_6", "K_7", "K_8", "K_9", "K_0",
                    "K_HYPHEN", "K_EQUAL", "K_*", "K_*", "K_*", "K_Q", "K_W", "K_E", "K_R", "K_T",
                    "K_Y", "K_U", "K_I", "K_O", "K_P", "K_LBRKT", "K_RBRKT", "K_BKSLASH", "K_*",
                    "K_*", "K_*", "K_A", "K_S", "K_D", "K_F", "K_G", "K_H", "K_J", "K_K", "K_L",
                    "K_COLON", "K_QUOTE", "K_*", "K_*", "K_*", "K_*", "K_*", "K_oE2",
                    "K_Z", "K_X", "K_C", "K_V", "K_B", "K_N", "K_M", "K_COMMA", "K_PERIOD",
                    "K_SLASH", "K_*", "K_*", "K_*", "K_*", "K_*", "K_SPACE"
                ];
                Layouts.dfltText = '`1234567890-=\xA7~~qwertyuiop[]\\~~~asdfghjkl;\'~~~~~?zxcvbnm,./~~~~~ '
                    + '~!@#$%^&*()_+\xA7~~QWERTYUIOP{}\\~~~ASDFGHJKL:"~~~~~?ZXCVBNM<>?~~~~~ ';
                Layouts.DEFAULT_RAW_SPEC = { 'F': 'Tahoma', 'BK': Layouts.dfltText };
                // Cross-reference with the ids in osk.setButtonClass.
                Layouts.buttonClasses = {
                    'DEFAULT': '0',
                    'SHIFT': '1',
                    'SHIFT-ON': '2',
                    'SPECIAL': '3',
                    'SPECIAL-ON': '4',
                    'DEADKEY': '8',
                    'BLANK': '9',
                    'HIDDEN': '10'
                };
                Layouts.modifierSpecials = {
                    'leftalt': '*LAlt*',
                    'rightalt': '*RAlt*',
                    'alt': '*Alt*',
                    'leftctrl': '*LCtrl*',
                    'rightctrl': '*RCtrl*',
                    'ctrl': '*Ctrl*',
                    'ctrl-alt': '*AltGr*',
                    'leftctrl-leftalt': '*LAltCtrl*',
                    'rightctrl-rightalt': '*RAltCtrl*',
                    'leftctrl-leftalt-shift': '*LAltCtrlShift*',
                    'rightctrl-rightalt-shift': '*RAltCtrlShift*',
                    'shift': '*Shift*',
                    'shift-alt': '*AltShift*',
                    'shift-ctrl': '*CtrlShift*',
                    'shift-ctrl-alt': '*AltCtrlShift*',
                    'leftalt-shift': '*LAltShift*',
                    'rightalt-shift': '*RAltShift*',
                    'leftctrl-shift': '*LCtrlShift*',
                    'rightctrl-shift': '*RCtrlShift*'
                };
                // Defines the default visual layout for a keyboard.
                Layouts.dfltLayout = {
                    "desktop": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_BKQUOTE" },
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_TAB", "text": "*Tab*", "sp": "1", "width": "130" },
                                            { "id": "K_Q" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "id": "K_BKSLASH" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_CAPS", "text": "*Caps*", "sp": "1", "width": "165" },
                                            { "id": "K_A" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "165" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            { "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "130" },
                                            { "id": "K_oE2" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_RSHIFT", "text": "*Shift*", "sp": "1", "width": "130" }
                                        ]
                                    },
                                    {
                                        "id": "5",
                                        "key": [
                                            { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" },
                                            { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_SPACE", "text": "", "width": "770" },
                                            { "id": "K_RALT", "text": "*Alt*", "sp": "1", "width": "160" },
                                            { "id": "K_RCONTROL", "text": "*Ctrl*", "sp": "1", "width": "170" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "tablet": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "sp": "1", "width": "150" },
                                            { "id": "K_SPACE", "text": "", "width": "570" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "sp": "1", "width": "150" },
                                            { "id": "K_ENTER", "text": "*Enter*", "sp": "1", "width": "200" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    "phone": {
                        "font": "Tahoma,Helvetica",
                        "layer": [
                            {
                                "id": "default",
                                "row": [
                                    {
                                        "id": "0",
                                        "key": [
                                            { "id": "K_1" },
                                            { "id": "K_2" },
                                            { "id": "K_3" },
                                            { "id": "K_4" },
                                            { "id": "K_5" },
                                            { "id": "K_6" },
                                            { "id": "K_7" },
                                            { "id": "K_8" },
                                            { "id": "K_9" },
                                            { "id": "K_0" },
                                            { "id": "K_HYPHEN" },
                                            { "id": "K_EQUAL" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "1",
                                        "key": [
                                            { "id": "K_Q", "pad": "25" },
                                            { "id": "K_W" },
                                            { "id": "K_E" },
                                            { "id": "K_R" },
                                            { "id": "K_T" },
                                            { "id": "K_Y" },
                                            { "id": "K_U" },
                                            { "id": "K_I" },
                                            { "id": "K_O" },
                                            { "id": "K_P" },
                                            { "id": "K_LBRKT" },
                                            { "id": "K_RBRKT" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "2",
                                        "key": [
                                            { "id": "K_A", "pad": "50" },
                                            { "id": "K_S" },
                                            { "id": "K_D" },
                                            { "id": "K_F" },
                                            { "id": "K_G" },
                                            { "id": "K_H" },
                                            { "id": "K_J" },
                                            { "id": "K_K" },
                                            { "id": "K_L" },
                                            { "id": "K_COLON" },
                                            { "id": "K_QUOTE" },
                                            { "id": "K_BKSLASH", "width": "90" }
                                        ]
                                    },
                                    {
                                        "id": "3",
                                        "key": [
                                            { "id": "K_oE2", "width": "90" },
                                            { "id": "K_Z" },
                                            { "id": "K_X" },
                                            { "id": "K_C" },
                                            { "id": "K_V" },
                                            { "id": "K_B" },
                                            { "id": "K_N" },
                                            { "id": "K_M" },
                                            { "id": "K_COMMA" },
                                            { "id": "K_PERIOD" },
                                            { "id": "K_SLASH" },
                                            { "id": "K_BKQUOTE" },
                                            { "sp": "10", "width": "1" }
                                        ]
                                    },
                                    {
                                        "id": "4",
                                        "key": [
                                            {
                                                "id": "K_SHIFT", "text": "*Shift*", "sp": "1", "width": "200", "sk": [
                                                    { "id": "K_LCONTROL", "text": "*Ctrl*", "sp": "1", "width": "50", "nextlayer": "ctrl" },
                                                    { "id": "K_LCONTROL", "text": "*LCtrl*", "sp": "1", "width": "50", "nextlayer": "leftctrl" },
                                                    { "id": "K_RCONTROL", "text": "*RCtrl*", "sp": "1", "width": "50", "nextlayer": "rightctrl" },
                                                    { "id": "K_LALT", "text": "*Alt*", "sp": "1", "width": "50", "nextlayer": "alt" },
                                                    { "id": "K_LALT", "text": "*LAlt*", "sp": "1", "width": "50", "nextlayer": "leftalt" },
                                                    { "id": "K_RALT", "text": "*RAlt*", "sp": "1", "width": "50", "nextlayer": "rightalt" },
                                                    { "id": "K_ALTGR", "text": "*AltGr*", "sp": "1", "width": "50", "nextlayer": "ctrl-alt" }
                                                ]
                                            },
                                            { "id": "K_LOPT", "text": "*Menu*", "width": "150", "sp": "1" },
                                            { "id": "K_SPACE", "width": "570", "text": "" },
                                            { "id": "K_BKSP", "text": "*BkSp*", "width": "150", "sp": "1" },
                                            { "id": "K_ENTER", "text": "*Enter*", "width": "200", "sp": "1" }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                };
                return Layouts;
            }());
            keyboards.Layouts = Layouts;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            var ActiveKey = /** @class */ (function () {
                function ActiveKey() {
                    this.isMnemonic = false;
                }
                Object.defineProperty(ActiveKey.prototype, "baseKeyID", {
                    // Keeping things simple here, as this was added LATE in 14.0 beta.
                    // Could definitely extend in the future to instead return an object
                    // that denotes the 'nature' of the key.
                    // - isUnicode
                    // - isHardwareKey
                    // - etc.
                    // Reference for the terminology in the comments below:
                    // https://help.keyman.com/developer/current-version/guides/develop/creating-a-touch-keyboard-layout-for-amharic-the-nitty-gritty
                    /**
                     * Matches the key code as set within Keyman Developer for the layout.
                     * For example, K_R or U_0020.  Denotes either physical keys or virtual keys with custom output,
                     * with no additional metadata like layer or active modifiers.
                     *
                     * Is used to determine the keycode for input events, rule-matching, and keystroke processing.
                     */
                    get: function () {
                        if (typeof this.id === 'undefined') {
                            return undefined;
                        }
                        return this.id;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ActiveKey.prototype, "coreID", {
                    /**
                     * A unique identifier based on both the key ID & the 'desktop layer' to be used for the key.
                     *
                     * Allows diambiguation of scenarios where the same key ID is used twice within a layer, but
                     * with different innate modifiers.  (Refer to https://github.com/keymanapp/keyman/issues/4617)
                     * The 'desktop layer' may be omitted if it matches the key's display layer.
                     *
                     * Examples, given a 'default' display layer, matching keys to Keyman keyboard language:
                     *
                     * ```
                     * "K_Q"
                     * + [K_Q]
                     * "K_Q+shift"
                     * + [K_Q SHIFT]
                     * ```
                     *
                     * Useful when the active layer of an input-event is already known.
                     */
                    get: function () {
                        if (typeof this.id === 'undefined') {
                            return undefined;
                        }
                        var baseID = this.id || '';
                        if (this.displayLayer != this.layer) {
                            baseID = baseID + '+' + this.layer;
                        }
                        return baseID;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ActiveKey.prototype, "elementID", {
                    /**
                     * A keyboard-unique identifier to be used for any display elements representing this key
                     * in user interfaces and/or on-screen keyboards.
                     *
                     * Distinguishes between otherwise-identical keys on different layers of an OSK.
                     * Includes identifying information about the key's display layer.
                     *
                     * Examples, given a 'default' display layer, matching keys to Keyman keyboard language:
                     *
                     * ```
                     * "default-K_Q"
                     * + [K_Q]
                     * "default-K_Q+shift"
                     * + [K_Q SHIFT]
                     * ```
                     *
                     * Useful when only the active keyboard is known about an input event.
                     */
                    get: function () {
                        if (typeof this.id === 'undefined') {
                            return undefined;
                        }
                        return this.displayLayer + '-' + this.coreID;
                    },
                    enumerable: true,
                    configurable: true
                });
                ActiveKey.polyfill = function (key, layout, displayLayer) {
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveKey();
                    var proto = Object.getPrototypeOf(dummy);
                    for (var prop in dummy) {
                        if (!key.hasOwnProperty(prop)) {
                            var descriptor = Object.getOwnPropertyDescriptor(proto, prop);
                            if (descriptor) {
                                // It's a computed property!  Copy the descriptor onto the key's object.
                                Object.defineProperty(key, prop, descriptor);
                            }
                            else {
                                key[prop] = dummy[prop];
                            }
                        }
                    }
                    // Ensure subkeys are also properly extended.
                    if (key.sk) {
                        for (var _i = 0, _a = key.sk; _i < _a.length; _i++) {
                            var subkey = _a[_i];
                            ActiveKey.polyfill(subkey, layout, displayLayer);
                        }
                    }
                    var aKey = key;
                    aKey.displayLayer = displayLayer;
                    aKey.layer = aKey.layer || displayLayer;
                    // Compute the key's base KeyEvent properties for use in future event generation
                    aKey.constructBaseKeyEvent(layout, displayLayer);
                };
                ActiveKey.prototype.constructBaseKeyEvent = function (layout, displayLayer) {
                    // Get key name and keyboard shift state (needed only for default layouts and physical keyboard handling)
                    // Note - virtual keys should be treated case-insensitive, so we force uppercasing here.
                    var layer = this.layer || displayLayer || '';
                    var keyName = this.id ? this.id.toUpperCase() : null;
                    // Start:  mirrors _GetKeyEventProperties
                    // Override key shift state if specified for key in layout (corrected for popup keys KMEW-93)
                    var keyShiftState = keyman.text.KeyboardProcessor.getModifierState(layer);
                    // First check the virtual key, and process shift, control, alt or function keys
                    var Lkc = {
                        Lmodifiers: keyShiftState,
                        Lstates: 0,
                        Lcode: keyName ? keyman.text.Codes.keyCodes[keyName] : 0,
                        LisVirtualKey: true,
                        vkCode: 0,
                        kName: keyName,
                        kLayer: layer,
                        kbdLayer: displayLayer,
                        kNextLayer: this.nextlayer,
                        device: null,
                        isSynthetic: true
                    };
                    if (layout.keyboard) {
                        var keyboard = layout.keyboard;
                        // Include *limited* support for mnemonic keyboards (Sept 2012)
                        // If a touch layout has been defined for a mnemonic keyout, do not perform mnemonic mapping for rules on touch devices.
                        if (keyboard.isMnemonic && !(layout.isDefault && layout.formFactor != 'desktop')) {
                            if (Lkc.Lcode != keyman.text.Codes.keyCodes['K_SPACE']) { // exception required, March 2013
                                // Jan 2019 - interesting that 'K_SPACE' also affects the caps-state check...
                                Lkc.vkCode = Lkc.Lcode;
                                this.isMnemonic = true;
                            }
                        }
                        else {
                            Lkc.vkCode = Lkc.Lcode;
                        }
                        // Support version 1.0 KeymanWeb keyboards that do not define positional vs mnemonic
                        if (!keyboard.definesPositionalOrMnemonic) {
                            // Not the best pattern, but currently safe - we don't look up any properties of any of the
                            // arguments in this use case, and the object's scope is extremely limited.
                            Lkc.Lcode = keyman.KeyMapping._USKeyCodeToCharCode(this.constructKeyEvent(null, null));
                            Lkc.LisVirtualKey = false;
                        }
                    }
                    this.baseKeyEvent = Lkc;
                };
                ActiveKey.prototype.constructKeyEvent = function (keyboardProcessor, device) {
                    // Make a deep copy of our preconstructed key event, filling it out from there.
                    var Lkc = keyman.utils.deepCopy(this.baseKeyEvent);
                    Lkc.device = device;
                    if (this.isMnemonic) {
                        keyman.text.KeyboardProcessor.setMnemonicCode(Lkc, this.layer.indexOf('shift') != -1, keyboardProcessor ? keyboardProcessor.stateKeys['K_CAPS'] : false);
                    }
                    // Performs common pre-analysis for both 'native' and 'embedded' OSK key & subkey input events.
                    // This part depends on the keyboard processor's active state.
                    if (keyboardProcessor) {
                        keyboardProcessor.setSyntheticEventDefaults(Lkc);
                        // If it's a state key modifier, trigger its effects as part of the
                        // keystroke.
                        var bitmap = {
                            'K_CAPS': keyman.text.Codes.stateBitmasks.CAPS,
                            'K_NUMLOCK': keyman.text.Codes.stateBitmasks.NUM_LOCK,
                            'K_SCROLL': keyman.text.Codes.stateBitmasks.SCROLL_LOCK
                        };
                        var bitmask = bitmap[Lkc.kName];
                        if (bitmask) {
                            Lkc.Lstates ^= bitmask;
                            Lkc.LmodifierChange = true;
                        }
                    }
                    return Lkc;
                };
                ActiveKey.prototype.getSubkey = function (coreID) {
                    if (this.sk) {
                        for (var _i = 0, _a = this.sk; _i < _a.length; _i++) {
                            var key = _a[_i];
                            if (key.coreID == coreID) {
                                return key;
                            }
                        }
                    }
                    return null;
                };
                ActiveKey.DEFAULT_PAD = 15; // Padding to left of key, in virtual units
                ActiveKey.DEFAULT_RIGHT_MARGIN = 15; // Padding to right of right-most key, in virtual units
                ActiveKey.DEFAULT_KEY_WIDTH = 100; // Width of a key, if not specified, in virtual units
                // Defines key defaults
                ActiveKey.DEFAULT_KEY = {
                    text: '',
                    width: ActiveKey.DEFAULT_KEY_WIDTH.toString(),
                    sp: '0',
                    pad: ActiveKey.DEFAULT_PAD.toString()
                };
                return ActiveKey;
            }());
            keyboards.ActiveKey = ActiveKey;
            var ActiveRow = /** @class */ (function () {
                function ActiveRow() {
                }
                ActiveRow.polyfill = function (row, layout, displayLayer, totalWidth, proportionalY) {
                    // Apply defaults, setting the width and other undefined properties for each key
                    var keys = row['key'];
                    for (var j = 0; j < keys.length; j++) {
                        var key = keys[j];
                        for (var tp in ActiveKey.DEFAULT_KEY) {
                            if (typeof key[tp] != 'string') {
                                key[tp] = ActiveKey.DEFAULT_KEY[tp];
                            }
                        }
                        // Modify the key type for special keys with non-standard labels
                        // to allow the keyboard font to ovveride the SpecialOSK font.
                        // Blank keys are no longer reclassed - can use before/after CSS to add text
                        switch (key['sp']) {
                            case '1':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '3';
                                }
                                break;
                            case '2':
                                if (!ActiveRow.SPECIAL_LABEL.test(key['text']) && key['text'] != '') {
                                    key['sp'] = '4';
                                }
                                break;
                        }
                        ActiveKey.polyfill(key, layout, displayLayer);
                    }
                    /* The calculations here are effectively 'virtualized'.  When used with the OSK, the VisualKeyboard
                     * will overwrite these values with their true runtime geometry.
                     *
                     * These calculations approximate those of the actual OSK (without fitting to a specific resolution)
                     * and are intended for use with layout testing (while headless) in the future.
                     */
                    var setProportions = function (key, padPc, keyPc, totalPc) {
                        key.proportionalPad = padPc;
                        key.proportionalWidth = keyPc;
                        key.proportionalX = (totalPc + padPc + (keyPc / 2));
                    };
                    // Calculate percentage-based scalings by summing defined widths and scaling each key to %.
                    // Save each percentage key width as a separate member (do *not* overwrite layout specified width!)
                    var keyPercent, padPercent, totalPercent = 0;
                    for (var j = 0; j < keys.length - 1; j++) {
                        keyPercent = parseInt(keys[j]['width'], 10) / totalWidth;
                        keys[j]['widthpc'] = keyPercent;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        // compute center's default x-coord (used in headless modes)
                        setProportions(keys[j], padPercent, keyPercent, totalPercent);
                        totalPercent += padPercent + keyPercent;
                    }
                    // Allow for right OSK margin (15 layout units)
                    var rightMargin = ActiveKey.DEFAULT_RIGHT_MARGIN / totalWidth;
                    totalPercent += rightMargin;
                    // If a single key, and padding is negative, add padding to right align the key
                    if (keys.length == 1 && parseInt(keys[0]['pad'], 10) < 0) {
                        keyPercent = parseInt(keys[0]['width'], 10) / totalWidth;
                        keys[0]['widthpc'] = keyPercent;
                        totalPercent += keyPercent;
                        keys[0]['padpc'] = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        setProportions(keys[0], padPercent, keyPercent, totalPercent);
                    }
                    else if (keys.length > 0) {
                        var j = keys.length - 1;
                        padPercent = parseInt(keys[j]['pad'], 10) / totalWidth;
                        keys[j]['padpc'] = padPercent;
                        totalPercent += padPercent;
                        keys[j]['widthpc'] = keyPercent = 1 - totalPercent;
                        // compute center's default x-coord (used in headless modes)
                        setProportions(keys[j], padPercent, keyPercent, totalPercent);
                    }
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveRow();
                    for (var key in dummy) {
                        if (!row.hasOwnProperty(key)) {
                            row[key] = dummy[key];
                        }
                    }
                    var aRow = row;
                    aRow.proportionalY = proportionalY;
                };
                ActiveRow.prototype.populateKeyMap = function (map) {
                    this.key.forEach(function (key) {
                        if (key.coreID) {
                            map[key.coreID] = key;
                        }
                    });
                };
                // Identify key labels (e.g. *Shift*) that require the special OSK font
                ActiveRow.SPECIAL_LABEL = /\*\w+\*/;
                return ActiveRow;
            }());
            keyboards.ActiveRow = ActiveRow;
            var ActiveLayer = /** @class */ (function () {
                function ActiveLayer() {
                }
                ActiveLayer.polyfill = function (layer, layout) {
                    layer.aligned = false;
                    // Create a DIV for each row of the group
                    var rows = layer['row'];
                    // Calculate the maximum row width (in layout units)
                    var totalWidth = 0;
                    for (var i = 0; i < layer['row'].length; i++) {
                        var width = 0;
                        var row = rows[i];
                        var keys = row['key'];
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            // Test for a trailing comma included in spec, added as null object by IE
                            if (key == null) {
                                keys.length = keys.length - 1;
                            }
                            else {
                                var kw, kp;
                                kw = (typeof key['width'] == 'string' && key['width'] != '') ? parseInt(key['width'], 10) : ActiveKey.DEFAULT_KEY_WIDTH;
                                if (isNaN(kw) || kw == 0)
                                    kw = ActiveKey.DEFAULT_KEY_WIDTH;
                                key['width'] = kw.toString();
                                kp = (typeof key['pad'] == 'string' && key['pad'] != '') ? parseInt(key['pad'], 10) : ActiveKey.DEFAULT_PAD;
                                if (isNaN(kp) || kp == 0)
                                    kp = ActiveKey.DEFAULT_PAD; // KMEW-119
                                key['pad'] = kp.toString();
                                width += kw + kp;
                                //if(typeof key['width'] == 'string' && key['width'] != '') width += parseInt(key['width'],10); else width += DEFAULT_KEY_WIDTH;
                                //if(typeof key['pad'] == 'string' && key['pad'] != '') width += parseInt(key['pad'],10); else width += 5;
                            }
                        }
                        if (width > totalWidth) {
                            totalWidth = width;
                        }
                    }
                    // Add default right margin
                    if (layout.formFactor == 'desktop') {
                        totalWidth += 5; // TODO: resolve difference between touch and desktop; why don't we use ActiveKey.DEFAULT_RIGHT_MARGIN?
                    }
                    else {
                        totalWidth += ActiveKey.DEFAULT_RIGHT_MARGIN;
                    }
                    var rowCount = layer.row.length;
                    for (var i = 0; i < rowCount; i++) {
                        // Calculate proportional y-coord of row.  0 is at top with highest y-coord.
                        var rowProportionalY = (i + 0.5) / rowCount;
                        ActiveRow.polyfill(layer.row[i], layout, layer.id, totalWidth, rowProportionalY);
                    }
                    // Add class functions and properties to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayer();
                    for (var key in dummy) {
                        if (!layer.hasOwnProperty(key)) {
                            layer[key] = dummy[key];
                        }
                    }
                    var aLayer = layer;
                    aLayer.totalWidth = totalWidth;
                    aLayer.defaultKeyProportionalWidth = parseInt(ActiveKey.DEFAULT_KEY.width, 10) / totalWidth;
                    aLayer.rowProportionalHeight = 1.0 / rowCount;
                    aLayer.keyMap = aLayer.constructKeyMap();
                };
                ActiveLayer.prototype.constructKeyMap = function () {
                    var map = {};
                    this.row.forEach(function (row) {
                        row.populateKeyMap(map);
                    });
                    return map;
                };
                /**
                 * Builds a sorted-order array of most likely keys to be intended for a given touch.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.getTouchProbabilities = function (touchCoords, kbdScaleRatio) {
                    var distribution = this.simpleTouchDistribution(touchCoords, kbdScaleRatio);
                    var list = [];
                    for (var key in distribution) {
                        list.push({ keyId: key, p: distribution[key] });
                    }
                    return list.sort(function (a, b) {
                        return b.p - a.p; // Largest probability keys should be listed first.
                    });
                };
                /**
                 * Computes a probability distribution regarding the likelihood of a touch command being intended
                 * for each of the layout's keys.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.simpleTouchDistribution = function (touchCoords, kbdScaleRatio) {
                    var keyDists = this.keyTouchDistances(touchCoords, kbdScaleRatio);
                    var keyProbs = {};
                    var totalMass = 0;
                    // Should we wish to allow multiple different transforms for distance -> probability, use a function parameter in place
                    // of the formula in the loop below.
                    for (var key in keyDists) {
                        totalMass += keyProbs[key] = 1 / (keyDists[key] + 1e-6); // Prevent div-by-0 errors.
                    }
                    for (var key in keyProbs) {
                        keyProbs[key] /= totalMass;
                    }
                    return keyProbs;
                };
                /**
                 * Computes a squared 'pseudo-distance' for the touch from each key.  (Not a proper metric.)
                 * Intended for use in generating a probability distribution over the keys based on the touch input.
                 * @param touchCoords A proportional (x, y) coordinate of the touch within the keyboard's geometry.
                 *                           Should be within [0, 0] to [1, 1].
                 * @param kbdScaleRatio The ratio of the keyboard's horizontal scale to its vertical scale.
                 *                           For a 400 x 200 keyboard, should be 2.
                 */
                ActiveLayer.prototype.keyTouchDistances = function (touchCoords, kbdScaleRatio) {
                    var layer = this;
                    var keyDists = {};
                    // This double-nested loop computes a pseudo-distance for the touch from each key.  Quite useful for
                    // generating a probability distribution.
                    this.row.forEach(function (row) {
                        row.key.forEach(function (key) {
                            // If the key lacks an ID, just skip it.  Sometimes used for padding.
                            if (!key.baseKeyID) {
                                return;
                            }
                            else {
                                // Attempt to filter out known non-output keys.
                                // Results in a more optimized distribution.
                                switch (key.baseKeyID) {
                                    case 'K_SHIFT':
                                    case 'K_LOPT':
                                    case 'K_ROPT':
                                    case 'K_NUMLOCK': // Often used for numeric layers.
                                    case 'K_CAPS':
                                        // As these aren't output keys, they shouldn't be possible fat-finger targets.
                                        return;
                                    default:
                                        // Refer to text/codes.ts - these are Keyman-custom "keycodes" used for
                                        // layer shifting keys.  To be safe, we currently let K_TABBACK and
                                        // K_TABFWD through, though we might be able to drop them too.
                                        var code = com.keyman.text.Codes[key.baseKeyID];
                                        if (code > 50000 && code < 50011) {
                                            return;
                                        }
                                }
                            }
                            // These represent the within-key distance of the touch from the key's center.
                            // Both should be on the interval [0, 0.5].
                            var dx = Math.abs(touchCoords.x - key.proportionalX);
                            var dy = Math.abs(touchCoords.y - row.proportionalY);
                            // If the touch isn't within the key, these store the out-of-key distance
                            // from the closest point on the key being checked.
                            var distX, distY;
                            if (dx > 0.5 * key.proportionalWidth) {
                                distX = (dx - 0.5 * key.proportionalWidth);
                                dx = 0.5;
                            }
                            else {
                                distX = 0;
                                dx /= key.proportionalWidth;
                            }
                            if (dy > 0.5 * layer.rowProportionalHeight) {
                                distY = (dy - 0.5 * layer.rowProportionalHeight);
                                dy = 0.5;
                            }
                            else {
                                distY = 0;
                                dy /= layer.rowProportionalHeight;
                            }
                            // Now that the differentials are computed, it's time to do distance scaling.
                            //
                            // For out-of-key distance, we scale the X component by the keyboard's aspect ratio
                            // to get the actual out-of-key distance rather than proportional.
                            distX *= kbdScaleRatio;
                            // While the keys are rarely perfect squares, we map all within-key distance
                            // to a square shape.  (ALT/CMD should seem as close to SPACE as a 'B'.)
                            //
                            // For that square, we take the rowHeight as its edge lengths.
                            distX += dx * layer.rowProportionalHeight;
                            distY += dy * layer.rowProportionalHeight;
                            var distance = distX * distX + distY * distY;
                            keyDists[key.coreID] = distance;
                        });
                    });
                    return keyDists;
                };
                ActiveLayer.prototype.getKey = function (keyId) {
                    // Keys usually are specified in a "long form" prefixed with their layer's ID.
                    if (keyId.indexOf(this.id + '-') == 0) {
                        keyId = keyId.replace(this.id + '-', '');
                    }
                    var idComponents = keyId.split('::');
                    if (idComponents.length > 1) {
                        var baseKey = this.keyMap[idComponents[0]];
                        return baseKey.getSubkey(idComponents[1]);
                    }
                    else {
                        return this.keyMap[keyId];
                    }
                };
                return ActiveLayer;
            }());
            keyboards.ActiveLayer = ActiveLayer;
            var ActiveLayout = /** @class */ (function () {
                function ActiveLayout() {
                }
                ActiveLayout.prototype.getLayer = function (layerId) {
                    return this.layerMap[layerId];
                };
                /**
                 * Refer to https://github.com/keymanapp/keyman/issues/254, which mentions
                 * KD-11 from a prior issue-tracking system from the closed-source days that
                 * resulted in an unintended extra empty row.
                 *
                 * It'll be pretty rare to see a keyboard affected by the bug, but we don't
                 * 100% control all keyboards out there, so it's best we make sure the edge
                 * case is covered.
                 *
                 * @param layers The layer group to be loaded for the form factor.  Will be
                 *               mutated by this operation.
                 */
                ActiveLayout.correctLayerEmptyRowBug = function (layers) {
                    for (var n = 0; n < layers.length; n++) {
                        var layer = layers[n];
                        var rows = layer['row'];
                        var i = void 0;
                        for (i = rows.length - 1; i >= 0; i--) {
                            if (!Array.isArray(rows[i]['key']) || rows[i]['key'].length == 0) {
                                rows.splice(i, 1);
                            }
                        }
                    }
                };
                /**
                 *
                 * @param layout
                 * @param formFactor
                 */
                ActiveLayout.polyfill = function (layout, keyboard, formFactor) {
                    if (layout == null) {
                        throw new Error("Cannot build an ActiveLayout for a null specification.");
                    }
                    // Create a separate OSK div for each OSK layer, only one of which will ever be visible
                    var n;
                    var layerMap = {};
                    var layers = layout['layer'];
                    ActiveLayout.correctLayerEmptyRowBug(layers);
                    // Add class functions to the existing layout object, allowing it to act as an ActiveLayout.
                    var dummy = new ActiveLayout();
                    for (var key in dummy) {
                        if (!layout.hasOwnProperty(key)) {
                            layout[key] = dummy[key];
                        }
                    }
                    var aLayout = layout;
                    aLayout.keyboard = keyboard;
                    aLayout.formFactor = formFactor;
                    for (n = 0; n < layers.length; n++) {
                        ActiveLayer.polyfill(layers[n], aLayout);
                        layerMap[layers[n].id] = layers[n];
                    }
                    aLayout.layerMap = layerMap;
                    return aLayout;
                };
                return ActiveLayout;
            }());
            keyboards.ActiveLayout = ActiveLayout;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            /**
             * Defines common behaviors associated with system stores.
             */
            var SystemStore = /** @class */ (function () {
                function SystemStore(id) {
                    this.id = id;
                }
                SystemStore.prototype.set = function (value) {
                    throw new Error("System store with ID " + this.id + " may not be directly set.");
                };
                return SystemStore;
            }());
            text.SystemStore = SystemStore;
            var MutableSystemStore = /** @class */ (function (_super) {
                __extends(MutableSystemStore, _super);
                function MutableSystemStore(id, defaultValue) {
                    var _this = _super.call(this, id) || this;
                    _this.handler = null;
                    _this._value = defaultValue;
                    return _this;
                }
                Object.defineProperty(MutableSystemStore.prototype, "value", {
                    get: function () {
                        return this._value;
                    },
                    enumerable: true,
                    configurable: true
                });
                MutableSystemStore.prototype.matches = function (value) {
                    return this._value == value;
                };
                MutableSystemStore.prototype.set = function (value) {
                    if (this.handler) {
                        if (this.handler(this, value)) {
                            return;
                        }
                    }
                    this._value = value;
                };
                return MutableSystemStore;
            }(SystemStore));
            text.MutableSystemStore = MutableSystemStore;
            /**
             * Handles checks against the current platform.
             */
            var PlatformSystemStore = /** @class */ (function (_super) {
                __extends(PlatformSystemStore, _super);
                function PlatformSystemStore(keyboardInterface) {
                    var _this = _super.call(this, text.KeyboardInterface.TSS_PLATFORM) || this;
                    _this.kbdInterface = keyboardInterface;
                    return _this;
                }
                PlatformSystemStore.prototype.matches = function (value) {
                    var i, constraint, constraints = value.split(' ');
                    var device = this.kbdInterface.activeDevice;
                    for (i = 0; i < constraints.length; i++) {
                        constraint = constraints[i].toLowerCase();
                        switch (constraint) {
                            case 'touch':
                            case 'hardware':
                                if (device.touchable != (constraint == 'touch')) {
                                    return false;
                                }
                                break;
                            case 'macos':
                            case 'mac':
                                constraint = 'macosx';
                            // fall through
                            case 'macosx':
                            case 'windows':
                            case 'android':
                            case 'ios':
                            case 'linux':
                                if (device.OS != constraint) {
                                    return false;
                                }
                                break;
                            case 'tablet':
                            case 'phone':
                            case 'desktop':
                                if (device.formFactor != constraint) {
                                    return false;
                                }
                                break;
                            case 'web':
                                if (device.browser == 'native') {
                                    return false; // web matches anything other than 'native'
                                }
                                break;
                            case 'native':
                            // This will return true for embedded KeymanWeb
                            case 'ie':
                            case 'chrome':
                            case 'firefox':
                            case 'safari':
                            case 'edge':
                            case 'opera':
                                if (device.browser != constraint) {
                                    return false;
                                }
                                break;
                            default:
                                return false;
                        }
                    }
                    // Everything we checked against was valid and had matches - it's a match!
                    return true;
                };
                return PlatformSystemStore;
            }(SystemStore));
            text.PlatformSystemStore = PlatformSystemStore;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="deadkeys.ts" />
/// <reference path="ruleBehavior.ts" />
// Defines classes for handling system stores
/// <reference path="systemStores.ts" />
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            //#region Helper type definitions
            var KeyInformation = /** @class */ (function () {
                function KeyInformation() {
                }
                return KeyInformation;
            }());
            text.KeyInformation = KeyInformation;
            var RuleDeadkey = /** @class */ (function () {
                function RuleDeadkey() {
                }
                return RuleDeadkey;
            }());
            var ContextAny = /** @class */ (function () {
                function ContextAny() {
                }
                return ContextAny;
            }());
            var RuleIndex = /** @class */ (function () {
                function RuleIndex() {
                }
                return RuleIndex;
            }());
            var ContextEx = /** @class */ (function () {
                function ContextEx() {
                }
                return ContextEx;
            }());
            var ContextNul = /** @class */ (function () {
                function ContextNul() {
                }
                return ContextNul;
            }());
            var StoreBeep = /** @class */ (function () {
                function StoreBeep() {
                }
                return StoreBeep;
            }());
            /**
             * Cache of context storing and retrieving return values from KC
             * Must be reset prior to each keystroke and after any text changes
             * MCD 3/1/14
             **/
            var CachedContext = /** @class */ (function () {
                function CachedContext() {
                }
                CachedContext.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContext.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContext.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                return CachedContext;
            }());
            ;
            /**
             * An extended version of cached context storing designed to work with
             * `fullContextMatch` and its helper functions.
             */
            var CachedContextEx = /** @class */ (function () {
                function CachedContextEx() {
                }
                CachedContextEx.prototype.reset = function () {
                    this._cache = [];
                };
                CachedContextEx.prototype.get = function (n, ln) {
                    // return null; // uncomment this line to disable context caching
                    if (typeof this._cache[n] == 'undefined') {
                        return null;
                    }
                    else if (typeof this._cache[n][ln] == 'undefined') {
                        return null;
                    }
                    return this._cache[n][ln];
                };
                CachedContextEx.prototype.set = function (n, ln, val) {
                    if (typeof this._cache[n] == 'undefined') {
                        this._cache[n] = [];
                    }
                    this._cache[n][ln] = val;
                };
                CachedContextEx.prototype.clone = function () {
                    var r = new CachedContextEx();
                    r._cache = this._cache;
                    return r;
                };
                return CachedContextEx;
            }());
            ;
            //#endregion
            var KeyboardInterface = /** @class */ (function () {
                function KeyboardInterface(variableStoreSerializer) {
                    if (variableStoreSerializer === void 0) { variableStoreSerializer = null; }
                    this.cachedContext = new CachedContext();
                    this.cachedContextEx = new CachedContextEx();
                    this._AnyIndices = []; // AnyIndex - array of any/index match indices
                    this.systemStores = {};
                    this.systemStores[KeyboardInterface.TSS_PLATFORM] = new text.PlatformSystemStore(this);
                    this.systemStores[KeyboardInterface.TSS_LAYER] = new text.MutableSystemStore(KeyboardInterface.TSS_LAYER, 'default');
                    this.variableStoreSerializer = variableStoreSerializer;
                }
                /**
                 * Function     KSF
                 * Scope        Public
                 *
                 * Saves the document's current focus settings on behalf of the keyboard.  Often paired with insertText.
                 */
                KeyboardInterface.prototype.saveFocus = function () { };
                /**
                 * Function     registerKeyboard  KR
                 * Scope        Public
                 * @param       {Object}      Pk      Keyboard  object
                 * Description  Registers a keyboard with KeymanWeb once its script has fully loaded.
                 *
                 *              In web-core, this also activates the keyboard; in other modules, this method
                 *              may be replaced with other implementations.
                 */
                KeyboardInterface.prototype.registerKeyboard = function (Pk) {
                    // NOTE:  This implementation is web-core specific and is intentionally replaced, whole-sale,
                    //        by DOM-aware code.
                    var keyboard = new keyman.keyboards.Keyboard(Pk);
                    this.activeKeyboard = keyboard;
                };
                /**
                 * Get *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "abcdef"  i.e. return as much as possible of the requested string
                 */
                KeyboardInterface.prototype.context = function (n, ln, outputTarget) {
                    var v = this.cachedContext.get(n, ln);
                    if (v !== null) {
                        return v;
                    }
                    var r = this.KC_(n, ln, outputTarget);
                    this.cachedContext.set(n, ln, r);
                    return r;
                };
                /**
                 * Get (uncached) keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {string}              Context string
                 *
                 * Example     [abcdef|ghi] as INPUT, with the caret position marked by |:
                 *             KC(2,1,Pelem) == "e"
                 *             KC(3,3,Pelem) == "def"
                 *             KC(10,10,Pelem) == "XXXXabcdef"  i.e. return as much as possible of the requested string, where X = \uFFFE
                 */
                KeyboardInterface.prototype.KC_ = function (n, ln, outputTarget) {
                    var tempContext = '';
                    tempContext = outputTarget.getTextBeforeCaret();
                    if (tempContext._kmwLength() < n) {
                        tempContext = Array(n - tempContext._kmwLength() + 1).join("\uFFFE") + tempContext;
                    }
                    return tempContext._kmwSubstr(-n)._kmwSubstr(0, ln);
                };
                /**
                 * Function     nul           KN
                 * Scope        Public
                 * @param       {number}      n       Length of context to check
                 * @param       {Object}      Ptarg   Element to work with (must be currently focused element)
                 * @return      {boolean}             True if length of context is less than or equal to n
                 * Description  Test length of context, return true if the length of the context is less than or equal to n
                 *
                 * Example     [abc|def] as INPUT, with the caret position marked by |:
                 *             KN(3,Pelem) == TRUE
                 *             KN(2,Pelem) == FALSE
                 *             KN(4,Pelem) == TRUE
                 */
                KeyboardInterface.prototype.nul = function (n, outputTarget) {
                    var cx = this.context(n + 1, 1, outputTarget);
                    // With #31, the result will be a replacement character if context is empty.
                    return cx === "\uFFFE";
                };
                /**
                 * Function     contextMatch  KCM
                 * Scope        Public
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {Object}      Ptarg   Focused element
                 * @param       {string}      val     String to match
                 * @param       {number}      ln      Number of characters to return
                 * @return      {boolean}             True if selected context matches val
                 * Description  Test keyboard context for match
                 */
                KeyboardInterface.prototype.contextMatch = function (n, outputTarget, val, ln) {
                    var cx = this.context(n, ln, outputTarget);
                    if (cx === val) {
                        return true; // I3318
                    }
                    outputTarget.deadkeys().resetMatched(); // I3318
                    return false;
                };
                /**
                 * Builds the *cached or uncached* keyboard context for a specified range, relative to caret
                 *
                 * @param       {number}      n       Number of characters to move back from caret
                 * @param       {number}      ln      Number of characters to return
                 * @param       {Object}      Pelem   Element to work with (must be currently focused element)
                 * @return      {Array}               Context array (of strings and numbers)
                 */
                KeyboardInterface.prototype._BuildExtendedContext = function (n, ln, outputTarget) {
                    var cache = this.cachedContextEx.get(n, ln);
                    if (cache !== null) {
                        return cache;
                    }
                    else {
                        // By far the easiest way to correctly build what we want is to start from the right and work to what we need.
                        // We may have done it for a similar cursor position before.
                        cache = this.cachedContextEx.get(n, n);
                        if (cache === null) {
                            // First, let's make sure we have a cloned, sorted copy of the deadkey array.
                            var unmatchedDeadkeys = outputTarget.deadkeys().toSortedArray(); // Is reverse-order sorted for us already.
                            // Time to build from scratch!
                            var index = 0;
                            cache = { valContext: [], deadContext: [] };
                            while (cache.valContext.length < n) {
                                // As adapted from `deadkeyMatch`.
                                var sp = outputTarget.getDeadkeyCaret();
                                var deadPos = sp - index;
                                if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p > deadPos) {
                                    // We have deadkeys at the right-hand side of the caret!  They don't belong in the context, so pop 'em off.
                                    unmatchedDeadkeys.splice(0, 1);
                                    continue;
                                }
                                else if (unmatchedDeadkeys.length > 0 && unmatchedDeadkeys[0].p == deadPos) {
                                    // Take the deadkey.
                                    cache.deadContext[n - cache.valContext.length - 1] = unmatchedDeadkeys[0];
                                    cache.valContext = [unmatchedDeadkeys[0].d].concat(cache.valContext);
                                    unmatchedDeadkeys.splice(0, 1);
                                }
                                else {
                                    // Take the character.  We get "\ufffe" if it doesn't exist.
                                    var kc = this.context(++index, 1, outputTarget);
                                    cache.valContext = [kc].concat(cache.valContext);
                                }
                            }
                            this.cachedContextEx.set(n, n, cache);
                        }
                        // Now that we have the cache...
                        var subCache = cache;
                        subCache.valContext = subCache.valContext.slice(0, ln);
                        for (var i = 0; i < subCache.valContext.length; i++) {
                            if (subCache[i] == '\ufffe') {
                                subCache.valContext.splice(0, 1);
                                subCache.deadContext.splice(0, 1);
                            }
                        }
                        if (subCache.valContext.length == 0) {
                            subCache.valContext = ['\ufffe'];
                            subCache.deadContext = [];
                        }
                        this.cachedContextEx.set(n, ln, subCache);
                        return subCache;
                    }
                };
                /**
                 * Function       fullContextMatch    KFCM
                 * Scope          Private
                 * @param         {number}    n       Number of characters to move back from caret
                 * @param         {Object}    Ptarg   Focused element
                 * @param         {Array}     rule    An array of ContextEntries to match.
                 * @return        {boolean}           True if the fully-specified rule context matches the current KMW state.
                 *
                 * A KMW 10+ function designed to bring KMW closer to Keyman Desktop functionality,
                 * near-directly modeling (externally) the compiled form of Desktop rules' context section.
                 */
                KeyboardInterface.prototype.fullContextMatch = function (n, outputTarget, rule) {
                    // Stage one:  build the context index map.
                    var fullContext = this._BuildExtendedContext(n, rule.length, outputTarget);
                    this.ruleContextEx = this.cachedContextEx.clone();
                    var context = fullContext.valContext;
                    var deadContext = fullContext.deadContext;
                    var mismatch = false;
                    // This symbol internally indicates lack of context in a position.  (See KC_)
                    var NUL_CONTEXT = "\uFFFE";
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    // Stage two:  time to match against the rule specified.
                    for (var i = 0; i < rule.length; i++) {
                        if (typeof rule[i] == 'string') {
                            var str = rule[i];
                            if (str !== context[i]) {
                                mismatch = true;
                                break;
                            }
                        }
                        else {
                            // TypeScript needs a cast to this intermediate type to do its discriminated union magic.
                            var r = rule[i];
                            switch (r.t) {
                                case 'd':
                                    // We still need to set a flag here;
                                    if (r['d'] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'a':
                                    var lookup;
                                    if (typeof context[i] == 'string') {
                                        lookup = context[i];
                                    }
                                    else {
                                        lookup = { 't': 'd', 'd': context[i] };
                                    }
                                    var result = this.any(i, lookup, r.a);
                                    if (!r.n) { // If it's a standard 'any'...
                                        if (!result) {
                                            mismatch = true;
                                        }
                                        else if (deadContext[i] !== undefined) {
                                            // It's a deadkey match, so indicate that.
                                            deadContext[i].set();
                                        }
                                        // 'n' for 'notany'.
                                        // - if `result === true`, `any` would match:  this should thus fail.
                                        // - if `context[i] === NUL_CONTEXT`, `notany` should not match.
                                    }
                                    else if (r.n && (result || context[i] === NUL_CONTEXT)) {
                                        mismatch = true;
                                    }
                                    break;
                                case 'i':
                                    // The context will never hold a 'beep.'
                                    var ch = this._Index(r.i, r.o);
                                    if (ch !== undefined && (typeof (ch) == 'string' ? ch : ch.d) !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'c':
                                    if (context[r.c - 1] !== context[i]) {
                                        mismatch = true;
                                    }
                                    else if (deadContext[i] !== undefined) {
                                        deadContext[i].set();
                                    }
                                    break;
                                case 'n':
                                    // \uFFFE is the internal 'no context here sentinel'.
                                    if (context[i] != NUL_CONTEXT) {
                                        mismatch = true;
                                    }
                                    break;
                                default:
                                    assertNever(r);
                            }
                        }
                    }
                    if (mismatch) {
                        // Reset the matched 'any' indices, if any.
                        outputTarget.deadkeys().resetMatched();
                        this._AnyIndices = [];
                    }
                    return !mismatch;
                };
                /**
                 * Function     KIK
                 * Scope        Public
                 * @param       {Object}  e   keystroke event
                 * @return      {boolean}     true if keypress event
                 * Description  Test if event as a keypress event
                 */
                KeyboardInterface.prototype.isKeypress = function (e) {
                    if (this.activeKeyboard.isMnemonic) { // I1380 - support KIK for positional layouts
                        return !e.LisVirtualKey; // will now return true for U_xxxx keys, but not for T_xxxx keys
                    }
                    else {
                        return keyman.KeyMapping._USKeyCodeToCharCode(e) ? true : false; // I1380 - support KIK for positional layouts
                    }
                };
                /**
                 * Function     keyMatch      KKM
                 * Scope        Public
                 * @param       {Object}      e           keystroke event
                 * @param       {number}      Lruleshift
                 * @param       {number}      Lrulekey
                 * @return      {boolean}                 True if key matches rule
                 * Description  Test keystroke with modifiers against rule
                 */
                KeyboardInterface.prototype.keyMatch = function (e, Lruleshift, Lrulekey) {
                    var retVal = false; // I3318
                    var keyCode = (e.Lcode == 173 ? 189 : e.Lcode); //I3555 (Firefox hyphen issue)
                    var bitmask = this.activeKeyboard.modifierBitmask;
                    var Codes = com.keyman.text.Codes;
                    var modifierBitmask = bitmask & Codes.modifierBitmasks["ALL"];
                    var stateBitmask = bitmask & Codes.stateBitmasks["ALL"];
                    if (e.vkCode > 255) {
                        keyCode = e.vkCode; // added to support extended (touch-hold) keys for mnemonic layouts
                    }
                    if (e.LisVirtualKey || keyCode > 255) {
                        if ((Lruleshift & 0x4000) == 0x4000 || (keyCode > 255)) { // added keyCode test to support extended keys
                            retVal = ((Lrulekey == keyCode) && ((Lruleshift & modifierBitmask) == e.Lmodifiers)); //I3318, I3555
                            retVal = retVal && this.stateMatch(e, Lruleshift & stateBitmask);
                        }
                    }
                    else if ((Lruleshift & 0x4000) == 0) {
                        retVal = (keyCode == Lrulekey); // I3318, I3555
                    }
                    if (!retVal) {
                        this.activeTargetOutput.deadkeys().resetMatched(); // I3318
                    }
                    return retVal; // I3318
                };
                ;
                /**
                 * Function     stateMatch    KSM
                 * Scope        Public
                 * @param       {Object}      e       keystroke event
                 * @param       {number}      Lstate
                 * Description  Test keystroke against state key rules
                 */
                KeyboardInterface.prototype.stateMatch = function (e, Lstate) {
                    return ((Lstate & e.Lstates) == Lstate);
                };
                /**
                 * Function     keyInformation  KKI
                 * Scope        Public
                 * @param       {Object}      e
                 * @return      {Object}              Object with event's virtual key flag, key code, and modifiers
                 * Description  Get object with extended key event information
                 */
                KeyboardInterface.prototype.keyInformation = function (e) {
                    var ei = new KeyInformation();
                    ei['vk'] = e.LisVirtualKey;
                    ei['code'] = e.Lcode;
                    ei['modifiers'] = e.Lmodifiers;
                    return ei;
                };
                ;
                /**
                 * Function     deadkeyMatch  KDM
                 * Scope        Public
                 * @param       {number}      n       offset from current cursor position
                 * @param       {Object}      Ptarg   target element
                 * @param       {number}      d       deadkey
                 * @return      {boolean}             True if deadkey found selected context matches val
                 * Description  Match deadkey at current cursor position
                 */
                KeyboardInterface.prototype.deadkeyMatch = function (n, outputTarget, d) {
                    return outputTarget.hasDeadkeyMatch(n, d);
                };
                /**
                 * Function     beep          KB
                 * Scope        Public
                 * @param       {Object}      Pelem     element to flash
                 * Description  Flash body as substitute for audible beep; notify embedded device to vibrate
                 */
                KeyboardInterface.prototype.beep = function (outputTarget) {
                    this.resetContextCache();
                    // Denote as part of the matched rule's behavior.
                    this.ruleBehavior.beep = true;
                };
                KeyboardInterface.prototype._ExplodeStore = function (store) {
                    if (typeof (store) == 'string') {
                        var cachedStores = this.activeKeyboard.explodedStores;
                        // Is the result cached?
                        if (cachedStores[store]) {
                            return cachedStores[store];
                        }
                        // Nope, so let's build its cache.
                        var result = [];
                        for (var i = 0; i < store._kmwLength(); i++) {
                            result.push(store._kmwCharAt(i));
                        }
                        // Cache the result for later!
                        cachedStores[store] = result;
                        return result;
                    }
                    else {
                        return store;
                    }
                };
                /**
                 * Function     any           KA
                 * Scope        Public
                 * @param       {number}      n     character position (index)
                 * @param       {string}      ch    character to find in string
                 * @param       {string}      s     'any' string
                 * @return      {boolean}           True if character found in 'any' string, sets index accordingly
                 * Description  Test for character matching
                 */
                KeyboardInterface.prototype.any = function (n, ch, s) {
                    if (ch == '') {
                        return false;
                    }
                    s = this._ExplodeStore(s);
                    var Lix = -1;
                    for (var i = 0; i < s.length; i++) {
                        if (typeof (s[i]) == 'string') {
                            if (s[i] == ch) {
                                Lix = i;
                                break;
                            }
                        }
                        else if (s[i]['d'] === ch['d']) {
                            Lix = i;
                            break;
                        }
                    }
                    this._AnyIndices[n] = Lix;
                    return Lix >= 0;
                };
                /**
                 * Function     _Index
                 * Scope        Public
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * Description  Returns the character from a store string according to the offset in the index array
                 */
                KeyboardInterface.prototype._Index = function (Ps, Pn) {
                    Ps = this._ExplodeStore(Ps);
                    if (this._AnyIndices[Pn - 1] < Ps.length) { //I3319
                        return Ps[this._AnyIndices[Pn - 1]];
                    }
                    else {
                        /* Should not be possible for a compiled keyboard, but may arise
                        * during the development of handwritten keyboards.
                        */
                        console.warn("Unmatched contextual index() statement detected in rule with index " + Pn + "!");
                        return "";
                    }
                };
                /**
                 * Function     indexOutput   KIO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {string}      Ps      string
                 * @param       {number}      Pn      index
                 * @param       {Object}      Pelem   element to output to
                 * Description  Output a character selected from the string according to the offset in the index array
                 */
                KeyboardInterface.prototype.indexOutput = function (Pdn, Ps, Pn, outputTarget) {
                    this.resetContextCache();
                    var assertNever = function (x) {
                        // Could be accessed by improperly handwritten calls to `fullContextMatch`.
                        throw new Error("Unexpected object in fullContextMatch specification: " + x);
                    };
                    var indexChar = this._Index(Ps, Pn);
                    if (indexChar !== "") {
                        if (typeof indexChar == 'string') {
                            this.output(Pdn, outputTarget, indexChar); //I3319
                        }
                        else if (indexChar['t']) {
                            var storeEntry = indexChar;
                            switch (storeEntry.t) {
                                case 'b': // Beep commands may appear within stores.
                                    this.beep(outputTarget);
                                    break;
                                case 'd':
                                    this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                                    break;
                                default:
                                    assertNever(storeEntry);
                            }
                        }
                        else { // For keyboards developed during 10.0's alpha phase - t:'d' was assumed.
                            this.deadkeyOutput(Pdn, outputTarget, indexChar['d']);
                        }
                    }
                };
                /**
                 * Function     deleteContext KDC
                 * Scope        Public
                 * @param       {number}      dn      number of context entries to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.deleteContext = function (dn, outputTarget) {
                    var context;
                    // We want to control exactly which deadkeys get removed.
                    if (dn > 0) {
                        context = this._BuildExtendedContext(dn, dn, outputTarget);
                        var nulCount = 0;
                        for (var i = 0; i < context.valContext.length; i++) {
                            var dk = context.deadContext[i];
                            if (dk) {
                                // Remove deadkey in context.
                                outputTarget.deadkeys().remove(dk);
                                // Reduce our reported context size.
                                dn--;
                            }
                            else if (context.valContext[i] == "\uFFFE") {
                                // Count any `nul` sentinels that would contribute to our deletion count.
                                nulCount++;
                            }
                        }
                        // Prevent attempts to delete nul sentinels, as they don't exist in the actual context.
                        // (Addresses regression from KMW v 12.0 paired with Developer bug through same version)
                        var contextLength = context.valContext.length - nulCount;
                        if (dn > contextLength) {
                            dn = contextLength;
                        }
                    }
                    // If a matched deadkey hasn't been deleted, we don't WANT to delete it.
                    outputTarget.deadkeys().resetMatched();
                    // Why reinvent the wheel?  Delete the remaining characters by 'inserting a blank string'.
                    this.output(dn, outputTarget, '');
                };
                /**
                 * Function     output        KO
                 * Scope        Public
                 * @param       {number}      dn      number of characters to overwrite
                 * @param       {Object}      Pelem   element to output to
                 * @param       {string}      s       string to output
                 * Description  Keyboard output
                 */
                KeyboardInterface.prototype.output = function (dn, outputTarget, s) {
                    this.resetContextCache();
                    outputTarget.saveProperties();
                    outputTarget.clearSelection();
                    outputTarget.deadkeys().deleteMatched(); // I3318
                    if (dn >= 0) {
                        // Automatically manages affected deadkey positions.  Does not delete deadkeys b/c legacy behavior support.
                        outputTarget.deleteCharsBeforeCaret(dn);
                    }
                    // Automatically manages affected deadkey positions.
                    outputTarget.insertTextBeforeCaret(s);
                    outputTarget.restoreProperties();
                };
                /**
                 * `contextExOutput` function emits the character or object at `contextOffset` from the
                 * current matched rule's context. Introduced in Keyman 14.0, in order to resolve a
                 * gap between desktop and web core functionality for context(n) matching on notany().
                 * See #917 for additional detail.
                 * @alias       KCXO
                 * @public
                 * @param       {number}        Pdn            number of characters to delete left of cursor
                 * @param       {OutputTarget}  outputTarget   target to output to
                 * @param       {number}        contextLength  length of current rule context to retrieve
                 * @param       {number}        contextOffset  offset from start of current rule context, 1-based
                 */
                KeyboardInterface.prototype.contextExOutput = function (Pdn, outputTarget, contextLength, contextOffset) {
                    this.resetContextCache();
                    if (Pdn >= 0) {
                        this.output(Pdn, outputTarget, "");
                    }
                    var context = this.ruleContextEx.get(contextLength, contextLength);
                    var dk = context.deadContext[contextOffset - 1], vc = context.valContext[contextOffset - 1];
                    if (dk) {
                        outputTarget.insertDeadkeyBeforeCaret(dk.d);
                    }
                    else if (typeof vc == 'string') {
                        this.output(-1, outputTarget, vc);
                    }
                    else {
                        throw new Error("contextExOutput: should never be a numeric valContext with no corresponding deadContext");
                    }
                };
                /**
                 * Function     deadkeyOutput KDO
                 * Scope        Public
                 * @param       {number}      Pdn     no of character to overwrite (delete)
                 * @param       {Object}      Pelem   element to output to
                 * @param       {number}      Pd      deadkey id
                 * Description  Record a deadkey at current cursor position, deleting Pdn characters first
                 */
                KeyboardInterface.prototype.deadkeyOutput = function (Pdn, outputTarget, Pd) {
                    this.resetContextCache();
                    if (Pdn >= 0) {
                        this.output(Pdn, outputTarget, ""); //I3318 corrected to >=
                    }
                    outputTarget.insertDeadkeyBeforeCaret(Pd);
                    //    _DebugDeadKeys(Pelem, 'KDeadKeyOutput: dn='+Pdn+'; deadKey='+Pd);
                };
                /**
                 * KIFS compares the content of a system store with a string value
                 *
                 * @param       {number}      systemId    ID of the system store to test (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String value to compare to
                 * @param       {Object}      Pelem       Currently active element (may be needed by future tests)
                 * @return      {boolean}                 True if the test succeeds
                 */
                KeyboardInterface.prototype.ifStore = function (systemId, strValue, outputTarget) {
                    var result = true;
                    var store = this.systemStores[systemId];
                    if (store) {
                        result = store.matches(strValue);
                    }
                    return result; //Moved from previous line, now supports layer selection, Build 350
                };
                /**
                 * KSETS sets the value of a system store to a string
                 *
                 * @param       {number}      systemId    ID of the system store to set (only TSS_LAYER currently supported)
                 * @param       {string}      strValue    String to set as the system store content
                 * @param       {Object}      Pelem       Currently active element (may be needed in future tests)
                 * @return      {boolean}                 True if command succeeds
                 *                                        (i.e. for TSS_LAYER, if the layer is successfully selected)
                 *
                 * Note that option/variable stores are instead set within keyboard script code, as they only
                 * affect keyboard behavior.
                 */
                KeyboardInterface.prototype.setStore = function (systemId, strValue, outputTarget) {
                    this.resetContextCache();
                    if (systemId == KeyboardInterface.TSS_LAYER) {
                        // Denote the changed store as part of the matched rule's behavior.
                        this.ruleBehavior.setStore[systemId] = strValue;
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * Load an option store value from a cookie or default value
                 *
                 * @param       {string}      kbdName     keyboard internal name
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      dfltValue   default value
                 * @return      {string}                  current or default option value
                 *
                 * This will only ever be called when the keyboard is loaded, as it is used by keyboards
                 * to initialize a store value on the keyboard's script object.
                 */
                KeyboardInterface.prototype.loadStore = function (kbdName, storeName, dfltValue) {
                    this.resetContextCache();
                    if (this.variableStoreSerializer) {
                        var cValue = this.variableStoreSerializer.loadStore(kbdName, storeName);
                        return cValue[storeName] || dfltValue;
                    }
                    else {
                        return dfltValue;
                    }
                };
                /**
                 * Save an option store value to a cookie
                 *
                 * @param       {string}      storeName   store (option) name, embedded in cookie name
                 * @param       {string}      optValue    option value to save
                 * @return      {boolean}                 true if save successful
                 *
                 * Note that a keyboard will freely manipulate the value of its variable stores on the
                 * script object within its own code.  This function's use is merely to _persist_ that
                 * value across sessions, providing a custom user default for later uses of the keyboard.
                 */
                KeyboardInterface.prototype.saveStore = function (storeName, optValue) {
                    this.resetContextCache();
                    var kbd = this.activeKeyboard;
                    if (!kbd || typeof kbd.id == 'undefined' || kbd.id == '') {
                        return false;
                    }
                    // And the lookup under that entry looks for the value under the store name, again.
                    var valueObj = {};
                    valueObj[storeName] = optValue;
                    // Null-check in case of invocation during unit-test
                    if (this.ruleBehavior) {
                        this.ruleBehavior.saveStore[storeName] = valueObj;
                    }
                    else {
                        // We're in a unit-test environment, directly invoking this method from outside of a keyboard.
                        // In this case, we should immediately commit the change.
                        this.variableStoreSerializer.saveStore(this.activeKeyboard.id, storeName, valueObj);
                    }
                    return true;
                };
                KeyboardInterface.prototype.resetContextCache = function () {
                    this.cachedContext.reset();
                    this.cachedContextEx.reset();
                };
                KeyboardInterface.prototype.defaultBackspace = function (outputTarget) {
                    this.output(1, outputTarget, "");
                };
                /**
                 * Function     processKeystroke
                 * Scope        Private
                 * @param       {Object}        element     The page element receiving input
                 * @param       {Object}        keystroke   The input keystroke (with its properties) to be mapped by the keyboard.
                 * Description  Encapsulates calls to keyboard input processing.
                 * @returns     {number}        0 if no match is made, otherwise 1.
                 */
                KeyboardInterface.prototype.processKeystroke = function (outputTarget, keystroke) {
                    // Clear internal state tracking data from prior keystrokes.
                    if (!outputTarget) {
                        throw "No target specified for keyboard output!";
                    }
                    else if (!this.activeKeyboard) {
                        throw "No active keyboard for keystroke processing!";
                    }
                    outputTarget.invalidateSelection();
                    outputTarget.deadkeys().resetMatched(); // I3318
                    this.resetContextCache();
                    // Capture the initial state of the OutputTarget before any rules are matched.
                    var preInput = text.Mock.from(outputTarget);
                    // Capture the initial state of any variable stores
                    var cachedVariableStores = this.activeKeyboard.variableStores;
                    // Establishes the results object, allowing corresponding commands to set values here as appropriate.
                    this.ruleBehavior = new text.RuleBehavior();
                    // Ensure the settings are in place so that KIFS/ifState activates and deactivates
                    // the appropriate rule(s) for the modeled device.
                    this.activeDevice = keystroke.device;
                    // Calls the start-group of the active keyboard.
                    this.activeTargetOutput = outputTarget;
                    var matched = this.activeKeyboard.process(outputTarget, keystroke);
                    this.activeTargetOutput = null;
                    // Finalize the rule's results.
                    this.ruleBehavior.transcription = outputTarget.buildTranscriptionFrom(preInput, keystroke);
                    // We always backup the changes to variable stores to the RuleBehavior, to
                    // be applied during finalization, then restore them to the cached initial
                    // values to avoid side-effects with predictive text mocks.
                    this.ruleBehavior.variableStores = this.activeKeyboard.variableStores;
                    this.activeKeyboard.variableStores = cachedVariableStores;
                    // `matched` refers to whether or not the FINAL rule (from any group) matched, rather than
                    // whether or not ANY rule matched.  If the final rule doesn't match, we trigger the key's
                    // default behavior (if appropriate).
                    //
                    // See https://github.com/keymanapp/keyman/pull/4350#issuecomment-768753852
                    this.ruleBehavior.triggerKeyDefault = !matched;
                    // Clear our result-tracking variable to prevent any possible pollution for future processing.
                    var behavior = this.ruleBehavior;
                    this.ruleBehavior = null;
                    return behavior;
                };
                /**
                 * Applies the dictionary of variable store values to the active keyboard
                 *
                 * Has no effect on keyboards compiled with 14.0 or earlier; system store
                 * names are not exposed unless compiled with Developer 15.0 or later.
                 *
                 * @param stores A dictionary of stores which should be found in the
                 *               keyboard
                 */
                KeyboardInterface.prototype.applyVariableStores = function (stores) {
                    this.activeKeyboard.variableStores = stores;
                };
                /**
                 * Publishes the KeyboardInterface's shorthand API names.  As this assigns the current functions
                 * held by the longform versions, note that this should be called after replacing any of them via
                 * JS method extension.
                 *
                 * DOM-aware KeymanWeb should call this after its domKbdInterface.ts code is loaded, as it replaces
                 * a few.  (This is currently done within its kmwapi.ts.)
                 */
                KeyboardInterface.__publishShorthandAPI = function () {
                    // Keyboard callbacks
                    var prototype = this.prototype;
                    var exportKBCallback = function (miniName, longName) {
                        prototype[miniName] = prototype[longName];
                    };
                    exportKBCallback('KSF', 'saveFocus');
                    exportKBCallback('KBR', 'beepReset');
                    exportKBCallback('KT', 'insertText');
                    exportKBCallback('KR', 'registerKeyboard');
                    exportKBCallback('KRS', 'registerStub');
                    exportKBCallback('KC', 'context');
                    exportKBCallback('KN', 'nul');
                    exportKBCallback('KCM', 'contextMatch');
                    exportKBCallback('KFCM', 'fullContextMatch');
                    exportKBCallback('KIK', 'isKeypress');
                    exportKBCallback('KKM', 'keyMatch');
                    exportKBCallback('KSM', 'stateMatch');
                    exportKBCallback('KKI', 'keyInformation');
                    exportKBCallback('KDM', 'deadkeyMatch');
                    exportKBCallback('KB', 'beep');
                    exportKBCallback('KA', 'any');
                    exportKBCallback('KDC', 'deleteContext');
                    exportKBCallback('KO', 'output');
                    exportKBCallback('KDO', 'deadkeyOutput');
                    exportKBCallback('KCXO', 'contextExOutput');
                    exportKBCallback('KIO', 'indexOutput');
                    exportKBCallback('KIFS', 'ifStore');
                    exportKBCallback('KSETS', 'setStore');
                    exportKBCallback('KLOAD', 'loadStore');
                    exportKBCallback('KSAVE', 'saveStore');
                };
                KeyboardInterface.GLOBAL_NAME = 'KeymanWeb';
                KeyboardInterface.TSS_LAYER = 33;
                KeyboardInterface.TSS_PLATFORM = 31;
                return KeyboardInterface;
            }());
            text.KeyboardInterface = KeyboardInterface;
            (function () {
                // This will be the only call within the keyboard-processor module.
                KeyboardInterface.__publishShorthandAPI();
            }());
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/// <reference path="defaultLayouts.ts" />
/// <reference path="activeLayout.ts" />
/// <reference path="../text/kbdInterface.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var keyboards;
        (function (keyboards) {
            /**
             * Stores preprocessed properties of a keyboard for quick retrieval later.
             */
            var CacheTag = /** @class */ (function () {
                function CacheTag() {
                    this.stores = {};
                }
                return CacheTag;
            }());
            var LayoutState;
            (function (LayoutState) {
                LayoutState[LayoutState["NOT_LOADED"] = undefined] = "NOT_LOADED";
                LayoutState[LayoutState["POLYFILLED"] = 1] = "POLYFILLED";
                LayoutState[LayoutState["CALIBRATED"] = 2] = "CALIBRATED";
            })(LayoutState = keyboards.LayoutState || (keyboards.LayoutState = {}));
            ;
            /**
             * Acts as a wrapper class for Keyman keyboards compiled to JS, providing type information
             * and keyboard-centered functionality in an object-oriented way without modifying the
             * wrapped keyboard itself.
             */
            var Keyboard = /** @class */ (function () {
                function Keyboard(keyboardScript) {
                    if (keyboardScript) {
                        this.scriptObject = keyboardScript;
                    }
                    else {
                        this.scriptObject = Keyboard.DEFAULT_SCRIPT_OBJECT;
                    }
                    this.layoutStates = {};
                }
                /**
                 * Calls the keyboard's `gs` function, which represents the keyboard source's group(main).
                 */
                Keyboard.prototype.process = function (outputTarget, keystroke) {
                    return this.scriptObject['gs'](outputTarget, keystroke);
                };
                Object.defineProperty(Keyboard.prototype, "isHollow", {
                    get: function () {
                        return this.scriptObject == Keyboard.DEFAULT_SCRIPT_OBJECT;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "id", {
                    get: function () {
                        return this.scriptObject['KI'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "name", {
                    get: function () {
                        return this.scriptObject['KN'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "variableStores", {
                    /**
                     * Cache variable store values
                     *
                     * Primarily used for predictive text to prevent variable store
                     * values from being changed in 'fat finger' processing.
                     *
                     * KVS is available in keyboards compiled with Keyman Developer 15
                     * and later versions. See #2924.
                     *
                     * @returns an object with each property referencing a variable store
                     */
                    get: function () {
                        var storeNames = this.scriptObject['KVS'];
                        var values = {};
                        if (Array.isArray(storeNames)) {
                            for (var _i = 0, storeNames_1 = storeNames; _i < storeNames_1.length; _i++) {
                                var store = storeNames_1[_i];
                                values[store] = this.scriptObject[store];
                            }
                        }
                        return values;
                    },
                    /**
                     * Restore variable store values from cache
                     *
                     * KVS is available in keyboards compiled with Keyman Developer 15
                     * and later versions. See #2924.
                     *
                     * @param values  name-value pairs for each store value
                     */
                    set: function (values) {
                        var storeNames = this.scriptObject['KVS'];
                        if (Array.isArray(storeNames)) {
                            for (var _i = 0, storeNames_2 = storeNames; _i < storeNames_2.length; _i++) {
                                var store = storeNames_2[_i];
                                // If the value is not present in the cache, don't overwrite it;
                                // while this is not used in initial implementation, we could use
                                // it in future to update a single variable store value rather than
                                // the whole cache.
                                if (typeof values[store] == 'string') {
                                    this.scriptObject[store] = values[store];
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "_legacyLayoutSpec", {
                    // TODO:  Better typing.
                    get: function () {
                        return this.scriptObject['KV']; // used with buildDefaultLayout; layout must be constructed at runtime.
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "_layouts", {
                    // May return null if no layouts exist or have been initialized.
                    get: function () {
                        return this.scriptObject['KVKL']; // This one is compiled by Developer's visual keyboard layout editor.
                    },
                    set: function (value) {
                        this.scriptObject['KVKL'] = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "compilerVersion", {
                    get: function () {
                        return new keyman.utils.Version(this.scriptObject['KVER']);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isMnemonic", {
                    get: function () {
                        return !!this.scriptObject['KM'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "definesPositionalOrMnemonic", {
                    get: function () {
                        return typeof this.scriptObject['KM'] != 'undefined';
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "helpText", {
                    /**
                     * HTML help text, as specified by either the &kmw_helptext or &kmw_helpfile system stores.
                     *
                     * Reference: https://help.keyman.com/developer/language/reference/kmw_helptext,
                     *            https://help.keyman.com/developer/language/reference/kmw_helpfile
                     */
                    get: function () {
                        return this.scriptObject['KH'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "hasScript", {
                    /**
                     * Embedded JS script designed for use with a keyboard's HTML help text.  Always defined
                     * within the file referenced by &kmw_embedjs in a keyboard's source, though that file
                     * may also contain _other_ script definitions as well.  (`KHF` must be explicitly defined
                     * within that file.)
                     */
                    get: function () {
                        return !!this.scriptObject['KHF'];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Embeds a custom script for use by the OSK, which may be interactive (like with sil_euro_latin).
                 * Note:  this must be called AFTER any contents of `helpText` have been inserted into the DOM.
                 * (See sil_euro_latin's source -> sil_euro_latin_js.txt)
                 *
                 * Reference: https://help.keyman.com/developer/language/reference/kmw_embedjs
                 */
                Keyboard.prototype.embedScript = function (e) {
                    // e:  Expects the OSKManager's _Box element.  We don't add type info here b/c it would
                    //     reference the DOM.
                    this.scriptObject['KHF'](e);
                };
                Object.defineProperty(Keyboard.prototype, "oskStyling", {
                    get: function () {
                        return this.scriptObject['KCSS'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isCJK", {
                    /**
                     * true if this keyboard uses a (legacy) pick list (Chinese, Japanese, Korean, etc.)
                     *
                     * TODO:  Make a property on keyboards (say, `isPickList` / `KPL`) to signal this when we
                     *        get around to better, generalized picker-list support.
                     */
                    get: function () {
                        var lg;
                        if (typeof (this.scriptObject['KLC']) != 'undefined') {
                            lg = this.scriptObject['KLC'];
                        }
                        else if (typeof (this.scriptObject['LanguageCode']) != 'undefined') {
                            lg = this.scriptObject['LanguageCode'];
                        }
                        // While some of these aren't proper BCP-47 language codes, the CJK keyboards predate our use of BCP-47.
                        // So, we preserve the old ISO 639-3 codes, as that's what the keyboards are matching against.
                        return ((lg == 'cmn') || (lg == 'jpn') || (lg == 'kor'));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isRTL", {
                    get: function () {
                        return !!this.scriptObject['KRTL'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "modifierBitmask", {
                    /**
                     * Obtains the currently-active modifier bitmask for the active keyboard.
                     */
                    get: function () {
                        // NON_CHIRAL is the default bitmask if KMBM is not defined.
                        // We always need a bitmask to compare against, as seen in `isChiral`.
                        return this.scriptObject['KMBM'] || keyman.text.Codes.modifierBitmasks['NON_CHIRAL'];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "isChiral", {
                    get: function () {
                        return !!(this.modifierBitmask & keyman.text.Codes.modifierBitmasks['IS_CHIRAL']);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "desktopFont", {
                    get: function () {
                        if (this.scriptObject['KV']) {
                            return this.scriptObject['KV']['F'];
                        }
                        else {
                            return null;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "cacheTag", {
                    get: function () {
                        var tag = this.scriptObject['_kmw'];
                        if (!tag) {
                            tag = new CacheTag();
                            this.scriptObject['_kmw'] = tag;
                        }
                        return tag;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "explodedStores", {
                    get: function () {
                        return this.cacheTag.stores;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "emulatesAltGr", {
                    /**
                     * Signifies whether or not a layout or OSK should include AltGr / Right-alt emulation for this keyboard.
                     * @param   {Object=}   keyLabels
                     * @return  {boolean}
                     */
                    get: function () {
                        var modifierCodes = keyman.text.Codes.modifierCodes;
                        // If we're not chiral, we're not emulating.
                        if (!this.isChiral) {
                            return false;
                        }
                        if (this._legacyLayoutSpec == null) {
                            return false;
                        }
                        // Only exists in KMW 10.0+, but before that Web had no chirality support, so... return false.
                        var layers = this._legacyLayoutSpec['KLS'];
                        if (!layers) {
                            return false;
                        }
                        var emulationMask = modifierCodes['LCTRL'] | modifierCodes['LALT'];
                        var unshiftedEmulationLayer = layers[keyboards.Layouts.getLayerId(emulationMask)];
                        var shiftedEmulationLayer = layers[keyboards.Layouts.getLayerId(modifierCodes['SHIFT'] | emulationMask)];
                        // buildDefaultLayout ensures that these are aliased to the original modifier set being emulated.
                        // As a result, we can directly test for reference equality.
                        //
                        // This allows us to still return `true` after creating the layers for emulation; during keyboard
                        // construction, the two layers should be null for AltGr emulation to succeed.
                        if (unshiftedEmulationLayer != null &&
                            unshiftedEmulationLayer != layers[keyboards.Layouts.getLayerId(modifierCodes['RALT'])]) {
                            return false;
                        }
                        if (shiftedEmulationLayer != null &&
                            shiftedEmulationLayer != layers[keyboards.Layouts.getLayerId(modifierCodes['RALT'] | modifierCodes['SHIFT'])]) {
                            return false;
                        }
                        // It's technically possible for the OSK to not specify anything while allowing chiral input.  A last-ditch catch:
                        var bitmask = this.modifierBitmask;
                        if ((bitmask & emulationMask) != emulationMask) {
                            // At least one of the emulation modifiers is never used by the keyboard!  We can confirm everything's safe.
                            return true;
                        }
                        if (unshiftedEmulationLayer == null && shiftedEmulationLayer == null) {
                            // We've run out of things to go on; we can't detect if chiral AltGr emulation is intended or not.
                            // TODO:  handle this again!
                            // if(!osk.altGrWarning) {
                            //   console.warn("Could not detect if AltGr emulation is safe, but defaulting to active emulation!")
                            //   // Avoid spamming the console with warnings on every call of the method.
                            //   osk.altGrWarning = true;
                            // }
                            return true;
                        }
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard.prototype, "usesSupplementaryPlaneChars", {
                    get: function () {
                        var kbd = this.scriptObject;
                        // I3319 - SMP extension, I3363 (Build 301)
                        return kbd && ((kbd['KS'] && kbd['KS'] == 1) || kbd['KN'] == 'Hieroglyphic');
                    },
                    enumerable: true,
                    configurable: true
                });
                Keyboard.prototype.usesDesktopLayoutOnDevice = function (device) {
                    if (this.scriptObject['KVKL']) {
                        // A custom mobile layout is defined... but are we using it?
                        return device.formFactor == keyman.utils.FormFactor.Desktop;
                    }
                    else {
                        return true;
                    }
                };
                /**
                 * @param       {number}    _PCommand     event code (16,17,18) or 0
                 * @param       {Object}    _PTarget      target element
                 * @param       {number}    _PData        1 or 0
                 * Notifies keyboard of keystroke or other event
                 */
                Keyboard.prototype.notify = function (_PCommand, _PTarget, _PData) {
                    // Good example use case - the Japanese CJK-picker keyboard
                    if (typeof (this.scriptObject['KNS']) == 'function') {
                        this.scriptObject['KNS'](_PCommand, _PTarget, _PData);
                    }
                };
                Keyboard.prototype.findOrConstructLayout = function (formFactor) {
                    if (this._layouts) {
                        // Search for viable layouts.  `null` is allowed for desktop form factors when help text is available,
                        // so we check explicitly against `undefined`.
                        if (this._layouts[formFactor] !== undefined) {
                            return this._layouts[formFactor];
                        }
                        else if (formFactor == keyman.utils.FormFactor.Phone && this._layouts[keyman.utils.FormFactor.Tablet]) {
                            return this._layouts[keyman.utils.FormFactor.Phone] = this._layouts[keyman.utils.FormFactor.Tablet];
                        }
                        else if (formFactor == keyman.utils.FormFactor.Tablet && this._layouts[keyman.utils.FormFactor.Phone]) {
                            return this._layouts[keyman.utils.FormFactor.Tablet] = this._layouts[keyman.utils.FormFactor.Phone];
                        }
                    }
                    // No pre-built layout available; time to start constructing it via defaults.
                    // First, if we have non-default keys specified by the ['BK'] array, we've got
                    // enough to work with to build a default layout.
                    var rawSpecifications = null; // TODO:  better typing, same type as this._legacyLayoutSpec.
                    if (this._legacyLayoutSpec != null && this._legacyLayoutSpec['KLS']) { // KLS is only specified whenever there are non-default keys.
                        rawSpecifications = this._legacyLayoutSpec;
                    }
                    else if (this._legacyLayoutSpec != null && this._legacyLayoutSpec['BK'] != null) {
                        var keyCaps = this._legacyLayoutSpec['BK'];
                        for (var i = 0; i < keyCaps.length; i++) {
                            if (keyCaps[i].length > 0) {
                                rawSpecifications = this._legacyLayoutSpec;
                                break;
                            }
                        }
                    }
                    // If we don't have key definitions to use for a layout but also lack help text or are a touch-based layout,
                    // we make a default layout anyway.  We have to show display something usable.
                    if (!rawSpecifications && (this.helpText == '' || formFactor != keyman.utils.FormFactor.Desktop)) {
                        rawSpecifications = { 'F': 'Tahoma', 'BK': keyboards.Layouts.dfltText };
                    }
                    // Regardless of success, we'll want to initialize the field that backs the property;
                    // may as well cache the default layout we just built, or a 'null' if it shouldn't exist..
                    if (!this._layouts) {
                        this._layouts = {};
                    }
                    // Final check - do we construct a layout, or is this a case where helpText / insertHelpHTML should take over?
                    if (rawSpecifications) {
                        // Now to generate a layout from our raw specifications.
                        var layout = this._layouts[formFactor] = keyboards.Layouts.buildDefaultLayout(rawSpecifications, this, formFactor);
                        layout.isDefault = true;
                        return layout;
                    }
                    else {
                        // The fact that it doesn't exist will indicate that help text/HTML should be inserted instead.
                        this._layouts[formFactor] = null; // provides a cached value for the check at the top of this method.
                        return null;
                    }
                };
                /**
                 * Returns an ActiveLayout object representing the keyboard's layout for this form factor.  May return null if a custom desktop "help" OSK is defined, as with sil_euro_latin.
                 *
                 * In such cases, please use either `helpText` or `insertHelpHTML` instead.
                 * @param formFactor {string} The desired form factor for the layout.
                 */
                Keyboard.prototype.layout = function (formFactor) {
                    var rawLayout = this.findOrConstructLayout(formFactor);
                    if (rawLayout) {
                        // Prevents accidentally reprocessing layouts; it's a simple enough check.
                        if (this.layoutStates[formFactor] == LayoutState.NOT_LOADED) {
                            rawLayout = keyboards.ActiveLayout.polyfill(rawLayout, this, formFactor);
                            this.layoutStates[formFactor] = LayoutState.POLYFILLED;
                        }
                        return rawLayout;
                    }
                    else {
                        return null;
                    }
                };
                Keyboard.prototype.refreshLayouts = function () {
                    var formFactors = [keyman.utils.FormFactor.Desktop, keyman.utils.FormFactor.Phone, keyman.utils.FormFactor.Tablet];
                    var _this = this;
                    formFactors.forEach(function (form) {
                        // Currently doesn't work if we reset it to POLYFILLED, likely due to how 'calibration'
                        // currently works.
                        _this.layoutStates[form] = LayoutState.NOT_LOADED;
                    });
                };
                Keyboard.prototype.markLayoutCalibrated = function (formFactor) {
                    if (this.layoutStates[formFactor] != LayoutState.NOT_LOADED) {
                        this.layoutStates[formFactor] = LayoutState.CALIBRATED;
                    }
                };
                Keyboard.prototype.getLayoutState = function (formFactor) {
                    return this.layoutStates[formFactor];
                };
                Keyboard.DEFAULT_SCRIPT_OBJECT = {
                    'gs': function (outputTarget, keystroke) { return false; },
                    'KI': '',
                    'KN': '',
                    'KV': keyboards.Layouts.DEFAULT_RAW_SPEC,
                    'KM': 0 // May not be the best default, but this matches current behavior when there is no activeKeyboard.
                };
                return Keyboard;
            }());
            keyboards.Keyboard = Keyboard;
        })(keyboards = keyman.keyboards || (keyman.keyboards = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/***
   KeymanWeb 11.0
   Copyright 2019 SIL International
***/
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var KeyMap = /** @class */ (function () {
            function KeyMap() {
            }
            return KeyMap;
        }());
        var BrowserKeyMaps = /** @class */ (function () {
            function BrowserKeyMaps() {
                this.FF = new KeyMap();
                this.Safari = new KeyMap();
                this.Opera = new KeyMap();
                // All three have been around since at least May 2014 / FF 29.
                // It'd hard to find precise history, but at least that much has been confirmed.
                // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode, on Feb 26 2021.
                this.FF['k61'] = 187; // =   // FF 2.0
                this.FF['k59'] = 186; // ;
                this.FF['k173'] = 189; // -/_
            }
            return BrowserKeyMaps;
        }());
        var LanguageKeyMaps = /** @class */ (function () {
            // // Here are some old legacy definitions that were no longer referenced but are likely related:
            // static _BaseLayoutEuro: {[code: string]: string} = {
            //   'se': '\u00a71234567890+´~~~QWERTYUIOP\u00c5\u00a8\'~~~ASDFGHJKL\u00d6\u00c4~~~~~<ZXCVBNM,.-~~~~~ ',  // Swedish
            //   'uk': '`1234567890-=~~~QWERTYUIOP[]#~~~ASDFGHJKL;\'~~~~~\\ZXCVBNM,./~~~~~ ' // UK
            function LanguageKeyMaps() {
                /* I732 START - 13/03/2007 MCD: Swedish: Start mapping of keystroke to US keyboard #2 */
                // Swedish key map
                this['se'] = new KeyMap();
                this['se']['k220'] = 192; // `
                this['se']['k187'] = 189; // -
                this['se']['k219'] = 187; // =
                this['se']['k221'] = 219; // [
                this['se']['k186'] = 221; // ]
                this['se']['k191'] = 220; // \
                this['se']['k192'] = 186; // ;
                this['se']['k189'] = 191; // /
                this['uk'] = new KeyMap(); // I1299
                this['uk']['k223'] = 192; // // ` U+00AC (logical not) =>  ` ~
                this['uk']['k192'] = 222; // ' @  =>  ' "
                this['uk']['k222'] = 226; // # ~  => K_oE2     // I1504 - UK keyboard mixup #, \
                this['uk']['k220'] = 220; // \ |  => \ |       // I1504 - UK keyboard mixup #, \
            }
            return LanguageKeyMaps;
        }());
        var KeyMapping = /** @class */ (function () {
            function KeyMapping() {
                // Do not construct this class.
            }
            KeyMapping._usCodeInit = function () {
                var s0 = new KeyMap(), s1 = new KeyMap();
                s0['k192'] = 96;
                s0['k49'] = 49;
                s0['k50'] = 50;
                s0['k51'] = 51;
                s0['k52'] = 52;
                s0['k53'] = 53;
                s0['k54'] = 54;
                s0['k55'] = 55;
                s0['k56'] = 56;
                s0['k57'] = 57;
                s0['k48'] = 48;
                s0['k189'] = 45;
                s0['k187'] = 61;
                s0['k81'] = 113;
                s0['k87'] = 119;
                s0['k69'] = 101;
                s0['k82'] = 114;
                s0['k84'] = 116;
                s0['k89'] = 121;
                s0['k85'] = 117;
                s0['k73'] = 105;
                s0['k79'] = 111;
                s0['k80'] = 112;
                s0['k219'] = 91;
                s0['k221'] = 93;
                s0['k220'] = 92;
                s0['k65'] = 97;
                s0['k83'] = 115;
                s0['k68'] = 100;
                s0['k70'] = 102;
                s0['k71'] = 103;
                s0['k72'] = 104;
                s0['k74'] = 106;
                s0['k75'] = 107;
                s0['k76'] = 108;
                s0['k186'] = 59;
                s0['k222'] = 39;
                s0['k90'] = 122;
                s0['k88'] = 120;
                s0['k67'] = 99;
                s0['k86'] = 118;
                s0['k66'] = 98;
                s0['k78'] = 110;
                s0['k77'] = 109;
                s0['k188'] = 44;
                s0['k190'] = 46;
                s0['k191'] = 47;
                s1['k192'] = 126;
                s1['k49'] = 33;
                s1['k50'] = 64;
                s1['k51'] = 35;
                s1['k52'] = 36;
                s1['k53'] = 37;
                s1['k54'] = 94;
                s1['k55'] = 38;
                s1['k56'] = 42;
                s1['k57'] = 40;
                s1['k48'] = 41;
                s1['k189'] = 95;
                s1['k187'] = 43;
                s1['k81'] = 81;
                s1['k87'] = 87;
                s1['k69'] = 69;
                s1['k82'] = 82;
                s1['k84'] = 84;
                s1['k89'] = 89;
                s1['k85'] = 85;
                s1['k73'] = 73;
                s1['k79'] = 79;
                s1['k80'] = 80;
                s1['k219'] = 123;
                s1['k221'] = 125;
                s1['k220'] = 124;
                s1['k65'] = 65;
                s1['k83'] = 83;
                s1['k68'] = 68;
                s1['k70'] = 70;
                s1['k71'] = 71;
                s1['k72'] = 72;
                s1['k74'] = 74;
                s1['k75'] = 75;
                s1['k76'] = 76;
                s1['k186'] = 58;
                s1['k222'] = 34;
                s1['k90'] = 90;
                s1['k88'] = 88;
                s1['k67'] = 67;
                s1['k86'] = 86;
                s1['k66'] = 66;
                s1['k78'] = 78;
                s1['k77'] = 77;
                s1['k188'] = 60;
                s1['k190'] = 62;
                s1['k191'] = 63;
                KeyMapping._usCharCodes = [s0, s1];
            };
            /**
             * Function     _USKeyCodeToCharCode
             * Scope        Private
             * @param       {Event}     Levent      KMW event object
             * @return      {number}                Character code
             * Description Translate keyboard codes to standard US layout codes
             */
            KeyMapping._USKeyCodeToCharCode = function (Levent) {
                return KeyMapping.usCharCodes[Levent.Lmodifiers & 0x10 ? 1 : 0]['k' + Levent.Lcode];
            };
            ;
            Object.defineProperty(KeyMapping, "usCharCodes", {
                get: function () {
                    if (!KeyMapping._usCharCodes) {
                        KeyMapping._usCodeInit();
                    }
                    return KeyMapping._usCharCodes;
                },
                enumerable: true,
                configurable: true
            });
            KeyMapping.browserMap = new BrowserKeyMaps();
            KeyMapping.languageMap = new LanguageKeyMaps();
            return KeyMapping;
        }());
        keyman.KeyMapping = KeyMapping;
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Establishes key-code definitions.
/// <reference path="codes.ts" />
// Defines our generalized "KeyEvent" class.
/// <reference path="keyEvent.ts" />
// Defines the RuleBehavior keyboard-processing return object.
/// <reference path="ruleBehavior.ts" />
// Defines default key handling behaviors.
/// <reference path="defaultOutput.ts" />
// Defines the keyboard wrapper object.
/// <reference path="../keyboards/keyboard.ts" />
// Defines built-in keymapping.
/// <reference path="keyMapping.ts" />
// Also relies on @keymanapp/web-utils, which is included via tsconfig.json.
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var KeyboardProcessor = /** @class */ (function () {
                function KeyboardProcessor(options) {
                    // Tracks the simulated value for supported state keys, allowing the OSK to mirror a physical keyboard for them.
                    // Using the exact keyCode name from the Codes definitions will allow for certain optimizations elsewhere in the code.
                    this.stateKeys = {
                        "K_CAPS": false,
                        "K_NUMLOCK": false,
                        "K_SCROLL": false
                    };
                    // Tracks the most recent modifier state information in order to quickly detect changes
                    // in keyboard state not otherwise captured by the hosting page in the browser.
                    // Needed for AltGr simulation.
                    this.modStateFlags = 0;
                    if (!options) {
                        options = KeyboardProcessor.DEFAULT_OPTIONS;
                    }
                    this.baseLayout = options.baseLayout || KeyboardProcessor.DEFAULT_OPTIONS.baseLayout;
                    this.keyboardInterface = new text.KeyboardInterface(options.variableStoreSerializer);
                    this.installInterface();
                }
                KeyboardProcessor.prototype.installInterface = function () {
                    // We must ensure that the keyboard can find the API functions at the expected place.
                    var globalThis = keyman.utils.getGlobalObject();
                    globalThis[text.KeyboardInterface.GLOBAL_NAME] = this.keyboardInterface;
                    // Ensure that the active keyboard is set on the keyboard interface object.
                    if (this.activeKeyboard) {
                        this.keyboardInterface.activeKeyboard = this.activeKeyboard;
                    }
                };
                Object.defineProperty(KeyboardProcessor.prototype, "activeKeyboard", {
                    get: function () {
                        return this.keyboardInterface.activeKeyboard;
                    },
                    set: function (keyboard) {
                        this.keyboardInterface.activeKeyboard = keyboard;
                        // All old deadkeys and keyboard-specific cache should immediately be invalidated
                        // on a keyboard change.
                        this.resetContext();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardProcessor.prototype, "layerStore", {
                    get: function () {
                        return this.keyboardInterface.systemStores[text.KeyboardInterface.TSS_LAYER];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardProcessor.prototype, "layerId", {
                    get: function () {
                        return this.layerStore.value;
                    },
                    // Note:  will trigger an 'event' callback designed to notify the OSK of layer changes.
                    set: function (value) {
                        this.layerStore.set(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Get the default RuleBehavior for the specified key, attempting to mimic standard browser defaults
                 * where and when appropriate.
                 *
                 * @param   {object}  Lkc           The pre-analyzed KeyEvent object
                 * @param   {boolean} outputTarget  The OutputTarget receiving the KeyEvent
                 * @return  {string}
                 */
                KeyboardProcessor.prototype.defaultRuleBehavior = function (Lkc, outputTarget) {
                    var preInput = text.Mock.from(outputTarget);
                    var ruleBehavior = new text.RuleBehavior();
                    var matched = false;
                    var char = '';
                    var special;
                    if (Lkc.isSynthetic || outputTarget.isSynthetic) {
                        matched = true; // All the conditions below result in matches until the final else, which restores the expected default
                        // if no match occurs.
                        if (text.DefaultOutput.isCommand(Lkc)) {
                            // Note this in the rule behavior, return successfully.  We'll consider applying it later.
                            ruleBehavior.triggersDefaultCommand = true;
                            // We'd rather let the browser handle these keys, but we're using emulated keystrokes, forcing KMW
                            // to emulate default behavior here.
                        }
                        else if ((special = text.DefaultOutput.forSpecialEmulation(Lkc)) != null) {
                            switch (special) {
                                case text.EmulationKeystrokes.Backspace:
                                    this.keyboardInterface.defaultBackspace(outputTarget);
                                    break;
                                case text.EmulationKeystrokes.Enter:
                                    outputTarget.handleNewlineAtCaret();
                                    break;
                                // case '\u007f': // K_DEL
                                // // For (possible) future implementation.
                                // // Would recommend (conceptually) equaling K_RIGHT + K_BKSP, the former of which would technically be a 'command'.
                                default:
                                    // In case we extend the allowed set, but forget to implement its handling case above.
                                    ruleBehavior.errorLog = "Unexpected 'special emulation' character (\\u" + special.kmwCharCodeAt(0).toString(16) + ") went unhandled!";
                            }
                        }
                        else {
                            // Back to the standard default, pending normal matching.
                            matched = false;
                        }
                    }
                    var isMnemonic = this.activeKeyboard && this.activeKeyboard.isMnemonic;
                    if (!matched) {
                        if ((char = text.DefaultOutput.forAny(Lkc, isMnemonic)) != null) {
                            special = text.DefaultOutput.forSpecialEmulation(Lkc);
                            if (special == text.EmulationKeystrokes.Backspace) {
                                // A browser's default backspace may fail to delete both parts of an SMP character.
                                this.keyboardInterface.defaultBackspace(outputTarget);
                            }
                            else if (special || text.DefaultOutput.isCommand(Lkc)) { // Filters out 'commands' like TAB.
                                // We only do the "for special emulation" cases under the condition above... aside from backspace
                                // Let the browser handle those.
                                return null;
                            }
                            else {
                                this.keyboardInterface.output(0, outputTarget, char);
                            }
                        }
                        else {
                            // No match, no default RuleBehavior.
                            return null;
                        }
                    }
                    // Shortcut things immediately if there were issues generating this rule behavior.
                    if (ruleBehavior.errorLog) {
                        return ruleBehavior;
                    }
                    var transcription = outputTarget.buildTranscriptionFrom(preInput, Lkc);
                    ruleBehavior.transcription = transcription;
                    return ruleBehavior;
                };
                KeyboardProcessor.prototype.setSyntheticEventDefaults = function (Lkc) {
                    // Set the flags for the state keys.
                    Lkc.Lstates |= this.stateKeys['K_CAPS'] ? text.Codes.modifierCodes['CAPS'] : text.Codes.modifierCodes['NO_CAPS'];
                    Lkc.Lstates |= this.stateKeys['K_NUMLOCK'] ? text.Codes.modifierCodes['NUM_LOCK'] : text.Codes.modifierCodes['NO_NUM_LOCK'];
                    Lkc.Lstates |= this.stateKeys['K_SCROLL'] ? text.Codes.modifierCodes['SCROLL_LOCK'] : text.Codes.modifierCodes['NO_SCROLL_LOCK'];
                    // Set LisVirtualKey to false to ensure that nomatch rule does fire for U_xxxx keys
                    if (Lkc.kName && Lkc.kName.substr(0, 2) == 'U_') {
                        Lkc.LisVirtualKey = false;
                    }
                    // Get code for non-physical keys (T_KOKAI, U_05AB etc)
                    if (typeof Lkc.Lcode == 'undefined') {
                        Lkc.Lcode = this.getVKDictionaryCode(Lkc.kName); // Updated for Build 347
                        if (!Lkc.Lcode) {
                            // Special case for U_xxxx keys. This vk code will never be used
                            // in a keyboard, so we use this to ensure that keystroke processing
                            // occurs for the key.
                            Lkc.Lcode = 1;
                        }
                    }
                    // Handles modifier states when the OSK is emulating rightalt through the leftctrl-leftalt layer.
                    if ((Lkc.Lmodifiers & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM'] && this.activeKeyboard.emulatesAltGr) {
                        Lkc.Lmodifiers &= ~text.Codes.modifierBitmasks['ALT_GR_SIM'];
                        Lkc.Lmodifiers |= text.Codes.modifierCodes['RALT'];
                    }
                };
                KeyboardProcessor.prototype.processKeystroke = function (keyEvent, outputTarget) {
                    var matchBehavior;
                    // Pass this key code and state to the keyboard program
                    if (this.activeKeyboard && keyEvent.Lcode != 0) {
                        /*
                         * The `this.installInterface()` call is insurance against something I've seen in unit tests when things break a bit.
                         *
                         * Currently, when a KMW shutdown doesn't go through properly or completely, sometimes we end up with parallel
                         * versions of KMW running, and an old, partially-shutdown one will "snipe" a command meant for the most-recent
                         * one's test. So, installing here ensures that the active Processor has its matching KeyboardInterface ready,
                         * even should that occur.
                         */
                        this.installInterface();
                        matchBehavior = this.keyboardInterface.processKeystroke(outputTarget, keyEvent);
                    }
                    if (!matchBehavior || matchBehavior.triggerKeyDefault) {
                        // Restore the virtual key code if a mnemonic keyboard is being used
                        // If no vkCode value was stored, maintain the original Lcode value.
                        keyEvent.Lcode = keyEvent.vkCode || keyEvent.Lcode;
                        // Handle unmapped keys, including special keys
                        // The following is physical layout dependent, so should be avoided if possible.  All keys should be mapped.
                        this.keyboardInterface.activeTargetOutput = outputTarget;
                        // Match against the 'default keyboard' - rules to mimic the default string output when typing in a browser.
                        // Many keyboards rely upon these 'implied rules'.
                        var defaultBehavior = this.defaultRuleBehavior(keyEvent, outputTarget);
                        if (defaultBehavior) {
                            if (!matchBehavior) {
                                matchBehavior = defaultBehavior;
                            }
                            else {
                                matchBehavior.mergeInDefaults(defaultBehavior);
                            }
                            matchBehavior.triggerKeyDefault = false; // We've triggered it successfully.
                        } // If null, we must rely on something else (like the browser, in DOM-aware code) to fulfill the default.
                        this.keyboardInterface.activeTargetOutput = null;
                    }
                    return matchBehavior;
                };
                // FIXME:  makes some bad assumptions.
                KeyboardProcessor.setMnemonicCode = function (Lkc, shifted, capsActive) {
                    // K_SPACE is not handled by defaultKeyOutput for physical keystrokes unless using touch-aliased elements.
                    // It's also a "exception required, March 2013" for clickKey, so at least they both have this requirement.
                    if (Lkc.Lcode != text.Codes.keyCodes['K_SPACE']) {
                        // So long as the key name isn't prefixed with 'U_', we'll get a default mapping based on the Lcode value.
                        // We need to determine the mnemonic base character - for example, SHIFT + K_PERIOD needs to map to '>'.
                        var mappingEvent = new text.KeyEvent();
                        for (var key in Lkc) {
                            mappingEvent[key] = Lkc[key];
                        }
                        // To facilitate storing relevant commands, we should probably reverse-lookup
                        // the actual keyname instead.
                        mappingEvent.kName = 'K_xxxx';
                        mappingEvent.Lmodifiers = (shifted ? 0x10 : 0); // mnemonic lookups only exist for default & shift layers.
                        var mappedChar = text.DefaultOutput.forAny(mappingEvent, true);
                        /* First, save a backup of the original code.  This one won't needlessly trigger keyboard
                         * rules, but allows us to replicate/emulate commands after rule processing if needed.
                         * (Like backspaces)
                         */
                        Lkc.vkCode = Lkc.Lcode;
                        if (mappedChar) {
                            // Will return 96 for 'a', which is a keycode corresponding to Codes.keyCodes('K_NP1') - a numpad key.
                            // That stated, we're in mnemonic mode - this keyboard's rules are based on the char codes.
                            Lkc.Lcode = mappedChar.charCodeAt(0);
                        }
                        else {
                            // Don't let command-type keys (like K_DEL, which will output '.' otherwise!)
                            // trigger keyboard rules.
                            //
                            // However, DO make sure modifier keys pass through safely.
                            // (https://github.com/keymanapp/keyman/issues/3744)
                            if (!KeyboardProcessor.isModifier(Lkc)) {
                                delete Lkc.Lcode;
                            }
                        }
                    }
                    if (capsActive) {
                        // TODO:  Needs fixing - does not properly mirror physical keystrokes, as Lcode range 96-111 corresponds
                        // to numpad keys!  (Physical keyboard section has its own issues here.)
                        if ((Lkc.Lcode >= 65 && Lkc.Lcode <= 90) /* 'A' - 'Z' */ || (Lkc.Lcode >= 97 && Lkc.Lcode <= 122) /* 'a' - 'z' */) {
                            Lkc.Lmodifiers ^= 0x10; // Flip the 'shifted' bit, so it'll act as the opposite key.
                            Lkc.Lcode ^= 0x20; // Flips the 'upper' vs 'lower' bit for the base 'a'-'z' ASCII alphabetics.
                        }
                    }
                };
                /**
                 * Get modifier key state from layer id
                 *
                 * @param       {string}      layerId       layer id (e.g. ctrlshift)
                 * @return      {number}                    modifier key state (desktop keyboards)
                 */
                KeyboardProcessor.getModifierState = function (layerId) {
                    var modifier = 0;
                    if (layerId.indexOf('shift') >= 0) {
                        modifier |= text.Codes.modifierCodes['SHIFT'];
                    }
                    // The chiral checks must not be directly exclusive due each other to visual OSK feedback.
                    var ctrlMatched = false;
                    if (layerId.indexOf('leftctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['LCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('rightctrl') >= 0) {
                        modifier |= text.Codes.modifierCodes['RCTRL'];
                        ctrlMatched = true;
                    }
                    if (layerId.indexOf('ctrl') >= 0 && !ctrlMatched) {
                        modifier |= text.Codes.modifierCodes['CTRL'];
                    }
                    var altMatched = false;
                    if (layerId.indexOf('leftalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['LALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('rightalt') >= 0) {
                        modifier |= text.Codes.modifierCodes['RALT'];
                        altMatched = true;
                    }
                    if (layerId.indexOf('alt') >= 0 && !altMatched) {
                        modifier |= text.Codes.modifierCodes['ALT'];
                    }
                    return modifier;
                };
                /**
                 * @summary Look up a custom virtual key code in the virtual key code dictionary KVKD.  On first run, will build the dictionary.
                 *
                 * `VKDictionary` is constructed from the keyboard's `KVKD` member. This list is constructed
                 * at compile-time and is a list of 'additional' virtual key codes, starting at 256 (i.e.
                 * outside the range of standard virtual key codes). These additional codes are both
                 * `[T_xxx]` and `[U_xxxx]` custom key codes from the Keyman keyboard language. However,
                 * `[U_xxxx]` keys only generate an entry in `KVKD` if there is a corresponding rule that
                 * is associated with them in the keyboard rules. If the `[U_xxxx]` key code is only
                 * referenced as the id of a key in the touch layout, then it does not get an entry in
                 * the `KVKD` property.
                 *
                 * @private
                 * @param       {string}      keyName   custom virtual key code to lookup in the dictionary
                 * @return      {number}                key code > 255 on success, or 0 if not found
                 */
                KeyboardProcessor.prototype.getVKDictionaryCode = function (keyName) {
                    var activeKeyboard = this.activeKeyboard;
                    if (!activeKeyboard.scriptObject['VKDictionary']) {
                        var a = [];
                        if (typeof activeKeyboard.scriptObject['KVKD'] == 'string') {
                            // Build the VK dictionary
                            // TODO: Move the dictionary build into the compiler -- so compiler generates code such as following.
                            // Makes the VKDictionary member unnecessary.
                            //       this.KVKD={"K_ABC":256,"K_DEF":257,...};
                            var s = activeKeyboard.scriptObject['KVKD'].split(' ');
                            for (var i = 0; i < s.length; i++) {
                                a[s[i].toUpperCase()] = i + 256; // We force upper-case since virtual keys should be case-insensitive.
                            }
                        }
                        activeKeyboard.scriptObject['VKDictionary'] = a;
                    }
                    var res = activeKeyboard.scriptObject['VKDictionary'][keyName.toUpperCase()];
                    return res ? res : 0;
                };
                /**
                 * Function     _UpdateVKShift
                 * Scope        Private
                 * @param       {Object}            e     OSK event
                 * @param       {number}            v     keyboard shift state
                 * @param       {(boolean|number)}  d     set (1) or clear(0) shift state bits
                 * @return      {boolean}                 Always true
                 * Description  Updates the current shift state within KMW, updating the OSK's visualization thereof.
                 */
                KeyboardProcessor.prototype._UpdateVKShift = function (e, v, d) {
                    var keyShiftState = 0, lockStates = 0, i;
                    var lockNames = ['CAPS', 'NUM_LOCK', 'SCROLL_LOCK'];
                    var lockKeys = ['K_CAPS', 'K_NUMLOCK', 'K_SCROLL'];
                    if (!this.activeKeyboard) {
                        return true;
                    }
                    if (e) {
                        // read shift states from Pevent
                        keyShiftState = e.Lmodifiers;
                        lockStates = e.Lstates;
                        // Are we simulating AltGr?  If it's a simulation and not real, time to un-simulate for the OSK.
                        if (this.activeKeyboard.isChiral && (this.activeKeyboard.emulatesAltGr) &&
                            (this.modStateFlags & text.Codes.modifierBitmasks['ALT_GR_SIM']) == text.Codes.modifierBitmasks['ALT_GR_SIM']) {
                            keyShiftState |= text.Codes.modifierBitmasks['ALT_GR_SIM'];
                            keyShiftState &= ~text.Codes.modifierCodes['RALT'];
                        }
                        for (i = 0; i < lockNames.length; i++) {
                            if (lockStates & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = !!(lockStates & text.Codes.modifierCodes[lockNames[i]]);
                            }
                        }
                    }
                    else if (d) {
                        keyShiftState |= v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = true;
                            }
                        }
                    }
                    else {
                        keyShiftState &= ~v;
                        for (i = 0; i < lockNames.length; i++) {
                            if (v & text.Codes.stateBitmasks[lockNames[i]]) {
                                this.stateKeys[lockKeys[i]] = false;
                            }
                        }
                    }
                    this.updateStates();
                    if (this.activeKeyboard.isMnemonic && this.stateKeys['K_CAPS']) {
                        // Modifier keypresses doesn't trigger mnemonic manipulation of modifier state.
                        // Only an output key does; active use of Caps will also flip the SHIFT flag.
                        if (!e || !KeyboardProcessor.isModifier(e)) {
                            // Mnemonic keystrokes manipulate the SHIFT property based on CAPS state.
                            // We need to unflip them when tracking the OSK layer.
                            keyShiftState ^= text.Codes.modifierCodes['SHIFT'];
                        }
                    }
                    this.layerId = this.getLayerId(keyShiftState);
                    return true;
                };
                KeyboardProcessor.prototype.updateStates = function () {
                    var lockNames = ['CAPS', 'NUM_LOCK', 'SCROLL_LOCK'];
                    var lockKeys = ['K_CAPS', 'K_NUMLOCK', 'K_SCROLL'];
                    for (var i = 0; i < lockKeys.length; i++) {
                        var key = lockKeys[i];
                        var flag = this.stateKeys[key];
                        var onBit = lockNames[i];
                        var offBit = 'NO_' + lockNames[i];
                        // Ensures that the current mod-state info properly matches the currently-simulated
                        // state key states.
                        if (flag) {
                            this.modStateFlags |= text.Codes.modifierCodes[onBit];
                            this.modStateFlags &= ~text.Codes.modifierCodes[offBit];
                        }
                        else {
                            this.modStateFlags &= ~text.Codes.modifierCodes[onBit];
                            this.modStateFlags |= text.Codes.modifierCodes[offBit];
                        }
                    }
                };
                KeyboardProcessor.prototype.getLayerId = function (modifier) {
                    return keyman.keyboards.Layouts.getLayerId(modifier);
                };
                /**
                 * Select the OSK's next keyboard layer based upon layer switching keys as a default
                 * The next layer will be determined from the key name unless otherwise specifed
                 *
                 *  @param  {string}                    keyName     key identifier
                 *  @param  {number|string|undefined}   nextLayerIn optional next layer identifier
                 *  @return {boolean}                               return true if keyboard layer changed
                 */
                KeyboardProcessor.prototype.selectLayer = function (keyEvent, fromNameOnly) {
                    if (fromNameOnly === void 0) { fromNameOnly = false; }
                    var keyName = keyEvent.kName;
                    var nextLayer = fromNameOnly ? null : keyEvent.kNextLayer;
                    var isChiral = this.activeKeyboard && this.activeKeyboard.isChiral;
                    // Layer must be identified by name, not number (27/08/2015)
                    if (typeof nextLayer == 'number') {
                        nextLayer = this.getLayerId(nextLayer * 0x10);
                    }
                    // Identify next layer, if required by key
                    if (!nextLayer) {
                        switch (keyName) {
                            case 'K_LSHIFT':
                            case 'K_RSHIFT':
                            case 'K_SHIFT':
                                nextLayer = 'shift';
                                break;
                            case 'K_LCONTROL':
                            case 'K_LCTRL':
                                if (isChiral) {
                                    nextLayer = 'leftctrl';
                                    break;
                                }
                            case 'K_RCONTROL':
                            case 'K_RCTRL':
                                if (isChiral) {
                                    nextLayer = 'rightctrl';
                                    break;
                                }
                            case 'K_CTRL':
                                nextLayer = 'ctrl';
                                break;
                            case 'K_LMENU':
                            case 'K_LALT':
                                if (isChiral) {
                                    nextLayer = 'leftalt';
                                    break;
                                }
                            case 'K_RMENU':
                            case 'K_RALT':
                                if (isChiral) {
                                    nextLayer = 'rightalt';
                                    break;
                                }
                            case 'K_ALT':
                                nextLayer = 'alt';
                                break;
                            case 'K_ALTGR':
                                if (isChiral) {
                                    nextLayer = 'leftctrl-rightalt';
                                }
                                else {
                                    nextLayer = 'ctrl-alt';
                                }
                                break;
                            case 'K_CURRENCIES':
                            case 'K_NUMERALS':
                            case 'K_SHIFTED':
                            case 'K_UPPER':
                            case 'K_LOWER':
                            case 'K_SYMBOLS':
                                nextLayer = 'default';
                                break;
                        }
                    }
                    // If no key corresponding to a layer transition is pressed, maintain the current layer.
                    if (!nextLayer) {
                        return false;
                    }
                    // Change layer and refresh OSK
                    this.updateLayer(keyEvent, nextLayer);
                    return true;
                };
                /**
                 * Sets the new layer id, allowing for toggling shift/ctrl/alt while preserving the remainder
                 * of the modifiers represented by the current layer id (where applicable)
                 *
                 * @param       {string}      id      layer id (e.g. ctrlshift)
                 */
                KeyboardProcessor.prototype.updateLayer = function (keyEvent, id) {
                    var activeLayer = this.layerId;
                    var s = activeLayer;
                    // Do not change layer unless needed (27/08/2015)
                    if (id == activeLayer && keyEvent.device.formFactor != keyman.utils.FormFactor.Desktop) {
                        return false;
                    }
                    var idx = id;
                    var i;
                    if (keyEvent.device.formFactor == keyman.utils.FormFactor.Desktop) {
                        // Need to test if target layer is a standard layer (based on the plain 'default')
                        var replacements = ['leftctrl', 'rightctrl', 'ctrl', 'leftalt', 'rightalt', 'alt', 'shift'];
                        for (i = 0; i < replacements.length; i++) {
                            // Don't forget to remove the kebab-case hyphens!
                            idx = idx.replace(replacements[i] + '-', '');
                            idx = idx.replace(replacements[i], '');
                        }
                        // If we are presently on the default layer, drop the 'default' and go straight to the shifted mode.
                        // If on a common symbolic layer, drop out of symbolic mode and go straight to the shifted mode.
                        if (activeLayer == 'default' || activeLayer == 'numeric' || activeLayer == 'symbol' || activeLayer == 'currency' || idx != '') {
                            s = id;
                        }
                        // Otherwise, we are based upon a layer that accepts modifier variations.
                        // Modify the layer according to the current state and key pressed.
                        //
                        // TODO:  Consider:  should this ever be allowed for a base layer other than 'default'?  If not,
                        // if(idx == '') with accompanying if-else structural shift would be a far better test here.
                        else {
                            // Save our current modifier state.
                            var modifier = KeyboardProcessor.getModifierState(s);
                            // Strip down to the base modifiable layer.
                            for (i = 0; i < replacements.length; i++) {
                                // Don't forget to remove the kebab-case hyphens!
                                s = s.replace(replacements[i] + '-', '');
                                s = s.replace(replacements[i], '');
                            }
                            // Toggle the modifier represented by our input argument.
                            switch (id) {
                                case 'shift':
                                    modifier ^= text.Codes.modifierCodes['SHIFT'];
                                    break;
                                case 'leftctrl':
                                    modifier ^= text.Codes.modifierCodes['LCTRL'];
                                    break;
                                case 'rightctrl':
                                    modifier ^= text.Codes.modifierCodes['RCTRL'];
                                    break;
                                case 'ctrl':
                                    modifier ^= text.Codes.modifierCodes['CTRL'];
                                    break;
                                case 'leftalt':
                                    modifier ^= text.Codes.modifierCodes['LALT'];
                                    break;
                                case 'rightalt':
                                    modifier ^= text.Codes.modifierCodes['RALT'];
                                    break;
                                case 'alt':
                                    modifier ^= text.Codes.modifierCodes['ALT'];
                                    break;
                                default:
                                    s = id;
                            }
                            // Combine our base modifiable layer and attach the new modifier variation info to obtain our destination layer.
                            if (s != 'default') {
                                if (s == '') {
                                    s = this.getLayerId(modifier);
                                }
                                else {
                                    s = this.getLayerId(modifier) + '-' + s;
                                }
                            }
                        }
                        if (s == '') {
                            s = 'default';
                        }
                    }
                    else {
                        // Mobile form-factor.  Either the layout is specified by a keyboard developer with direct layer name references
                        // or all layers are accessed via subkey of a single layer-shifting key - no need for modifier-combining logic.
                        s = id;
                    }
                    var layout = this.activeKeyboard.layout(keyEvent.device.formFactor);
                    if (layout.getLayer(s)) {
                        this.layerId = s;
                    }
                    else {
                        this.layerId = 'default';
                    }
                    var baseModifierState = text.KeyboardProcessor.getModifierState(this.layerId);
                    this.modStateFlags = baseModifierState | keyEvent.Lstates;
                };
                KeyboardProcessor.isModifier = function (Levent) {
                    switch (Levent.Lcode) {
                        case 16: //"K_SHIFT":16,"K_CONTROL":17,"K_ALT":18
                        case 17:
                        case 18:
                        case 20: //"K_CAPS":20, "K_NUMLOCK":144,"K_SCROLL":145
                        case 144:
                        case 145:
                            return true;
                        default:
                            return false;
                    }
                };
                // Returns true if the key event is a modifier press, allowing keyPress to return selectively
                // in those cases.
                KeyboardProcessor.prototype.doModifierPress = function (Levent, outputTarget, isKeyDown) {
                    if (!this.activeKeyboard) {
                        return false;
                    }
                    if (Levent.Lcode == 8) {
                        // I3318 (always clear deadkeys after backspace)
                        outputTarget.deadkeys().clear();
                    }
                    else if (KeyboardProcessor.isModifier(Levent)) {
                        // For eventual integration - we bypass an OSK update for physical keystrokes when in touch mode.
                        this.activeKeyboard.notify(Levent.Lcode, outputTarget, isKeyDown ? 1 : 0);
                        if (!Levent.device.touchable) {
                            return this._UpdateVKShift(Levent, Levent.Lcode - 15, 1); // I2187
                        }
                        else {
                            return true;
                        }
                    }
                    if (Levent.LmodifierChange) {
                        this.activeKeyboard.notify(0, outputTarget, 1);
                        this._UpdateVKShift(Levent, 0, 1);
                    }
                    // No modifier keypresses detected.
                    return false;
                };
                KeyboardProcessor.prototype.resetContext = function () {
                    this.layerId = 'default';
                    this.keyboardInterface.resetContextCache();
                    this._UpdateVKShift(null, 15, 0);
                };
                ;
                KeyboardProcessor.prototype.setNumericLayer = function (device) {
                    if (this.activeKeyboard) {
                        var layout = this.activeKeyboard.layout(device.formFactor);
                        if (layout.getLayer('numeric')) {
                            this.layerId = 'numeric';
                        }
                    }
                };
                ;
                KeyboardProcessor.DEFAULT_OPTIONS = {
                    baseLayout: 'us'
                };
                return KeyboardProcessor;
            }());
            text.KeyboardProcessor = KeyboardProcessor;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
(function () {
    var ns = com.keyman.text;
    // Let the Keyboard Processor be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ns.KeyboardProcessor;
        //@ts-ignore
        ns.KeyboardProcessor.com = com; // Export the root namespace so that all KeyboardProcessor classes are accessible by unit tests.
    }
}());
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var ContextWindow = /** @class */ (function () {
                function ContextWindow(mock, config) {
                    this.left = mock.getTextBeforeCaret();
                    this.startOfBuffer = this.left._kmwLength() <= config.leftContextCodePoints;
                    if (!this.startOfBuffer) {
                        // Our custom substring version will return the last n characters if param #1 is given -n.
                        this.left = this.left._kmwSubstr(-config.leftContextCodePoints);
                    }
                    this.right = mock.getTextAfterCaret();
                    this.endOfBuffer = this.right._kmwLength() <= config.rightContextCodePoints;
                    if (!this.endOfBuffer) {
                        this.right = this.right._kmwSubstr(0, config.rightContextCodePoints);
                    }
                }
                ContextWindow.prototype.toMock = function () {
                    var caretPos = this.left._kmwLength();
                    return new text.Mock(this.left + (this.right || ""), caretPos);
                };
                // Used to limit the range of context replicated for use of keyboard rules within
                // the engine, as used for fat-finger prep / `Alternate` generation.
                ContextWindow.ENGINE_RULE_WINDOW = {
                    leftContextCodePoints: 64,
                    rightContextCodePoints: 32
                };
                return ContextWindow;
            }());
            text.ContextWindow = ContextWindow;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
(function (e, t) { if (typeof define === "function" && define.amd) {
    define(t);
}
else if (typeof exports === "object") {
    module.exports = t();
}
else {
    e.returnExports = t();
} })(this, function () {
    "use strict";
    var e = Function.call.bind(Function.apply);
    var t = Function.call.bind(Function.call);
    var r = Array.isArray;
    var n = Object.keys;
    var o = function notThunker(t) { return function notThunk() { return !e(t, this, arguments); }; };
    var i = function (e) { try {
        e();
        return false;
    }
    catch (t) {
        return true;
    } };
    var a = function valueOrFalseIfThrows(e) { try {
        return e();
    }
    catch (t) {
        return false;
    } };
    var u = o(i);
    var f = function () { return !i(function () { return Object.defineProperty({}, "x", { get: function () { } }); }); };
    var s = !!Object.defineProperty && f();
    var c = function foo() { }.name === "foo";
    var l = Function.call.bind(Array.prototype.forEach);
    var p = Function.call.bind(Array.prototype.reduce);
    var v = Function.call.bind(Array.prototype.filter);
    var y = Function.call.bind(Array.prototype.some);
    var h = function (e, t, r, n) { if (!n && t in e) {
        return;
    } if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: false, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var b = function (e, t, r) { l(n(t), function (n) { var o = t[n]; h(e, n, o, !!r); }); };
    var g = Function.call.bind(Object.prototype.toString);
    var d = typeof /abc/ === "function" ? function IsCallableSlow(e) { return typeof e === "function" && g(e) === "[object Function]"; } : function IsCallableFast(e) { return typeof e === "function"; };
    var m = { getter: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } Object.defineProperty(e, t, { configurable: true, enumerable: false, get: r }); }, proxy: function (e, t, r) { if (!s) {
            throw new TypeError("getters require true ES5 support");
        } var n = Object.getOwnPropertyDescriptor(e, t); Object.defineProperty(r, t, { configurable: n.configurable, enumerable: n.enumerable, get: function getKey() { return e[t]; }, set: function setKey(r) { e[t] = r; } }); }, redefine: function (e, t, r) { if (s) {
            var n = Object.getOwnPropertyDescriptor(e, t);
            n.value = r;
            Object.defineProperty(e, t, n);
        }
        else {
            e[t] = r;
        } }, defineByDescriptor: function (e, t, r) { if (s) {
            Object.defineProperty(e, t, r);
        }
        else if ("value" in r) {
            e[t] = r.value;
        } }, preserveToString: function (e, t) { if (t && d(t.toString)) {
            h(e, "toString", t.toString.bind(t), true);
        } } };
    var O = Object.create || function (e, t) { var r = function Prototype() { }; r.prototype = e; var o = new r; if (typeof t !== "undefined") {
        n(t).forEach(function (e) { m.defineByDescriptor(o, e, t[e]); });
    } return o; };
    var w = function (e, t) { if (!Object.setPrototypeOf) {
        return false;
    } return a(function () { var r = function Subclass(t) { var r = new e(t); Object.setPrototypeOf(r, Subclass.prototype); return r; }; Object.setPrototypeOf(r, e); r.prototype = O(e.prototype, { constructor: { value: r } }); return t(r); }); };
    var j = function () { if (typeof self !== "undefined") {
        return self;
    } if (typeof window !== "undefined") {
        return window;
    } if (typeof global !== "undefined") {
        return global;
    } throw new Error("unable to locate global object"); };
    var S = j();
    var T = S.isFinite;
    var I = Function.call.bind(String.prototype.indexOf);
    var E = Function.apply.bind(Array.prototype.indexOf);
    var P = Function.call.bind(Array.prototype.concat);
    var C = Function.call.bind(String.prototype.slice);
    var M = Function.call.bind(Array.prototype.push);
    var x = Function.apply.bind(Array.prototype.push);
    var N = Function.call.bind(Array.prototype.shift);
    var A = Math.max;
    var R = Math.min;
    var _ = Math.floor;
    var k = Math.abs;
    var L = Math.exp;
    var F = Math.log;
    var D = Math.sqrt;
    var z = Function.call.bind(Object.prototype.hasOwnProperty);
    var q;
    var W = function () { };
    var G = S.Map;
    var H = G && G.prototype["delete"];
    var V = G && G.prototype.get;
    var B = G && G.prototype.has;
    var U = G && G.prototype.set;
    var $ = S.Symbol || {};
    var J = $.species || "@@species";
    var X = Number.isNaN || function isNaN(e) { return e !== e; };
    var K = Number.isFinite || function isFinite(e) { return typeof e === "number" && T(e); };
    var Z = d(Math.sign) ? Math.sign : function sign(e) { var t = Number(e); if (t === 0) {
        return t;
    } if (X(t)) {
        return t;
    } return t < 0 ? -1 : 1; };
    var Y = function log1p(e) { var t = Number(e); if (t < -1 || X(t)) {
        return NaN;
    } if (t === 0 || t === Infinity) {
        return t;
    } if (t === -1) {
        return -Infinity;
    } return 1 + t - 1 === 0 ? t : t * (F(1 + t) / (1 + t - 1)); };
    var Q = function isArguments(e) { return g(e) === "[object Arguments]"; };
    var ee = function isArguments(e) { return e !== null && typeof e === "object" && typeof e.length === "number" && e.length >= 0 && g(e) !== "[object Array]" && g(e.callee) === "[object Function]"; };
    var te = Q(arguments) ? Q : ee;
    var re = { primitive: function (e) { return e === null || typeof e !== "function" && typeof e !== "object"; }, string: function (e) { return g(e) === "[object String]"; }, regex: function (e) { return g(e) === "[object RegExp]"; }, symbol: function (e) { return typeof S.Symbol === "function" && typeof e === "symbol"; } };
    var ne = function overrideNative(e, t, r) { var n = e[t]; h(e, t, r, true); m.preserveToString(e[t], n); };
    var oe = typeof $ === "function" && typeof $["for"] === "function" && re.symbol($());
    var ie = re.symbol($.iterator) ? $.iterator : "_es6-shim iterator_";
    if (S.Set && typeof (new S.Set)["@@iterator"] === "function") {
        ie = "@@iterator";
    }
    if (!S.Reflect) {
        h(S, "Reflect", {}, true);
    }
    var ae = S.Reflect;
    var ue = String;
    var fe = typeof document === "undefined" || !document ? null : document.all;
    var se = fe == null ? function isNullOrUndefined(e) { return e == null; } : function isNullOrUndefinedAndNotDocumentAll(e) { return e == null && e !== fe; };
    var ce = { Call: function Call(t, r) { var n = arguments.length > 2 ? arguments[2] : []; if (!ce.IsCallable(t)) {
            throw new TypeError(t + " is not a function");
        } return e(t, r, n); }, RequireObjectCoercible: function (e, t) { if (se(e)) {
            throw new TypeError(t || "Cannot call method on " + e);
        } return e; }, TypeIsObject: function (e) { if (e === void 0 || e === null || e === true || e === false) {
            return false;
        } return typeof e === "function" || typeof e === "object" || e === fe; }, ToObject: function (e, t) { return Object(ce.RequireObjectCoercible(e, t)); }, IsCallable: d, IsConstructor: function (e) { return ce.IsCallable(e); }, ToInt32: function (e) { return ce.ToNumber(e) >> 0; }, ToUint32: function (e) { return ce.ToNumber(e) >>> 0; }, ToNumber: function (e) { if (g(e) === "[object Symbol]") {
            throw new TypeError("Cannot convert a Symbol value to a number");
        } return +e; }, ToInteger: function (e) { var t = ce.ToNumber(e); if (X(t)) {
            return 0;
        } if (t === 0 || !K(t)) {
            return t;
        } return (t > 0 ? 1 : -1) * _(k(t)); }, ToLength: function (e) { var t = ce.ToInteger(e); if (t <= 0) {
            return 0;
        } if (t > Number.MAX_SAFE_INTEGER) {
            return Number.MAX_SAFE_INTEGER;
        } return t; }, SameValue: function (e, t) { if (e === t) {
            if (e === 0) {
                return 1 / e === 1 / t;
            }
            return true;
        } return X(e) && X(t); }, SameValueZero: function (e, t) { return e === t || X(e) && X(t); }, IsIterable: function (e) { return ce.TypeIsObject(e) && (typeof e[ie] !== "undefined" || te(e)); }, GetIterator: function (e) { if (te(e)) {
            return new q(e, "value");
        } var t = ce.GetMethod(e, ie); if (!ce.IsCallable(t)) {
            throw new TypeError("value is not an iterable");
        } var r = ce.Call(t, e); if (!ce.TypeIsObject(r)) {
            throw new TypeError("bad iterator");
        } return r; }, GetMethod: function (e, t) { var r = ce.ToObject(e)[t]; if (se(r)) {
            return void 0;
        } if (!ce.IsCallable(r)) {
            throw new TypeError("Method not callable: " + t);
        } return r; }, IteratorComplete: function (e) { return !!e.done; }, IteratorClose: function (e, t) { var r = ce.GetMethod(e, "return"); if (r === void 0) {
            return;
        } var n, o; try {
            n = ce.Call(r, e);
        }
        catch (i) {
            o = i;
        } if (t) {
            return;
        } if (o) {
            throw o;
        } if (!ce.TypeIsObject(n)) {
            throw new TypeError("Iterator's return method returned a non-object.");
        } }, IteratorNext: function (e) { var t = arguments.length > 1 ? e.next(arguments[1]) : e.next(); if (!ce.TypeIsObject(t)) {
            throw new TypeError("bad iterator");
        } return t; }, IteratorStep: function (e) { var t = ce.IteratorNext(e); var r = ce.IteratorComplete(t); return r ? false : t; }, Construct: function (e, t, r, n) { var o = typeof r === "undefined" ? e : r; if (!n && ae.construct) {
            return ae.construct(e, t, o);
        } var i = o.prototype; if (!ce.TypeIsObject(i)) {
            i = Object.prototype;
        } var a = O(i); var u = ce.Call(e, a, t); return ce.TypeIsObject(u) ? u : a; }, SpeciesConstructor: function (e, t) { var r = e.constructor; if (r === void 0) {
            return t;
        } if (!ce.TypeIsObject(r)) {
            throw new TypeError("Bad constructor");
        } var n = r[J]; if (se(n)) {
            return t;
        } if (!ce.IsConstructor(n)) {
            throw new TypeError("Bad @@species");
        } return n; }, CreateHTML: function (e, t, r, n) { var o = ce.ToString(e); var i = "<" + t; if (r !== "") {
            var a = ce.ToString(n);
            var u = a.replace(/"/g, "&quot;");
            i += " " + r + '="' + u + '"';
        } var f = i + ">"; var s = f + o; return s + "</" + t + ">"; }, IsRegExp: function IsRegExp(e) { if (!ce.TypeIsObject(e)) {
            return false;
        } var t = e[$.match]; if (typeof t !== "undefined") {
            return !!t;
        } return re.regex(e); }, ToString: function ToString(e) { return ue(e); } };
    if (s && oe) {
        var le = function defineWellKnownSymbol(e) { if (re.symbol($[e])) {
            return $[e];
        } var t = $["for"]("Symbol." + e); Object.defineProperty($, e, { configurable: false, enumerable: false, writable: false, value: t }); return t; };
        if (!re.symbol($.search)) {
            var pe = le("search");
            var ve = String.prototype.search;
            h(RegExp.prototype, pe, function search(e) { return ce.Call(ve, e, [this]); });
            var ye = function search(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, pe);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(ve, t, [ce.ToString(e)]); };
            ne(String.prototype, "search", ye);
        }
        if (!re.symbol($.replace)) {
            var he = le("replace");
            var be = String.prototype.replace;
            h(RegExp.prototype, he, function replace(e, t) { return ce.Call(be, e, [this, t]); });
            var ge = function replace(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, he);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(be, r, [ce.ToString(e), t]); };
            ne(String.prototype, "replace", ge);
        }
        if (!re.symbol($.split)) {
            var de = le("split");
            var me = String.prototype.split;
            h(RegExp.prototype, de, function split(e, t) { return ce.Call(me, e, [this, t]); });
            var Oe = function split(e, t) { var r = ce.RequireObjectCoercible(this); if (!se(e)) {
                var n = ce.GetMethod(e, de);
                if (typeof n !== "undefined") {
                    return ce.Call(n, e, [r, t]);
                }
            } return ce.Call(me, r, [ce.ToString(e), t]); };
            ne(String.prototype, "split", Oe);
        }
        var we = re.symbol($.match);
        var je = we && function () { var e = {}; e[$.match] = function () { return 42; }; return "a".match(e) !== 42; }();
        if (!we || je) {
            var Se = le("match");
            var Te = String.prototype.match;
            h(RegExp.prototype, Se, function match(e) { return ce.Call(Te, e, [this]); });
            var Ie = function match(e) { var t = ce.RequireObjectCoercible(this); if (!se(e)) {
                var r = ce.GetMethod(e, Se);
                if (typeof r !== "undefined") {
                    return ce.Call(r, e, [t]);
                }
            } return ce.Call(Te, t, [ce.ToString(e)]); };
            ne(String.prototype, "match", Ie);
        }
    }
    var Ee = function wrapConstructor(e, t, r) { m.preserveToString(t, e); if (Object.setPrototypeOf) {
        Object.setPrototypeOf(e, t);
    } if (s) {
        l(Object.getOwnPropertyNames(e), function (n) { if (n in W || r[n]) {
            return;
        } m.proxy(e, n, t); });
    }
    else {
        l(Object.keys(e), function (n) { if (n in W || r[n]) {
            return;
        } t[n] = e[n]; });
    } t.prototype = e.prototype; m.redefine(e.prototype, "constructor", t); };
    var Pe = function () { return this; };
    var Ce = function (e) { if (s && !z(e, J)) {
        m.getter(e, J, Pe);
    } };
    var Me = function (e, t) { var r = t || function iterator() { return this; }; h(e, ie, r); if (!e[ie] && re.symbol(ie)) {
        e[ie] = r;
    } };
    var xe = function createDataProperty(e, t, r) { if (s) {
        Object.defineProperty(e, t, { configurable: true, enumerable: true, writable: true, value: r });
    }
    else {
        e[t] = r;
    } };
    var Ne = function createDataPropertyOrThrow(e, t, r) { xe(e, t, r); if (!ce.SameValue(e[t], r)) {
        throw new TypeError("property is nonconfigurable");
    } };
    var Ae = function (e, t, r, n) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("Constructor requires `new`: " + t.name);
    } var o = t.prototype; if (!ce.TypeIsObject(o)) {
        o = r;
    } var i = O(o); for (var a in n) {
        if (z(n, a)) {
            var u = n[a];
            h(i, a, u, true);
        }
    } return i; };
    if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
        var Re = String.fromCodePoint;
        ne(String, "fromCodePoint", function fromCodePoint(e) { return ce.Call(Re, this, arguments); });
    }
    var _e = { fromCodePoint: function fromCodePoint(e) { var t = []; var r; for (var n = 0, o = arguments.length; n < o; n++) {
            r = Number(arguments[n]);
            if (!ce.SameValue(r, ce.ToInteger(r)) || r < 0 || r > 1114111) {
                throw new RangeError("Invalid code point " + r);
            }
            if (r < 65536) {
                M(t, String.fromCharCode(r));
            }
            else {
                r -= 65536;
                M(t, String.fromCharCode((r >> 10) + 55296));
                M(t, String.fromCharCode(r % 1024 + 56320));
            }
        } return t.join(""); }, raw: function raw(e) { var t = ce.ToObject(e, "bad callSite"); var r = ce.ToObject(t.raw, "bad raw value"); var n = r.length; var o = ce.ToLength(n); if (o <= 0) {
            return "";
        } var i = []; var a = 0; var u, f, s, c; while (a < o) {
            u = ce.ToString(a);
            s = ce.ToString(r[u]);
            M(i, s);
            if (a + 1 >= o) {
                break;
            }
            f = a + 1 < arguments.length ? arguments[a + 1] : "";
            c = ce.ToString(f);
            M(i, c);
            a += 1;
        } return i.join(""); } };
    if (String.raw && String.raw({ raw: { 0: "x", 1: "y", length: 2 } }) !== "xy") {
        ne(String, "raw", _e.raw);
    }
    b(String, _e);
    var ke = function repeat(e, t) { if (t < 1) {
        return "";
    } if (t % 2) {
        return repeat(e, t - 1) + e;
    } var r = repeat(e, t / 2); return r + r; };
    var Le = Infinity;
    var Fe = { repeat: function repeat(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); if (r < 0 || r >= Le) {
            throw new RangeError("repeat count must be less than infinity and not overflow maximum string size");
        } return ke(t, r); }, startsWith: function startsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "startsWith" with a regex');
        } var r = ce.ToString(e); var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = A(ce.ToInteger(n), 0); return C(t, o, o + r.length) === r; }, endsWith: function endsWith(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); if (ce.IsRegExp(e)) {
            throw new TypeError('Cannot call method "endsWith" with a regex');
        } var r = ce.ToString(e); var n = t.length; var o; if (arguments.length > 1) {
            o = arguments[1];
        } var i = typeof o === "undefined" ? n : ce.ToInteger(o); var a = R(A(i, 0), n); return C(t, a - r.length, a) === r; }, includes: function includes(e) { if (ce.IsRegExp(e)) {
            throw new TypeError('"includes" does not accept a RegExp');
        } var t = ce.ToString(e); var r; if (arguments.length > 1) {
            r = arguments[1];
        } return I(this, t, r) !== -1; }, codePointAt: function codePointAt(e) { var t = ce.ToString(ce.RequireObjectCoercible(this)); var r = ce.ToInteger(e); var n = t.length; if (r >= 0 && r < n) {
            var o = t.charCodeAt(r);
            var i = r + 1 === n;
            if (o < 55296 || o > 56319 || i) {
                return o;
            }
            var a = t.charCodeAt(r + 1);
            if (a < 56320 || a > 57343) {
                return o;
            }
            return (o - 55296) * 1024 + (a - 56320) + 65536;
        } } };
    if (String.prototype.includes && "a".includes("a", Infinity) !== false) {
        ne(String.prototype, "includes", Fe.includes);
    }
    if (String.prototype.startsWith && String.prototype.endsWith) {
        var De = i(function () { return "/a/".startsWith(/a/); });
        var ze = a(function () { return "abc".startsWith("a", Infinity) === false; });
        if (!De || !ze) {
            ne(String.prototype, "startsWith", Fe.startsWith);
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
    }
    if (oe) {
        var qe = a(function () { var e = /a/; e[$.match] = false; return "/a/".startsWith(e); });
        if (!qe) {
            ne(String.prototype, "startsWith", Fe.startsWith);
        }
        var We = a(function () { var e = /a/; e[$.match] = false; return "/a/".endsWith(e); });
        if (!We) {
            ne(String.prototype, "endsWith", Fe.endsWith);
        }
        var Ge = a(function () { var e = /a/; e[$.match] = false; return "/a/".includes(e); });
        if (!Ge) {
            ne(String.prototype, "includes", Fe.includes);
        }
    }
    b(String.prototype, Fe);
    var He = ["\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003", "\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028", "\u2029\ufeff"].join("");
    var Ve = new RegExp("(^[" + He + "]+)|([" + He + "]+$)", "g");
    var Be = function trim() { return ce.ToString(ce.RequireObjectCoercible(this)).replace(Ve, ""); };
    var Ue = ["\x85", "\u200b", "\ufffe"].join("");
    var $e = new RegExp("[" + Ue + "]", "g");
    var Je = /^[-+]0x[0-9a-f]+$/i;
    var Xe = Ue.trim().length !== Ue.length;
    h(String.prototype, "trim", Be, Xe);
    var Ke = function (e) { return { value: e, done: arguments.length === 0 }; };
    var Ze = function (e) { ce.RequireObjectCoercible(e); this._s = ce.ToString(e); this._i = 0; };
    Ze.prototype.next = function () { var e = this._s; var t = this._i; if (typeof e === "undefined" || t >= e.length) {
        this._s = void 0;
        return Ke();
    } var r = e.charCodeAt(t); var n, o; if (r < 55296 || r > 56319 || t + 1 === e.length) {
        o = 1;
    }
    else {
        n = e.charCodeAt(t + 1);
        o = n < 56320 || n > 57343 ? 1 : 2;
    } this._i = t + o; return Ke(e.substr(t, o)); };
    Me(Ze.prototype);
    Me(String.prototype, function () { return new Ze(this); });
    var Ye = { from: function from(e) { var r = this; var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o, i; if (typeof n === "undefined") {
            o = false;
        }
        else {
            if (!ce.IsCallable(n)) {
                throw new TypeError("Array.from: when provided, the second argument must be a function");
            }
            if (arguments.length > 2) {
                i = arguments[2];
            }
            o = true;
        } var a = typeof (te(e) || ce.GetMethod(e, ie)) !== "undefined"; var u, f, s; if (a) {
            f = ce.IsConstructor(r) ? Object(new r) : [];
            var c = ce.GetIterator(e);
            var l, p;
            s = 0;
            while (true) {
                l = ce.IteratorStep(c);
                if (l === false) {
                    break;
                }
                p = l.value;
                try {
                    if (o) {
                        p = typeof i === "undefined" ? n(p, s) : t(n, i, p, s);
                    }
                    f[s] = p;
                }
                catch (v) {
                    ce.IteratorClose(c, true);
                    throw v;
                }
                s += 1;
            }
            u = s;
        }
        else {
            var y = ce.ToObject(e);
            u = ce.ToLength(y.length);
            f = ce.IsConstructor(r) ? Object(new r(u)) : new Array(u);
            var h;
            for (s = 0; s < u; ++s) {
                h = y[s];
                if (o) {
                    h = typeof i === "undefined" ? n(h, s) : t(n, i, h, s);
                }
                Ne(f, s, h);
            }
        } f.length = u; return f; }, of: function of() { var e = arguments.length; var t = this; var n = r(t) || !ce.IsCallable(t) ? new Array(e) : ce.Construct(t, [e]); for (var o = 0; o < e; ++o) {
            Ne(n, o, arguments[o]);
        } n.length = e; return n; } };
    b(Array, Ye);
    Ce(Array);
    q = function (e, t) { this.i = 0; this.array = e; this.kind = t; };
    b(q.prototype, { next: function () { var e = this.i; var t = this.array; if (!(this instanceof q)) {
            throw new TypeError("Not an ArrayIterator");
        } if (typeof t !== "undefined") {
            var r = ce.ToLength(t.length);
            for (; e < r; e++) {
                var n = this.kind;
                var o;
                if (n === "key") {
                    o = e;
                }
                else if (n === "value") {
                    o = t[e];
                }
                else if (n === "entry") {
                    o = [e, t[e]];
                }
                this.i = e + 1;
                return Ke(o);
            }
        } this.array = void 0; return Ke(); } });
    Me(q.prototype);
    var Qe = Array.of === Ye.of || function () { var e = function Foo(e) { this.length = e; }; e.prototype = []; var t = Array.of.apply(e, [1, 2]); return t instanceof e && t.length === 2; }();
    if (!Qe) {
        ne(Array, "of", Ye.of);
    }
    var et = { copyWithin: function copyWithin(e, t) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); var o = ce.ToInteger(e); var i = ce.ToInteger(t); var a = o < 0 ? A(n + o, 0) : R(o, n); var u = i < 0 ? A(n + i, 0) : R(i, n); var f; if (arguments.length > 2) {
            f = arguments[2];
        } var s = typeof f === "undefined" ? n : ce.ToInteger(f); var c = s < 0 ? A(n + s, 0) : R(s, n); var l = R(c - u, n - a); var p = 1; if (u < a && a < u + l) {
            p = -1;
            u += l - 1;
            a += l - 1;
        } while (l > 0) {
            if (u in r) {
                r[a] = r[u];
            }
            else {
                delete r[a];
            }
            u += p;
            a += p;
            l -= 1;
        } return r; }, fill: function fill(e) { var t; if (arguments.length > 1) {
            t = arguments[1];
        } var r; if (arguments.length > 2) {
            r = arguments[2];
        } var n = ce.ToObject(this); var o = ce.ToLength(n.length); t = ce.ToInteger(typeof t === "undefined" ? 0 : t); r = ce.ToInteger(typeof r === "undefined" ? o : r); var i = t < 0 ? A(o + t, 0) : R(t, o); var a = r < 0 ? o + r : r; for (var u = i; u < o && u < a; ++u) {
            n[u] = e;
        } return n; }, find: function find(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#find: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0, a; i < n; i++) {
            a = r[i];
            if (o) {
                if (t(e, o, a, i, r)) {
                    return a;
                }
            }
            else if (e(a, i, r)) {
                return a;
            }
        } }, findIndex: function findIndex(e) { var r = ce.ToObject(this); var n = ce.ToLength(r.length); if (!ce.IsCallable(e)) {
            throw new TypeError("Array#findIndex: predicate must be a function");
        } var o = arguments.length > 1 ? arguments[1] : null; for (var i = 0; i < n; i++) {
            if (o) {
                if (t(e, o, r[i], i, r)) {
                    return i;
                }
            }
            else if (e(r[i], i, r)) {
                return i;
            }
        } return -1; }, keys: function keys() { return new q(this, "key"); }, values: function values() { return new q(this, "value"); }, entries: function entries() { return new q(this, "entry"); } };
    if (Array.prototype.keys && !ce.IsCallable([1].keys().next)) {
        delete Array.prototype.keys;
    }
    if (Array.prototype.entries && !ce.IsCallable([1].entries().next)) {
        delete Array.prototype.entries;
    }
    if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[ie]) {
        b(Array.prototype, { values: Array.prototype[ie] });
        if (re.symbol($.unscopables)) {
            Array.prototype[$.unscopables].values = true;
        }
    }
    if (c && Array.prototype.values && Array.prototype.values.name !== "values") {
        var tt = Array.prototype.values;
        ne(Array.prototype, "values", function values() { return ce.Call(tt, this, arguments); });
        h(Array.prototype, ie, Array.prototype.values, true);
    }
    b(Array.prototype, et);
    if (1 / [true].indexOf(true, -0) < 0) {
        h(Array.prototype, "indexOf", function indexOf(e) { var t = E(this, arguments); if (t === 0 && 1 / t < 0) {
            return 0;
        } return t; }, true);
    }
    Me(Array.prototype, function () { return this.values(); });
    if (Object.getPrototypeOf) {
        Me(Object.getPrototypeOf([].values()));
    }
    var rt = function () { return a(function () { return Array.from({ length: -1 }).length === 0; }); }();
    var nt = function () { var e = Array.from([0].entries()); return e.length === 1 && r(e[0]) && e[0][0] === 0 && e[0][1] === 0; }();
    if (!rt || !nt) {
        ne(Array, "from", Ye.from);
    }
    var ot = function () { return a(function () { return Array.from([0], void 0); }); }();
    if (!ot) {
        var it = Array.from;
        ne(Array, "from", function from(e) { if (arguments.length > 1 && typeof arguments[1] !== "undefined") {
            return ce.Call(it, this, arguments);
        }
        else {
            return t(it, this, e);
        } });
    }
    var at = -(Math.pow(2, 32) - 1);
    var ut = function (e, r) { var n = { length: at }; n[r ? (n.length >>> 0) - 1 : 0] = true; return a(function () { t(e, n, function () { throw new RangeError("should not reach here"); }, []); return true; }); };
    if (!ut(Array.prototype.forEach)) {
        var ft = Array.prototype.forEach;
        ne(Array.prototype, "forEach", function forEach(e) { return ce.Call(ft, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.map)) {
        var st = Array.prototype.map;
        ne(Array.prototype, "map", function map(e) { return ce.Call(st, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.filter)) {
        var ct = Array.prototype.filter;
        ne(Array.prototype, "filter", function filter(e) { return ce.Call(ct, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.some)) {
        var lt = Array.prototype.some;
        ne(Array.prototype, "some", function some(e) { return ce.Call(lt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.every)) {
        var pt = Array.prototype.every;
        ne(Array.prototype, "every", function every(e) { return ce.Call(pt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduce)) {
        var vt = Array.prototype.reduce;
        ne(Array.prototype, "reduce", function reduce(e) { return ce.Call(vt, this.length >= 0 ? this : [], arguments); }, true);
    }
    if (!ut(Array.prototype.reduceRight, true)) {
        var yt = Array.prototype.reduceRight;
        ne(Array.prototype, "reduceRight", function reduceRight(e) { return ce.Call(yt, this.length >= 0 ? this : [], arguments); }, true);
    }
    var ht = Number("0o10") !== 8;
    var bt = Number("0b10") !== 2;
    var gt = y(Ue, function (e) { return Number(e + 0 + e) === 0; });
    if (ht || bt || gt) {
        var dt = Number;
        var mt = /^0b[01]+$/i;
        var Ot = /^0o[0-7]+$/i;
        var wt = mt.test.bind(mt);
        var jt = Ot.test.bind(Ot);
        var St = function (e) { var t; if (typeof e.valueOf === "function") {
            t = e.valueOf();
            if (re.primitive(t)) {
                return t;
            }
        } if (typeof e.toString === "function") {
            t = e.toString();
            if (re.primitive(t)) {
                return t;
            }
        } throw new TypeError("No default value"); };
        var Tt = $e.test.bind($e);
        var It = Je.test.bind(Je);
        var Et = function () { var e = function Number(t) { var r; if (arguments.length > 0) {
            r = re.primitive(t) ? t : St(t, "number");
        }
        else {
            r = 0;
        } if (typeof r === "string") {
            r = ce.Call(Be, r);
            if (wt(r)) {
                r = parseInt(C(r, 2), 2);
            }
            else if (jt(r)) {
                r = parseInt(C(r, 2), 8);
            }
            else if (Tt(r) || It(r)) {
                r = NaN;
            }
        } var n = this; var o = a(function () { dt.prototype.valueOf.call(n); return true; }); if (n instanceof e && !o) {
            return new dt(r);
        } return dt(r); }; return e; }();
        Ee(dt, Et, {});
        b(Et, { NaN: dt.NaN, MAX_VALUE: dt.MAX_VALUE, MIN_VALUE: dt.MIN_VALUE, NEGATIVE_INFINITY: dt.NEGATIVE_INFINITY, POSITIVE_INFINITY: dt.POSITIVE_INFINITY });
        Number = Et;
        m.redefine(S, "Number", Et);
    }
    var Pt = Math.pow(2, 53) - 1;
    b(Number, { MAX_SAFE_INTEGER: Pt, MIN_SAFE_INTEGER: -Pt, EPSILON: 2.220446049250313e-16, parseInt: S.parseInt, parseFloat: S.parseFloat, isFinite: K, isInteger: function isInteger(e) { return K(e) && ce.ToInteger(e) === e; }, isSafeInteger: function isSafeInteger(e) { return Number.isInteger(e) && k(e) <= Number.MAX_SAFE_INTEGER; }, isNaN: X });
    h(Number, "parseInt", S.parseInt, Number.parseInt !== S.parseInt);
    if ([, 1].find(function () { return true; }) === 1) {
        ne(Array.prototype, "find", et.find);
    }
    if ([, 1].findIndex(function () { return true; }) !== 0) {
        ne(Array.prototype, "findIndex", et.findIndex);
    }
    var Ct = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
    var Mt = function ensureEnumerable(e, t) { if (s && Ct(e, t)) {
        Object.defineProperty(e, t, { enumerable: false });
    } };
    var xt = function sliceArgs() { var e = Number(this); var t = arguments.length; var r = t - e; var n = new Array(r < 0 ? 0 : r); for (var o = e; o < t; ++o) {
        n[o - e] = arguments[o];
    } return n; };
    var Nt = function assignTo(e) { return function assignToSource(t, r) { t[r] = e[r]; return t; }; };
    var At = function (e, t) { var r = n(Object(t)); var o; if (ce.IsCallable(Object.getOwnPropertySymbols)) {
        o = v(Object.getOwnPropertySymbols(Object(t)), Ct(t));
    } return p(P(r, o || []), Nt(t), e); };
    var Rt = { assign: function (e, t) { var r = ce.ToObject(e, "Cannot convert undefined or null to object"); return p(ce.Call(xt, 1, arguments), At, r); }, is: function is(e, t) { return ce.SameValue(e, t); } };
    var _t = Object.assign && Object.preventExtensions && function () { var e = Object.preventExtensions({ 1: 2 }); try {
        Object.assign(e, "xy");
    }
    catch (t) {
        return e[1] === "y";
    } }();
    if (_t) {
        ne(Object, "assign", Rt.assign);
    }
    b(Object, Rt);
    if (s) {
        var kt = { setPrototypeOf: function (e, r) { var n; var o = function (e, t) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("cannot set prototype on a non-object");
            } if (!(t === null || ce.TypeIsObject(t))) {
                throw new TypeError("can only set prototype to an object or null" + t);
            } }; var i = function (e, r) { o(e, r); t(n, e, r); return e; }; try {
                n = e.getOwnPropertyDescriptor(e.prototype, r).set;
                t(n, {}, null);
            }
            catch (a) {
                if (e.prototype !== {}[r]) {
                    return;
                }
                n = function (e) { this[r] = e; };
                i.polyfill = i(i({}, null), e.prototype) instanceof e;
            } return i; }(Object, "__proto__") };
        b(Object, kt);
    }
    if (Object.setPrototypeOf && Object.getPrototypeOf && Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null && Object.getPrototypeOf(Object.create(null)) === null) {
        (function () { var e = Object.create(null); var t = Object.getPrototypeOf; var r = Object.setPrototypeOf; Object.getPrototypeOf = function (r) { var n = t(r); return n === e ? null : n; }; Object.setPrototypeOf = function (t, n) { var o = n === null ? e : n; return r(t, o); }; Object.setPrototypeOf.polyfill = false; })();
    }
    var Lt = !i(function () { return Object.keys("foo"); });
    if (!Lt) {
        var Ft = Object.keys;
        ne(Object, "keys", function keys(e) { return Ft(ce.ToObject(e)); });
        n = Object.keys;
    }
    var Dt = i(function () { return Object.keys(/a/g); });
    if (Dt) {
        var zt = Object.keys;
        ne(Object, "keys", function keys(e) { if (re.regex(e)) {
            var t = [];
            for (var r in e) {
                if (z(e, r)) {
                    M(t, r);
                }
            }
            return t;
        } return zt(e); });
        n = Object.keys;
    }
    if (Object.getOwnPropertyNames) {
        var qt = !i(function () { return Object.getOwnPropertyNames("foo"); });
        if (!qt) {
            var Wt = typeof window === "object" ? Object.getOwnPropertyNames(window) : [];
            var Gt = Object.getOwnPropertyNames;
            ne(Object, "getOwnPropertyNames", function getOwnPropertyNames(e) { var t = ce.ToObject(e); if (g(t) === "[object Window]") {
                try {
                    return Gt(t);
                }
                catch (r) {
                    return P([], Wt);
                }
            } return Gt(t); });
        }
    }
    if (Object.getOwnPropertyDescriptor) {
        var Ht = !i(function () { return Object.getOwnPropertyDescriptor("foo", "bar"); });
        if (!Ht) {
            var Vt = Object.getOwnPropertyDescriptor;
            ne(Object, "getOwnPropertyDescriptor", function getOwnPropertyDescriptor(e, t) { return Vt(ce.ToObject(e), t); });
        }
    }
    if (Object.seal) {
        var Bt = !i(function () { return Object.seal("foo"); });
        if (!Bt) {
            var Ut = Object.seal;
            ne(Object, "seal", function seal(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Ut(e); });
        }
    }
    if (Object.isSealed) {
        var $t = !i(function () { return Object.isSealed("foo"); });
        if (!$t) {
            var Jt = Object.isSealed;
            ne(Object, "isSealed", function isSealed(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Jt(e); });
        }
    }
    if (Object.freeze) {
        var Xt = !i(function () { return Object.freeze("foo"); });
        if (!Xt) {
            var Kt = Object.freeze;
            ne(Object, "freeze", function freeze(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return Kt(e); });
        }
    }
    if (Object.isFrozen) {
        var Zt = !i(function () { return Object.isFrozen("foo"); });
        if (!Zt) {
            var Yt = Object.isFrozen;
            ne(Object, "isFrozen", function isFrozen(e) { if (!ce.TypeIsObject(e)) {
                return true;
            } return Yt(e); });
        }
    }
    if (Object.preventExtensions) {
        var Qt = !i(function () { return Object.preventExtensions("foo"); });
        if (!Qt) {
            var er = Object.preventExtensions;
            ne(Object, "preventExtensions", function preventExtensions(e) { if (!ce.TypeIsObject(e)) {
                return e;
            } return er(e); });
        }
    }
    if (Object.isExtensible) {
        var tr = !i(function () { return Object.isExtensible("foo"); });
        if (!tr) {
            var rr = Object.isExtensible;
            ne(Object, "isExtensible", function isExtensible(e) { if (!ce.TypeIsObject(e)) {
                return false;
            } return rr(e); });
        }
    }
    if (Object.getPrototypeOf) {
        var nr = !i(function () { return Object.getPrototypeOf("foo"); });
        if (!nr) {
            var or = Object.getPrototypeOf;
            ne(Object, "getPrototypeOf", function getPrototypeOf(e) { return or(ce.ToObject(e)); });
        }
    }
    var ir = s && function () { var e = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags"); return e && ce.IsCallable(e.get); }();
    if (s && !ir) {
        var ar = function flags() { if (!ce.TypeIsObject(this)) {
            throw new TypeError("Method called on incompatible type: must be an object.");
        } var e = ""; if (this.global) {
            e += "g";
        } if (this.ignoreCase) {
            e += "i";
        } if (this.multiline) {
            e += "m";
        } if (this.unicode) {
            e += "u";
        } if (this.sticky) {
            e += "y";
        } return e; };
        m.getter(RegExp.prototype, "flags", ar);
    }
    var ur = s && a(function () { return String(new RegExp(/a/g, "i")) === "/a/i"; });
    var fr = oe && s && function () { var e = /./; e[$.match] = false; return RegExp(e) === e; }();
    var sr = a(function () { return RegExp.prototype.toString.call({ source: "abc" }) === "/abc/"; });
    var cr = sr && a(function () { return RegExp.prototype.toString.call({ source: "a", flags: "b" }) === "/a/b"; });
    if (!sr || !cr) {
        var lr = RegExp.prototype.toString;
        h(RegExp.prototype, "toString", function toString() { var e = ce.RequireObjectCoercible(this); if (re.regex(e)) {
            return t(lr, e);
        } var r = ue(e.source); var n = ue(e.flags); return "/" + r + "/" + n; }, true);
        m.preserveToString(RegExp.prototype.toString, lr);
    }
    if (s && (!ur || fr)) {
        var pr = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags").get;
        var vr = Object.getOwnPropertyDescriptor(RegExp.prototype, "source") || {};
        var yr = function () { return this.source; };
        var hr = ce.IsCallable(vr.get) ? vr.get : yr;
        var br = RegExp;
        var gr = function () { return function RegExp(e, t) { var r = ce.IsRegExp(e); var n = this instanceof RegExp; if (!n && r && typeof t === "undefined" && e.constructor === RegExp) {
            return e;
        } var o = e; var i = t; if (re.regex(e)) {
            o = ce.Call(hr, e);
            i = typeof t === "undefined" ? ce.Call(pr, e) : t;
            return new RegExp(o, i);
        }
        else if (r) {
            o = e.source;
            i = typeof t === "undefined" ? e.flags : t;
        } return new br(e, t); }; }();
        Ee(br, gr, { $input: true });
        RegExp = gr;
        m.redefine(S, "RegExp", gr);
    }
    if (s) {
        var dr = { input: "$_", lastMatch: "$&", lastParen: "$+", leftContext: "$`", rightContext: "$'" };
        l(n(dr), function (e) { if (e in RegExp && !(dr[e] in RegExp)) {
            m.getter(RegExp, dr[e], function get() { return RegExp[e]; });
        } });
    }
    Ce(RegExp);
    var mr = 1 / Number.EPSILON;
    var Or = function roundTiesToEven(e) { return e + mr - mr; };
    var wr = Math.pow(2, -23);
    var jr = Math.pow(2, 127) * (2 - wr);
    var Sr = Math.pow(2, -126);
    var Tr = Math.E;
    var Ir = Math.LOG2E;
    var Er = Math.LOG10E;
    var Pr = Number.prototype.clz;
    delete Number.prototype.clz;
    var Cr = { acosh: function acosh(e) { var t = Number(e); if (X(t) || e < 1) {
            return NaN;
        } if (t === 1) {
            return 0;
        } if (t === Infinity) {
            return t;
        } var r = 1 / (t * t); if (t < 2) {
            return Y(t - 1 + D(1 - r) * t);
        } var n = t / 2; return Y(n + D(1 - r) * n - 1) + 1 / Ir; }, asinh: function asinh(e) { var t = Number(e); if (t === 0 || !T(t)) {
            return t;
        } var r = k(t); var n = r * r; var o = Z(t); if (r < 1) {
            return o * Y(r + n / (D(n + 1) + 1));
        } return o * (Y(r / 2 + D(1 + 1 / n) * r / 2 - 1) + 1 / Ir); }, atanh: function atanh(e) { var t = Number(e); if (t === 0) {
            return t;
        } if (t === -1) {
            return -Infinity;
        } if (t === 1) {
            return Infinity;
        } if (X(t) || t < -1 || t > 1) {
            return NaN;
        } var r = k(t); return Z(t) * Y(2 * r / (1 - r)) / 2; }, cbrt: function cbrt(e) { var t = Number(e); if (t === 0) {
            return t;
        } var r = t < 0; var n; if (r) {
            t = -t;
        } if (t === Infinity) {
            n = Infinity;
        }
        else {
            n = L(F(t) / 3);
            n = (t / (n * n) + 2 * n) / 3;
        } return r ? -n : n; }, clz32: function clz32(e) { var t = Number(e); var r = ce.ToUint32(t); if (r === 0) {
            return 32;
        } return Pr ? ce.Call(Pr, r) : 31 - _(F(r + .5) * Ir); }, cosh: function cosh(e) { var t = Number(e); if (t === 0) {
            return 1;
        } if (X(t)) {
            return NaN;
        } if (!T(t)) {
            return Infinity;
        } var r = L(k(t) - 1); return (r + 1 / (r * Tr * Tr)) * (Tr / 2); }, expm1: function expm1(e) { var t = Number(e); if (t === -Infinity) {
            return -1;
        } if (!T(t) || t === 0) {
            return t;
        } if (k(t) > .5) {
            return L(t) - 1;
        } var r = t; var n = 0; var o = 1; while (n + r !== n) {
            n += r;
            o += 1;
            r *= t / o;
        } return n; }, hypot: function hypot(e, t) { var r = 0; var n = 0; for (var o = 0; o < arguments.length; ++o) {
            var i = k(Number(arguments[o]));
            if (n < i) {
                r *= n / i * (n / i);
                r += 1;
                n = i;
            }
            else {
                r += i > 0 ? i / n * (i / n) : i;
            }
        } return n === Infinity ? Infinity : n * D(r); }, log2: function log2(e) { return F(e) * Ir; }, log10: function log10(e) { return F(e) * Er; }, log1p: Y, sign: Z, sinh: function sinh(e) { var t = Number(e); if (!T(t) || t === 0) {
            return t;
        } var r = k(t); if (r < 1) {
            var n = Math.expm1(r);
            return Z(t) * n * (1 + 1 / (n + 1)) / 2;
        } var o = L(r - 1); return Z(t) * (o - 1 / (o * Tr * Tr)) * (Tr / 2); }, tanh: function tanh(e) { var t = Number(e); if (X(t) || t === 0) {
            return t;
        } if (t >= 20) {
            return 1;
        } if (t <= -20) {
            return -1;
        } return (Math.expm1(t) - Math.expm1(-t)) / (L(t) + L(-t)); }, trunc: function trunc(e) { var t = Number(e); return t < 0 ? -_(-t) : _(t); }, imul: function imul(e, t) { var r = ce.ToUint32(e); var n = ce.ToUint32(t); var o = r >>> 16 & 65535; var i = r & 65535; var a = n >>> 16 & 65535; var u = n & 65535; return i * u + (o * u + i * a << 16 >>> 0) | 0; }, fround: function fround(e) { var t = Number(e); if (t === 0 || t === Infinity || t === -Infinity || X(t)) {
            return t;
        } var r = Z(t); var n = k(t); if (n < Sr) {
            return r * Or(n / Sr / wr) * Sr * wr;
        } var o = (1 + wr / Number.EPSILON) * n; var i = o - (o - n); if (i > jr || X(i)) {
            return r * Infinity;
        } return r * i; } };
    var Mr = function withinULPDistance(e, t, r) { return k(1 - e / t) / Number.EPSILON < (r || 8); };
    b(Math, Cr);
    h(Math, "sinh", Cr.sinh, Math.sinh(710) === Infinity);
    h(Math, "cosh", Cr.cosh, Math.cosh(710) === Infinity);
    h(Math, "log1p", Cr.log1p, Math.log1p(-1e-17) !== -1e-17);
    h(Math, "asinh", Cr.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
    h(Math, "asinh", Cr.asinh, Math.asinh(1e300) === Infinity);
    h(Math, "atanh", Cr.atanh, Math.atanh(1e-300) === 0);
    h(Math, "tanh", Cr.tanh, Math.tanh(-2e-17) !== -2e-17);
    h(Math, "acosh", Cr.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
    h(Math, "acosh", Cr.acosh, !Mr(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
    h(Math, "cbrt", Cr.cbrt, !Mr(Math.cbrt(1e-300), 1e-100));
    h(Math, "sinh", Cr.sinh, Math.sinh(-2e-17) !== -2e-17);
    var xr = Math.expm1(10);
    h(Math, "expm1", Cr.expm1, xr > 22025.465794806718 || xr < 22025.465794806718);
    var Nr = Math.round;
    var Ar = Math.round(.5 - Number.EPSILON / 4) === 0 && Math.round(-.5 + Number.EPSILON / 3.99) === 1;
    var Rr = mr + 1;
    var _r = 2 * mr - 1;
    var kr = [Rr, _r].every(function (e) { return Math.round(e) === e; });
    h(Math, "round", function round(e) { var t = _(e); var r = t === -1 ? -0 : t + 1; return e - t < .5 ? t : r; }, !Ar || !kr);
    m.preserveToString(Math.round, Nr);
    var Lr = Math.imul;
    if (Math.imul(4294967295, 5) !== -5) {
        Math.imul = Cr.imul;
        m.preserveToString(Math.imul, Lr);
    }
    if (Math.imul.length !== 2) {
        ne(Math, "imul", function imul(e, t) { return ce.Call(Lr, Math, arguments); });
    }
    var Fr = function () { var e = S.setTimeout; if (typeof e !== "function" && typeof e !== "object") {
        return;
    } ce.IsPromise = function (e) { if (!ce.TypeIsObject(e)) {
        return false;
    } if (typeof e._promise === "undefined") {
        return false;
    } return true; }; var r = function (e) { if (!ce.IsConstructor(e)) {
        throw new TypeError("Bad promise constructor");
    } var t = this; var r = function (e, r) { if (t.resolve !== void 0 || t.reject !== void 0) {
        throw new TypeError("Bad Promise implementation!");
    } t.resolve = e; t.reject = r; }; t.resolve = void 0; t.reject = void 0; t.promise = new e(r); if (!(ce.IsCallable(t.resolve) && ce.IsCallable(t.reject))) {
        throw new TypeError("Bad promise constructor");
    } }; var n; if (typeof window !== "undefined" && ce.IsCallable(window.postMessage)) {
        n = function () { var e = []; var t = "zero-timeout-message"; var r = function (r) { M(e, r); window.postMessage(t, "*"); }; var n = function (r) { if (r.source === window && r.data === t) {
            r.stopPropagation();
            if (e.length === 0) {
                return;
            }
            var n = N(e);
            n();
        } }; window.addEventListener("message", n, true); return r; };
    } var o = function () { var e = S.Promise; var t = e && e.resolve && e.resolve(); return t && function (e) { return t.then(e); }; }; var i = ce.IsCallable(S.setImmediate) ? S.setImmediate : typeof process === "object" && process.nextTick ? process.nextTick : o() || (ce.IsCallable(n) ? n() : function (t) { e(t, 0); }); var a = function (e) { return e; }; var u = function (e) { throw e; }; var f = 0; var s = 1; var c = 2; var l = 0; var p = 1; var v = 2; var y = {}; var h = function (e, t, r) { i(function () { g(e, t, r); }); }; var g = function (e, t, r) { var n, o; if (t === y) {
        return e(r);
    } try {
        n = e(r);
        o = t.resolve;
    }
    catch (i) {
        n = i;
        o = t.reject;
    } o(n); }; var d = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.fulfillReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + l], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = s; r.reactionLength = 0; }; var m = function (e, t) { var r = e._promise; var n = r.reactionLength; if (n > 0) {
        h(r.rejectReactionHandler0, r.reactionCapability0, t);
        r.fulfillReactionHandler0 = void 0;
        r.rejectReactions0 = void 0;
        r.reactionCapability0 = void 0;
        if (n > 1) {
            for (var o = 1, i = 0; o < n; o++, i += 3) {
                h(r[i + p], r[i + v], t);
                e[i + l] = void 0;
                e[i + p] = void 0;
                e[i + v] = void 0;
            }
        }
    } r.result = t; r.state = c; r.reactionLength = 0; }; var O = function (e) { var t = false; var r = function (r) { var n; if (t) {
        return;
    } t = true; if (r === e) {
        return m(e, new TypeError("Self resolution"));
    } if (!ce.TypeIsObject(r)) {
        return d(e, r);
    } try {
        n = r.then;
    }
    catch (o) {
        return m(e, o);
    } if (!ce.IsCallable(n)) {
        return d(e, r);
    } i(function () { j(e, r, n); }); }; var n = function (r) { if (t) {
        return;
    } t = true; return m(e, r); }; return { resolve: r, reject: n }; }; var w = function (e, r, n, o) { if (e === I) {
        t(e, r, n, o, y);
    }
    else {
        t(e, r, n, o);
    } }; var j = function (e, t, r) { var n = O(e); var o = n.resolve; var i = n.reject; try {
        w(r, t, o, i);
    }
    catch (a) {
        i(a);
    } }; var T, I; var E = function () { var e = function Promise(t) { if (!(this instanceof e)) {
        throw new TypeError('Constructor Promise requires "new"');
    } if (this && this._promise) {
        throw new TypeError("Bad construction");
    } if (!ce.IsCallable(t)) {
        throw new TypeError("not a valid resolver");
    } var r = Ae(this, e, T, { _promise: { result: void 0, state: f, reactionLength: 0, fulfillReactionHandler0: void 0, rejectReactionHandler0: void 0, reactionCapability0: void 0 } }); var n = O(r); var o = n.reject; try {
        t(n.resolve, o);
    }
    catch (i) {
        o(i);
    } return r; }; return e; }(); T = E.prototype; var P = function (e, t, r, n) { var o = false; return function (i) { if (o) {
        return;
    } o = true; t[e] = i; if (--n.count === 0) {
        var a = r.resolve;
        a(t);
    } }; }; var C = function (e, t, r) { var n = e.iterator; var o = []; var i = { count: 1 }; var a, u; var f = 0; while (true) {
        try {
            a = ce.IteratorStep(n);
            if (a === false) {
                e.done = true;
                break;
            }
            u = a.value;
        }
        catch (s) {
            e.done = true;
            throw s;
        }
        o[f] = void 0;
        var c = t.resolve(u);
        var l = P(f, o, r, i);
        i.count += 1;
        w(c.then, c, l, r.reject);
        f += 1;
    } if (--i.count === 0) {
        var p = r.resolve;
        p(o);
    } return r.promise; }; var x = function (e, t, r) { var n = e.iterator; var o, i, a; while (true) {
        try {
            o = ce.IteratorStep(n);
            if (o === false) {
                e.done = true;
                break;
            }
            i = o.value;
        }
        catch (u) {
            e.done = true;
            throw u;
        }
        a = t.resolve(i);
        w(a.then, a, r.resolve, r.reject);
    } return r.promise; }; b(E, { all: function all(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return C(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, race: function race(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Promise is not object");
        } var n = new r(t); var o, i; try {
            o = ce.GetIterator(e);
            i = { iterator: o, done: false };
            return x(i, t, n);
        }
        catch (a) {
            var u = a;
            if (i && !i.done) {
                try {
                    ce.IteratorClose(o, true);
                }
                catch (f) {
                    u = f;
                }
            }
            var s = n.reject;
            s(u);
            return n.promise;
        } }, reject: function reject(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } var n = new r(t); var o = n.reject; o(e); return n.promise; }, resolve: function resolve(e) { var t = this; if (!ce.TypeIsObject(t)) {
            throw new TypeError("Bad promise constructor");
        } if (ce.IsPromise(e)) {
            var n = e.constructor;
            if (n === t) {
                return e;
            }
        } var o = new r(t); var i = o.resolve; i(e); return o.promise; } }); b(T, { "catch": function (e) { return this.then(null, e); }, then: function then(e, t) { var n = this; if (!ce.IsPromise(n)) {
            throw new TypeError("not a promise");
        } var o = ce.SpeciesConstructor(n, E); var i; var b = arguments.length > 2 && arguments[2] === y; if (b && o === E) {
            i = y;
        }
        else {
            i = new r(o);
        } var g = ce.IsCallable(e) ? e : a; var d = ce.IsCallable(t) ? t : u; var m = n._promise; var O; if (m.state === f) {
            if (m.reactionLength === 0) {
                m.fulfillReactionHandler0 = g;
                m.rejectReactionHandler0 = d;
                m.reactionCapability0 = i;
            }
            else {
                var w = 3 * (m.reactionLength - 1);
                m[w + l] = g;
                m[w + p] = d;
                m[w + v] = i;
            }
            m.reactionLength += 1;
        }
        else if (m.state === s) {
            O = m.result;
            h(g, i, O);
        }
        else if (m.state === c) {
            O = m.result;
            h(d, i, O);
        }
        else {
            throw new TypeError("unexpected Promise state");
        } return i.promise; } }); y = new r(E); I = T.then; return E; }();
    if (S.Promise) {
        delete S.Promise.accept;
        delete S.Promise.defer;
        delete S.Promise.prototype.chain;
    }
    if (typeof Fr === "function") {
        b(S, { Promise: Fr });
        var Dr = w(S.Promise, function (e) { return e.resolve(42).then(function () { }) instanceof e; });
        var zr = !i(function () { return S.Promise.reject(42).then(null, 5).then(null, W); });
        var qr = i(function () { return S.Promise.call(3, W); });
        var Wr = function (e) { var t = e.resolve(5); t.constructor = {}; var r = e.resolve(t); try {
            r.then(null, W).then(null, W);
        }
        catch (n) {
            return true;
        } return t === r; }(S.Promise);
        var Gr = s && function () { var e = 0; var t = Object.defineProperty({}, "then", { get: function () { e += 1; } }); Promise.resolve(t); return e === 1; }();
        var Hr = function BadResolverPromise(e) { var t = new Promise(e); e(3, function () { }); this.then = t.then; this.constructor = BadResolverPromise_1; };
        Hr.prototype = Promise.prototype;
        Hr.all = Promise.all;
        var Vr = a(function () { return !!Hr.all([1, 2]); });
        if (!Dr || !zr || !qr || Wr || !Gr || Vr) {
            Promise = Fr;
            ne(S, "Promise", Fr);
        }
        if (Promise.all.length !== 1) {
            var Br = Promise.all;
            ne(Promise, "all", function all(e) { return ce.Call(Br, this, arguments); });
        }
        if (Promise.race.length !== 1) {
            var Ur = Promise.race;
            ne(Promise, "race", function race(e) { return ce.Call(Ur, this, arguments); });
        }
        if (Promise.resolve.length !== 1) {
            var $r = Promise.resolve;
            ne(Promise, "resolve", function resolve(e) { return ce.Call($r, this, arguments); });
        }
        if (Promise.reject.length !== 1) {
            var Jr = Promise.reject;
            ne(Promise, "reject", function reject(e) { return ce.Call(Jr, this, arguments); });
        }
        Mt(Promise, "all");
        Mt(Promise, "race");
        Mt(Promise, "resolve");
        Mt(Promise, "reject");
        Ce(Promise);
    }
    var Xr = function (e) { var t = n(p(e, function (e, t) { e[t] = true; return e; }, {})); return e.join(":") === t.join(":"); };
    var Kr = Xr(["z", "a", "bb"]);
    var Zr = Xr(["z", 1, "a", "3", 2]);
    if (s) {
        var Yr = function fastkey(e, t) { if (!t && !Kr) {
            return null;
        } if (se(e)) {
            return "^" + ce.ToString(e);
        }
        else if (typeof e === "string") {
            return "$" + e;
        }
        else if (typeof e === "number") {
            if (!Zr) {
                return "n" + e;
            }
            return e;
        }
        else if (typeof e === "boolean") {
            return "b" + e;
        } return null; };
        var Qr = function emptyObject() { return Object.create ? Object.create(null) : {}; };
        var en = function addIterableToMap(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { if (!ce.TypeIsObject(e)) {
                throw new TypeError("Iterator value " + e + " is not an entry object");
            } n.set(e[0], e[1]); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e, t) { n.set(t, e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.set;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad map");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        if (!ce.TypeIsObject(f)) {
                            throw new TypeError("Iterator value " + f + " is not an entry object");
                        }
                        t(a, n, f[0], f[1]);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var tn = function addIterableToSet(e, n, o) { if (r(o) || re.string(o)) {
            l(o, function (e) { n.add(e); });
        }
        else if (o instanceof e) {
            t(e.prototype.forEach, o, function (e) { n.add(e); });
        }
        else {
            var i, a;
            if (!se(o)) {
                a = n.add;
                if (!ce.IsCallable(a)) {
                    throw new TypeError("bad set");
                }
                i = ce.GetIterator(o);
            }
            if (typeof i !== "undefined") {
                while (true) {
                    var u = ce.IteratorStep(i);
                    if (u === false) {
                        break;
                    }
                    var f = u.value;
                    try {
                        t(a, n, f);
                    }
                    catch (s) {
                        ce.IteratorClose(i, true);
                        throw s;
                    }
                }
            }
        } };
        var rn = { Map: function () { var e = {}; var r = function MapEntry(e, t) { this.key = e; this.value = t; this.next = null; this.prev = null; }; r.prototype.isRemoved = function isRemoved() { return this.key === e; }; var n = function isMap(e) { return !!e._es6map; }; var o = function requireMapSlot(e, t) { if (!ce.TypeIsObject(e) || !n(e)) {
                throw new TypeError("Method Map.prototype." + t + " called on incompatible receiver " + ce.ToString(e));
            } }; var i = function MapIterator(e, t) { o(e, "[[MapIterator]]"); this.head = e._head; this.i = this.head; this.kind = t; }; i.prototype = { isMapIterator: true, next: function next() { if (!this.isMapIterator) {
                    throw new TypeError("Not a MapIterator");
                } var e = this.i; var t = this.kind; var r = this.head; if (typeof this.i === "undefined") {
                    return Ke();
                } while (e.isRemoved() && e !== r) {
                    e = e.prev;
                } var n; while (e.next !== r) {
                    e = e.next;
                    if (!e.isRemoved()) {
                        if (t === "key") {
                            n = e.key;
                        }
                        else if (t === "value") {
                            n = e.value;
                        }
                        else {
                            n = [e.key, e.value];
                        }
                        this.i = e;
                        return Ke(n);
                    }
                } this.i = void 0; return Ke(); } }; Me(i.prototype); var a; var u = function Map() { if (!(this instanceof Map)) {
                throw new TypeError('Constructor Map requires "new"');
            } if (this && this._es6map) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Map, a, { _es6map: true, _head: null, _map: G ? new G : null, _size: 0, _storage: Qr() }); var t = new r(null, null); t.next = t.prev = t; e._head = t; if (arguments.length > 0) {
                en(Map, e, arguments[0]);
            } return e; }; a = u.prototype; m.getter(a, "size", function () { if (typeof this._size === "undefined") {
                throw new TypeError("size method called on incompatible Map");
            } return this._size; }); b(a, { get: function get(e) { o(this, "get"); var t; var r = Yr(e, true); if (r !== null) {
                    t = this._storage[r];
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } if (this._map) {
                    t = V.call(this._map, e);
                    if (t) {
                        return t.value;
                    }
                    else {
                        return;
                    }
                } var n = this._head; var i = n; while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        return i.value;
                    }
                } }, has: function has(e) { o(this, "has"); var t = Yr(e, true); if (t !== null) {
                    return typeof this._storage[t] !== "undefined";
                } if (this._map) {
                    return B.call(this._map, e);
                } var r = this._head; var n = r; while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, e)) {
                        return true;
                    }
                } return false; }, set: function set(e, t) { o(this, "set"); var n = this._head; var i = n; var a; var u = Yr(e, true); if (u !== null) {
                    if (typeof this._storage[u] !== "undefined") {
                        this._storage[u].value = t;
                        return this;
                    }
                    else {
                        a = this._storage[u] = new r(e, t);
                        i = n.prev;
                    }
                }
                else if (this._map) {
                    if (B.call(this._map, e)) {
                        V.call(this._map, e).value = t;
                    }
                    else {
                        a = new r(e, t);
                        U.call(this._map, e, a);
                        i = n.prev;
                    }
                } while ((i = i.next) !== n) {
                    if (ce.SameValueZero(i.key, e)) {
                        i.value = t;
                        return this;
                    }
                } a = a || new r(e, t); if (ce.SameValue(-0, e)) {
                    a.key = +0;
                } a.next = this._head; a.prev = this._head.prev; a.prev.next = a; a.next.prev = a; this._size += 1; return this; }, "delete": function (t) { o(this, "delete"); var r = this._head; var n = r; var i = Yr(t, true); if (i !== null) {
                    if (typeof this._storage[i] === "undefined") {
                        return false;
                    }
                    n = this._storage[i].prev;
                    delete this._storage[i];
                }
                else if (this._map) {
                    if (!B.call(this._map, t)) {
                        return false;
                    }
                    n = V.call(this._map, t).prev;
                    H.call(this._map, t);
                } while ((n = n.next) !== r) {
                    if (ce.SameValueZero(n.key, t)) {
                        n.key = e;
                        n.value = e;
                        n.prev.next = n.next;
                        n.next.prev = n.prev;
                        this._size -= 1;
                        return true;
                    }
                } return false; }, clear: function clear() { o(this, "clear"); this._map = G ? new G : null; this._size = 0; this._storage = Qr(); var t = this._head; var r = t; var n = r.next; while ((r = n) !== t) {
                    r.key = e;
                    r.value = e;
                    n = r.next;
                    r.next = r.prev = t;
                } t.next = t.prev = t; }, keys: function keys() { o(this, "keys"); return new i(this, "key"); }, values: function values() { o(this, "values"); return new i(this, "value"); }, entries: function entries() { o(this, "entries"); return new i(this, "key+value"); }, forEach: function forEach(e) { o(this, "forEach"); var r = arguments.length > 1 ? arguments[1] : null; var n = this.entries(); for (var i = n.next(); !i.done; i = n.next()) {
                    if (r) {
                        t(e, r, i.value[1], i.value[0], this);
                    }
                    else {
                        e(i.value[1], i.value[0], this);
                    }
                } } }); Me(a, a.entries); return u; }(), Set: function () { var e = function isSet(e) { return e._es6set && typeof e._storage !== "undefined"; }; var r = function requireSetSlot(t, r) { if (!ce.TypeIsObject(t) || !e(t)) {
                throw new TypeError("Set.prototype." + r + " called on incompatible receiver " + ce.ToString(t));
            } }; var o; var i = function Set() { if (!(this instanceof Set)) {
                throw new TypeError('Constructor Set requires "new"');
            } if (this && this._es6set) {
                throw new TypeError("Bad construction");
            } var e = Ae(this, Set, o, { _es6set: true, "[[SetData]]": null, _storage: Qr() }); if (!e._es6set) {
                throw new TypeError("bad set");
            } if (arguments.length > 0) {
                tn(Set, e, arguments[0]);
            } return e; }; o = i.prototype; var a = function (e) { var t = e; if (t === "^null") {
                return null;
            }
            else if (t === "^undefined") {
                return void 0;
            }
            else {
                var r = t.charAt(0);
                if (r === "$") {
                    return C(t, 1);
                }
                else if (r === "n") {
                    return +C(t, 1);
                }
                else if (r === "b") {
                    return t === "btrue";
                }
            } return +t; }; var u = function ensureMap(e) { if (!e["[[SetData]]"]) {
                var t = new rn.Map;
                e["[[SetData]]"] = t;
                l(n(e._storage), function (e) { var r = a(e); t.set(r, r); });
                e["[[SetData]]"] = t;
            } e._storage = null; }; m.getter(i.prototype, "size", function () { r(this, "size"); if (this._storage) {
                return n(this._storage).length;
            } u(this); return this["[[SetData]]"].size; }); b(i.prototype, { has: function has(e) { r(this, "has"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    return !!this._storage[t];
                } u(this); return this["[[SetData]]"].has(e); }, add: function add(e) { r(this, "add"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    this._storage[t] = true;
                    return this;
                } u(this); this["[[SetData]]"].set(e, e); return this; }, "delete": function (e) { r(this, "delete"); var t; if (this._storage && (t = Yr(e)) !== null) {
                    var n = z(this._storage, t);
                    return delete this._storage[t] && n;
                } u(this); return this["[[SetData]]"]["delete"](e); }, clear: function clear() { r(this, "clear"); if (this._storage) {
                    this._storage = Qr();
                } if (this["[[SetData]]"]) {
                    this["[[SetData]]"].clear();
                } }, values: function values() { r(this, "values"); u(this); return new f(this["[[SetData]]"].values()); }, entries: function entries() { r(this, "entries"); u(this); return new f(this["[[SetData]]"].entries()); }, forEach: function forEach(e) { r(this, "forEach"); var n = arguments.length > 1 ? arguments[1] : null; var o = this; u(o); this["[[SetData]]"].forEach(function (r, i) { if (n) {
                    t(e, n, i, i, o);
                }
                else {
                    e(i, i, o);
                } }); } }); h(i.prototype, "keys", i.prototype.values, true); Me(i.prototype, i.prototype.values); var f = function SetIterator(e) { this.it = e; }; f.prototype = { isSetIterator: true, next: function next() { if (!this.isSetIterator) {
                    throw new TypeError("Not a SetIterator");
                } return this.it.next(); } }; Me(f.prototype); return i; }() };
        var nn = S.Set && !Set.prototype["delete"] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray((new Set).keys);
        if (nn) {
            S.Set = rn.Set;
        }
        if (S.Map || S.Set) {
            var on = a(function () { return new Map([[1, 2]]).get(1) === 2; });
            if (!on) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, S.Map.prototype); return e; };
                S.Map.prototype = O(G.prototype);
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var an = new Map;
            var un = function () { var e = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]); e.set(-0, e); return e.get(0) === e && e.get(-0) === e && e.has(0) && e.has(-0); }();
            var fn = an.set(1, 2) === an;
            if (!un || !fn) {
                ne(Map.prototype, "set", function set(e, r) { t(U, this, e === 0 ? 0 : e, r); return this; });
            }
            if (!un) {
                b(Map.prototype, { get: function get(e) { return t(V, this, e === 0 ? 0 : e); }, has: function has(e) { return t(B, this, e === 0 ? 0 : e); } }, true);
                m.preserveToString(Map.prototype.get, V);
                m.preserveToString(Map.prototype.has, B);
            }
            var sn = new Set;
            var cn = Set.prototype["delete"] && Set.prototype.add && Set.prototype.has && function (e) { e["delete"](0); e.add(-0); return !e.has(0); }(sn);
            var ln = sn.add(1) === sn;
            if (!cn || !ln) {
                var pn = Set.prototype.add;
                Set.prototype.add = function add(e) { t(pn, this, e === 0 ? 0 : e); return this; };
                m.preserveToString(Set.prototype.add, pn);
            }
            if (!cn) {
                var vn = Set.prototype.has;
                Set.prototype.has = function has(e) { return t(vn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype.has, vn);
                var yn = Set.prototype["delete"];
                Set.prototype["delete"] = function SetDelete(e) { return t(yn, this, e === 0 ? 0 : e); };
                m.preserveToString(Set.prototype["delete"], yn);
            }
            var hn = w(S.Map, function (e) { var t = new e([]); t.set(42, 42); return t instanceof e; });
            var bn = Object.setPrototypeOf && !hn;
            var gn = function () { try {
                return !(S.Map() instanceof S.Map);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Map.length !== 0 || bn || !gn) {
                S.Map = function Map() { if (!(this instanceof Map)) {
                    throw new TypeError('Constructor Map requires "new"');
                } var e = new G; if (arguments.length > 0) {
                    en(Map, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Map.prototype); return e; };
                S.Map.prototype = G.prototype;
                h(S.Map.prototype, "constructor", S.Map, true);
                m.preserveToString(S.Map, G);
            }
            var dn = w(S.Set, function (e) { var t = new e([]); t.add(42, 42); return t instanceof e; });
            var mn = Object.setPrototypeOf && !dn;
            var On = function () { try {
                return !(S.Set() instanceof S.Set);
            }
            catch (e) {
                return e instanceof TypeError;
            } }();
            if (S.Set.length !== 0 || mn || !On) {
                var wn = S.Set;
                S.Set = function Set() { if (!(this instanceof Set)) {
                    throw new TypeError('Constructor Set requires "new"');
                } var e = new wn; if (arguments.length > 0) {
                    tn(Set, e, arguments[0]);
                } delete e.constructor; Object.setPrototypeOf(e, Set.prototype); return e; };
                S.Set.prototype = wn.prototype;
                h(S.Set.prototype, "constructor", S.Set, true);
                m.preserveToString(S.Set, wn);
            }
            var jn = new S.Map;
            var Sn = !a(function () { return jn.keys().next().done; });
            if (typeof S.Map.prototype.clear !== "function" || (new S.Set).size !== 0 || jn.size !== 0 || typeof S.Map.prototype.keys !== "function" || typeof S.Set.prototype.keys !== "function" || typeof S.Map.prototype.forEach !== "function" || typeof S.Set.prototype.forEach !== "function" || u(S.Map) || u(S.Set) || typeof jn.keys().next !== "function" || Sn || !hn) {
                b(S, { Map: rn.Map, Set: rn.Set }, true);
            }
            if (S.Set.prototype.keys !== S.Set.prototype.values) {
                h(S.Set.prototype, "keys", S.Set.prototype.values, true);
            }
            Me(Object.getPrototypeOf((new S.Map).keys()));
            Me(Object.getPrototypeOf((new S.Set).keys()));
            if (c && S.Set.prototype.has.name !== "has") {
                var Tn = S.Set.prototype.has;
                ne(S.Set.prototype, "has", function has(e) { return t(Tn, this, e); });
            }
        }
        b(S, rn);
        Ce(S.Map);
        Ce(S.Set);
    }
    var In = function throwUnlessTargetIsObject(e) { if (!ce.TypeIsObject(e)) {
        throw new TypeError("target must be an object");
    } };
    var En = { apply: function apply() { return ce.Call(ce.Call, null, arguments); }, construct: function construct(e, t) { if (!ce.IsConstructor(e)) {
            throw new TypeError("First argument must be a constructor.");
        } var r = arguments.length > 2 ? arguments[2] : e; if (!ce.IsConstructor(r)) {
            throw new TypeError("new.target must be a constructor.");
        } return ce.Construct(e, t, r, "internal"); }, deleteProperty: function deleteProperty(e, t) { In(e); if (s) {
            var r = Object.getOwnPropertyDescriptor(e, t);
            if (r && !r.configurable) {
                return false;
            }
        } return delete e[t]; }, has: function has(e, t) { In(e); return t in e; } };
    if (Object.getOwnPropertyNames) {
        Object.assign(En, { ownKeys: function ownKeys(e) { In(e); var t = Object.getOwnPropertyNames(e); if (ce.IsCallable(Object.getOwnPropertySymbols)) {
                x(t, Object.getOwnPropertySymbols(e));
            } return t; } });
    }
    var Pn = function ConvertExceptionToBoolean(e) { return !i(e); };
    if (Object.preventExtensions) {
        Object.assign(En, { isExtensible: function isExtensible(e) { In(e); return Object.isExtensible(e); }, preventExtensions: function preventExtensions(e) { In(e); return Pn(function () { return Object.preventExtensions(e); }); } });
    }
    if (s) {
        var Cn = function get(e, t, r) { var n = Object.getOwnPropertyDescriptor(e, t); if (!n) {
            var o = Object.getPrototypeOf(e);
            if (o === null) {
                return void 0;
            }
            return Cn(o, t, r);
        } if ("value" in n) {
            return n.value;
        } if (n.get) {
            return ce.Call(n.get, r);
        } return void 0; };
        var Mn = function set(e, r, n, o) { var i = Object.getOwnPropertyDescriptor(e, r); if (!i) {
            var a = Object.getPrototypeOf(e);
            if (a !== null) {
                return Mn(a, r, n, o);
            }
            i = { value: void 0, writable: true, enumerable: true, configurable: true };
        } if ("value" in i) {
            if (!i.writable) {
                return false;
            }
            if (!ce.TypeIsObject(o)) {
                return false;
            }
            var u = Object.getOwnPropertyDescriptor(o, r);
            if (u) {
                return ae.defineProperty(o, r, { value: n });
            }
            else {
                return ae.defineProperty(o, r, { value: n, writable: true, enumerable: true, configurable: true });
            }
        } if (i.set) {
            t(i.set, o, n);
            return true;
        } return false; };
        Object.assign(En, { defineProperty: function defineProperty(e, t, r) { In(e); return Pn(function () { return Object.defineProperty(e, t, r); }); }, getOwnPropertyDescriptor: function getOwnPropertyDescriptor(e, t) { In(e); return Object.getOwnPropertyDescriptor(e, t); }, get: function get(e, t) { In(e); var r = arguments.length > 2 ? arguments[2] : e; return Cn(e, t, r); }, set: function set(e, t, r) { In(e); var n = arguments.length > 3 ? arguments[3] : e; return Mn(e, t, r, n); } });
    }
    if (Object.getPrototypeOf) {
        var xn = Object.getPrototypeOf;
        En.getPrototypeOf = function getPrototypeOf(e) { In(e); return xn(e); };
    }
    if (Object.setPrototypeOf && En.getPrototypeOf) {
        var Nn = function (e, t) { var r = t; while (r) {
            if (e === r) {
                return true;
            }
            r = En.getPrototypeOf(r);
        } return false; };
        Object.assign(En, { setPrototypeOf: function setPrototypeOf(e, t) { In(e); if (t !== null && !ce.TypeIsObject(t)) {
                throw new TypeError("proto must be an object or null");
            } if (t === ae.getPrototypeOf(e)) {
                return true;
            } if (ae.isExtensible && !ae.isExtensible(e)) {
                return false;
            } if (Nn(e, t)) {
                return false;
            } Object.setPrototypeOf(e, t); return true; } });
    }
    var An = function (e, t) { if (!ce.IsCallable(S.Reflect[e])) {
        h(S.Reflect, e, t);
    }
    else {
        var r = a(function () { S.Reflect[e](1); S.Reflect[e](NaN); S.Reflect[e](true); return true; });
        if (r) {
            ne(S.Reflect, e, t);
        }
    } };
    Object.keys(En).forEach(function (e) { An(e, En[e]); });
    var Rn = S.Reflect.getPrototypeOf;
    if (c && Rn && Rn.name !== "getPrototypeOf") {
        ne(S.Reflect, "getPrototypeOf", function getPrototypeOf(e) { return t(Rn, S.Reflect, e); });
    }
    if (S.Reflect.setPrototypeOf) {
        if (a(function () { S.Reflect.setPrototypeOf(1, {}); return true; })) {
            ne(S.Reflect, "setPrototypeOf", En.setPrototypeOf);
        }
    }
    if (S.Reflect.defineProperty) {
        if (!a(function () { var e = !S.Reflect.defineProperty(1, "test", { value: 1 }); var t = typeof Object.preventExtensions !== "function" || !S.Reflect.defineProperty(Object.preventExtensions({}), "test", {}); return e && t; })) {
            ne(S.Reflect, "defineProperty", En.defineProperty);
        }
    }
    if (S.Reflect.construct) {
        if (!a(function () { var e = function F() { }; return S.Reflect.construct(function () { }, [], e) instanceof e; })) {
            ne(S.Reflect, "construct", En.construct);
        }
    }
    if (String(new Date(NaN)) !== "Invalid Date") {
        var _n = Date.prototype.toString;
        var kn = function toString() { var e = +this; if (e !== e) {
            return "Invalid Date";
        } return ce.Call(_n, this); };
        ne(Date.prototype, "toString", kn);
    }
    var Ln = { anchor: function anchor(e) { return ce.CreateHTML(this, "a", "name", e); }, big: function big() { return ce.CreateHTML(this, "big", "", ""); }, blink: function blink() { return ce.CreateHTML(this, "blink", "", ""); }, bold: function bold() { return ce.CreateHTML(this, "b", "", ""); }, fixed: function fixed() { return ce.CreateHTML(this, "tt", "", ""); }, fontcolor: function fontcolor(e) { return ce.CreateHTML(this, "font", "color", e); }, fontsize: function fontsize(e) { return ce.CreateHTML(this, "font", "size", e); }, italics: function italics() { return ce.CreateHTML(this, "i", "", ""); }, link: function link(e) { return ce.CreateHTML(this, "a", "href", e); }, small: function small() { return ce.CreateHTML(this, "small", "", ""); }, strike: function strike() { return ce.CreateHTML(this, "strike", "", ""); }, sub: function sub() { return ce.CreateHTML(this, "sub", "", ""); }, sup: function sub() { return ce.CreateHTML(this, "sup", "", ""); } };
    l(Object.keys(Ln), function (e) { var r = String.prototype[e]; var n = false; if (ce.IsCallable(r)) {
        var o = t(r, "", ' " ');
        var i = P([], o.match(/"/g)).length;
        n = o !== o.toLowerCase() || i > 2;
    }
    else {
        n = true;
    } if (n) {
        ne(String.prototype, e, Ln[e]);
    } });
    var Fn = function () { if (!oe) {
        return false;
    } var e = typeof JSON === "object" && typeof JSON.stringify === "function" ? JSON.stringify : null; if (!e) {
        return false;
    } if (typeof e($()) !== "undefined") {
        return true;
    } if (e([$()]) !== "[null]") {
        return true;
    } var t = { a: $() }; t[$()] = true; if (e(t) !== "{}") {
        return true;
    } return false; }();
    var Dn = a(function () { if (!oe) {
        return true;
    } return JSON.stringify(Object($())) === "{}" && JSON.stringify([Object($())]) === "[{}]"; });
    if (Fn || !Dn) {
        var zn = JSON.stringify;
        ne(JSON, "stringify", function stringify(e) { if (typeof e === "symbol") {
            return;
        } var n; if (arguments.length > 1) {
            n = arguments[1];
        } var o = [e]; if (!r(n)) {
            var i = ce.IsCallable(n) ? n : null;
            var a = function (e, r) { var n = i ? t(i, this, e, r) : r; if (typeof n !== "symbol") {
                if (re.symbol(n)) {
                    return Nt({})(n);
                }
                else {
                    return n;
                }
            } };
            o.push(a);
        }
        else {
            o.push(n);
        } if (arguments.length > 2) {
            o.push(arguments[2]);
        } return zn.apply(this, o); });
    }
    return S;
});
//# sourceMappingURL=es6-shim.map
/// <reference path="node_modules/es6-shim/es6-shim.min.js" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                /**
                 * Associate tokens with promises.
                 *
                 * First, .make() a promise -- associate a token with resolve/reject callbacks.
                 *
                 * You can either .keep() a promise -- resolve() and forget it;
                 * Or you may also .break() a promise -- reject() and forget it.
                 *
                 * <T> is the type of resolved value (value yielded successfully by promise).
                 */
                var PromiseStore = /** @class */ (function () {
                    function PromiseStore() {
                        this._promises = new Map();
                    }
                    Object.defineProperty(PromiseStore.prototype, "length", {
                        /**
                         * How many promises are currently being tracked?
                         */
                        get: function () {
                            return this._promises.size;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Associate a token with its respective resolve and reject callbacks.
                     */
                    PromiseStore.prototype.make = function (token, resolve, reject) {
                        if (this._promises.has(token)) {
                            return reject("Existing request with token " + token);
                        }
                        this._promises.set(token, { reject: reject, resolve: resolve });
                    };
                    /**
                     * Resolve the promise associated with a token (with a value!).
                     * Once the promise is resolved, the token is removed..
                     */
                    PromiseStore.prototype.keep = function (token, value) {
                        var callbacks = this._promises.get(token);
                        if (!callbacks) {
                            throw new Error("No promise associated with token: " + token);
                        }
                        var accept = callbacks.resolve;
                        this._promises.delete(token);
                        return accept(value);
                    };
                    /**
                     * Instantly reject and forget a promise associated with the token.
                     */
                    PromiseStore.prototype.break = function (token, reason) {
                        var callbacks = this._promises.get(token);
                        if (!callbacks) {
                            throw new Error("No promise associated with token: " + token);
                        }
                        this._promises.delete(token);
                        callbacks.reject(reason);
                    };
                    return PromiseStore;
                }());
                prediction.PromiseStore = PromiseStore;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
/*
 * Copyright (c) 2018 National Research Council Canada (author: Eddie A. Santos)
 * Copyright (c) 2018 SIL International
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/// <reference path="node_modules/es6-shim/es6-shim.min.js" />
/// <reference path="promise-store.ts" />
/**
 * Top-level interface to the Language Modelling layer, or "LMLayer" for short.
 *
 * The Language Modelling layer provides a way for keyboards to offer prediction and
 * correction functionalities. The LMLayer proper runs within a Web Worker, however,
 * this class is intended to run in the main thread, and automatically spawn a Web
 * Worker, capable of offering predictions.
 *
 * Since the Worker runs in a different thread, the public methods of this class are
 * asynchronous. Methods of note include:
 *
 *  - #loadModel() -- loads a specified model file
 *  - #predict() -- ask the LMLayer to offer suggestions (predictions or corrections) for
 *                  the input event
 *  - #unloadModel() -- unloads the LMLayer's currently loaded model, preparing it to
 *                          receive (load) a new model
 *
 * The top-level LMLayer will automatically starts up its own Web Worker.
 */
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction) {
                var LMLayer = /** @class */ (function () {
                    /**
                     * Construct the top-level LMLayer interface. This also starts the underlying Worker.
                     *
                     * @param uri URI of the underlying LMLayer worker code. This will usually be a blob:
                     *            or file: URI. If uri is not provided, this will start the default Worker.
                     */
                    function LMLayer(capabilities, worker) {
                        // Either use the given worker, or instantiate the default worker.
                        this._worker = worker || prediction.DefaultWorker.constructInstance();
                        this._worker.onmessage = this.onMessage.bind(this);
                        this._declareLMLayerReady = null;
                        this._predictPromises = new prediction.PromiseStore();
                        this._wordbreakPromises = new prediction.PromiseStore();
                        this._acceptPromises = new prediction.PromiseStore();
                        this._revertPromises = new prediction.PromiseStore();
                        this._nextToken = Number.MIN_SAFE_INTEGER;
                        this.sendConfig(capabilities);
                    }
                    /**
                     * Initializes the LMLayer worker with the host platform's capability set.
                     *
                     * @param capabilities The host platform's capability spec - a model cannot assume access to more context
                     *                     than specified by this parameter.
                     */
                    LMLayer.prototype.sendConfig = function (capabilities) {
                        this._worker.postMessage({
                            message: 'config',
                            capabilities: capabilities
                        });
                    };
                    /**
                     * Initializes the LMLayer worker with a path to the desired model file.
                     */
                    LMLayer.prototype.loadModel = function (modelSource, loadType) {
                        var _this = this;
                        if (loadType === void 0) { loadType = 'file'; }
                        return new Promise(function (resolve, _reject) {
                            // Sets up so the promise is resolved in the onMessage() callback, when it receives
                            // the 'ready' message.
                            _this._declareLMLayerReady = resolve;
                            var modelSourceSpec = {
                                type: loadType
                            };
                            if (loadType == 'file') {
                                modelSourceSpec.file = modelSource;
                            }
                            else {
                                modelSourceSpec.code = modelSource;
                            }
                            _this._worker.postMessage({
                                message: 'load',
                                source: modelSourceSpec
                            });
                        });
                    };
                    /**
                     * Unloads the previously-active model from memory, resetting the LMLayer to prep
                     * for transition to use of a new model.
                     */
                    LMLayer.prototype.unloadModel = function () {
                        this._worker.postMessage({
                            message: 'unload'
                        });
                    };
                    LMLayer.prototype.predict = function (transform, context) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._predictPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'predict',
                                token: token,
                                transform: transform,
                                context: context,
                            });
                        });
                    };
                    LMLayer.prototype.wordbreak = function (context) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._wordbreakPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'wordbreak',
                                token: token,
                                context: context
                            });
                        });
                    };
                    LMLayer.prototype.acceptSuggestion = function (suggestion, context, postTransform) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._acceptPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'accept',
                                token: token,
                                suggestion: suggestion,
                                context: context,
                                postTransform: postTransform
                            });
                        });
                    };
                    LMLayer.prototype.revertSuggestion = function (reversion, context) {
                        var _this = this;
                        var token = this._nextToken++;
                        return new Promise(function (resolve, reject) {
                            _this._revertPromises.make(token, resolve, reject);
                            _this._worker.postMessage({
                                message: 'revert',
                                token: token,
                                reversion: reversion,
                                context: context
                            });
                        });
                    };
                    LMLayer.prototype.resetContext = function (context) {
                        this._worker.postMessage({
                            message: 'reset-context',
                            context: context
                        });
                    };
                    // TODO: asynchronous close() method.
                    //       Worker code must recognize message and call self.close().
                    LMLayer.prototype.onMessage = function (event) {
                        var payload = event.data;
                        if (payload.message === 'error') {
                            console.error(payload.log);
                            if (payload.error) {
                                console.error(payload.error);
                            }
                        }
                        else if (payload.message === 'ready') {
                            this._declareLMLayerReady(event.data.configuration);
                        }
                        else if (payload.message === 'suggestions') {
                            this._predictPromises.keep(payload.token, payload.suggestions);
                        }
                        else if (payload.message === 'currentword') {
                            this._wordbreakPromises.keep(payload.token, payload.word);
                        }
                        else if (payload.message === 'postaccept') {
                            this._acceptPromises.keep(payload.token, payload.reversion);
                        }
                        else if (payload.message === 'postrevert') {
                            this._revertPromises.keep(payload.token, payload.suggestions);
                        }
                        else {
                            // This branch should never execute, but just in case...
                            //@ts-ignore
                            throw new Error("Message not implemented: " + payload.message);
                        }
                    };
                    /**
                     * Clears out any computational resources in use by the LMLayer, including shutting
                     * down any internal WebWorkers.
                     */
                    LMLayer.prototype.shutdown = function () {
                        this._worker.terminate();
                    };
                    /**
                     * Given a function, this utility returns the source code within it, as a string.
                     * This is intended to unwrap the "wrapped" source code created in the LMLayerWorker
                     * build process.
                     *
                     * @param fn The function whose body will be returned.
                     */
                    LMLayer.unwrap = function (fn) {
                        var wrapper = fn.toString();
                        var match = wrapper.match(/function[^{]+{((?:.|\r|\n)+)}[^}]*$/);
                        return match[1];
                    };
                    return LMLayer;
                }());
                prediction.LMLayer = LMLayer;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
(function () {
    var ns = com.keyman.text.prediction;
    // Let LMLayer be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ns.LMLayer;
        //@ts-ignore
        ns.LMLayer.PromiseStore = ns.PromiseStore;
    }
    else {
        //@ts-ignore
        window.LMLayer = ns.LMLayer;
    }
}());
///<reference path="../../../node_modules/@keymanapp/lexical-model-layer/embedded_worker.d.ts" />
///<reference path="../../../node_modules/@keymanapp/lexical-model-layer/message.d.ts" />
///<reference path="../../../node_modules/@keymanapp/lexical-model-layer/index.ts" />
///<reference path="../../includes/events.ts" />
/// <reference path="../contextWindow.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var prediction;
            (function (prediction_1) {
                var ReadySuggestions = /** @class */ (function () {
                    function ReadySuggestions(suggestions, id) {
                        this.suggestions = suggestions;
                        this.transcriptionID = id;
                    }
                    return ReadySuggestions;
                }());
                prediction_1.ReadySuggestions = ReadySuggestions;
                var LanguageProcessor = /** @class */ (function (_super) {
                    __extends(LanguageProcessor, _super);
                    function LanguageProcessor() {
                        var _this = _super !== null && _super.apply(this, arguments) || this;
                        _this.recentTranscriptions = [];
                        _this._mayPredict = true;
                        _this._mayCorrect = true;
                        return _this;
                    }
                    LanguageProcessor.prototype.init = function (supportsRightDeletions) {
                        if (supportsRightDeletions === void 0) { supportsRightDeletions = false; }
                        // Establishes KMW's platform 'capabilities', which limit the range of context a LMLayer
                        // model may expect.
                        var capabilities = {
                            maxLeftContextCodePoints: 64,
                            // Since the apps don't yet support right-deletions.
                            maxRightContextCodePoints: supportsRightDeletions ? 0 : 64
                        };
                        if (!this.canEnable()) {
                            return;
                        }
                        this.lmEngine = new prediction_1.LMLayer(capabilities);
                    };
                    Object.defineProperty(LanguageProcessor.prototype, "activeModel", {
                        get: function () {
                            return this.currentModel;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    LanguageProcessor.prototype.unloadModel = function () {
                        this.lmEngine.unloadModel();
                        delete this.currentModel;
                        delete this.configuration;
                        this.emit('statechange', 'inactive');
                    };
                    LanguageProcessor.prototype.loadModel = function (model) {
                        if (!model) {
                            throw new Error("Null reference not allowed.");
                        }
                        var specType = model.path ? 'file' : 'raw';
                        var source = specType == 'file' ? model.path : model.code;
                        var lp = this;
                        // We pre-emptively emit so that the banner's DOM elements may update synchronously.
                        // Prevents an ugly "flash of unstyled content" layout issue during keyboard load
                        // on our mobile platforms when embedded.
                        lp.currentModel = model;
                        if (this.mayPredict) {
                            lp.emit('statechange', 'active');
                        }
                        return this.lmEngine.loadModel(source, specType).then(function (config) {
                            lp.configuration = config;
                            lp.emit('statechange', 'configured');
                        }).catch(function (error) {
                            // Does this provide enough logging information?
                            var message;
                            if (error instanceof Error) {
                                message = error.message;
                            }
                            else {
                                message = String(error);
                            }
                            console.error("Could not load model '" + model.id + "': " + message);
                            // Since the model couldn't load, immediately deactivate.  Visually, it'll look
                            // like the banner crashed shortly after load.
                            lp.currentModel = null;
                            lp.emit('statechange', 'inactive');
                        });
                    };
                    LanguageProcessor.prototype.invalidateContext = function (outputTarget) {
                        // Signal to any predictive text UI that the context has changed, invalidating recent predictions.
                        this.emit('invalidatesuggestions', 'context');
                        // If there's no active model, there can be no predictions.
                        // We'll also be missing important data needed to even properly REQUEST the predictions.
                        if (!this.currentModel || !this.configuration) {
                            return;
                        }
                        // Don't attempt predictions when disabled!
                        // invalidateContext otherwise bypasses .predict()'s check against this.
                        if (!this.isActive) {
                            return;
                        }
                        else if (outputTarget) {
                            var transcription = outputTarget.buildTranscriptionFrom(outputTarget, null);
                            this.predict_internal(transcription, true);
                        }
                        else {
                            // Shouldn't be possible, and we'll want to know if and when it is.
                            console.warn("OutputTarget missing during an invalidateContext call");
                        }
                    };
                    LanguageProcessor.prototype.wordbreak = function (target) {
                        if (!this.isActive) {
                            return null;
                        }
                        var context = new text.ContextWindow(text.Mock.from(target), this.configuration);
                        return this.lmEngine.wordbreak(context);
                    };
                    LanguageProcessor.prototype.predict = function (transcription) {
                        if (!this.isActive) {
                            return null;
                        }
                        // If there's no active model, there can be no predictions.
                        // We'll also be missing important data needed to even properly REQUEST the predictions.
                        if (!this.currentModel || !this.configuration) {
                            return null;
                        }
                        // We've already invalidated any suggestions resulting from any previously-existing Promise -
                        // may as well officially invalidate them via event.
                        this.emit("invalidatesuggestions", 'new');
                        return this.predict_internal(transcription);
                    };
                    LanguageProcessor.prototype.applySuggestion = function (suggestion, outputTarget) {
                        if (!outputTarget) {
                            throw "Accepting suggestions requires a destination OutputTarget instance.";
                        }
                        // Find the state of the context at the time the suggestion was generated.
                        // This may refer to the context before an input keystroke or before application
                        // of a predictive suggestion.
                        var original = this.getPredictionState(suggestion.transformId);
                        if (!original) {
                            console.warn("Could not apply the Suggestion!");
                            return null;
                        }
                        else {
                            // Apply the Suggestion!
                            // Step 1:  determine the final output text
                            var final = text.Mock.from(original.preInput);
                            final.apply(suggestion.transform);
                            // Step 2:  build a final, master Transform that will produce the desired results from the CURRENT state.
                            // In embedded mode, both Android and iOS are best served by calculating this transform and applying its
                            // values as needed for use with their IME interfaces.
                            var transform = final.buildTransformFrom(outputTarget);
                            outputTarget.apply(transform);
                            // Build a 'reversion' Transcription that can be used to undo this apply() if needed,
                            // replacing the suggestion transform with the original input text.
                            var preApply = text.Mock.from(original.preInput);
                            preApply.apply(original.transform);
                            // Builds the reversion option according to the loaded lexical model's known
                            // syntactic properties.
                            var suggestionContext = new text.ContextWindow(original.preInput, this.configuration);
                            // We must accept the Suggestion from its original context, which was before
                            // `original.transform` was applied.
                            var reversionPromise = this.lmEngine.acceptSuggestion(suggestion, suggestionContext, original.transform);
                            // Also, request new prediction set based on the resulting context.
                            var lp_1 = this;
                            reversionPromise = reversionPromise.then(function (reversion) {
                                var mappedReversion = {
                                    // By mapping back to the original Transcription that generated the Suggestion,
                                    // the input will be automatically rewound to the preInput state.
                                    transform: original.transform,
                                    // The ID part is critical; the reversion can't be applied without it.
                                    transformId: -original.token,
                                    displayAs: reversion.displayAs,
                                    id: reversion.id,
                                    tag: reversion.tag
                                };
                                // // If using the version from lm-layer:
                                // let mappedReversion = reversion;
                                // mappedReversion.transformId = reversionTranscription.token;
                                lp_1.predictFromTarget(outputTarget);
                                return mappedReversion;
                            });
                            return reversionPromise;
                        }
                    };
                    LanguageProcessor.prototype.applyReversion = function (reversion, outputTarget) {
                        if (!outputTarget) {
                            throw "Accepting suggestions requires a destination OutputTarget instance.";
                        }
                        // Find the state of the context at the time the suggestion was generated.
                        // This may refer to the context before an input keystroke or before application
                        // of a predictive suggestion.
                        //
                        // Reversions use the additive inverse of the id token of the Transcription being
                        // reverted to.
                        var original = this.getPredictionState(-reversion.transformId);
                        if (!original) {
                            console.warn("Could not apply the Suggestion!");
                            return;
                        }
                        // Apply the Reversion!
                        // Step 1:  determine the final output text
                        var final = text.Mock.from(original.preInput);
                        final.apply(reversion.transform); // Should match original.transform, actually. (See applySuggestion)
                        // Step 2:  build a final, master Transform that will produce the desired results from the CURRENT state.
                        // In embedded mode, both Android and iOS are best served by calculating this transform and applying its
                        // values as needed for use with their IME interfaces.
                        var transform = final.buildTransformFrom(outputTarget);
                        outputTarget.apply(transform);
                        // The reason we need to preserve the additive-inverse 'transformId' property on Reversions.
                        var promise = this.lmEngine.revertSuggestion(reversion, new text.ContextWindow(original.preInput, this.configuration));
                        var lp = this;
                        return promise.then(function (suggestions) {
                            var result = new ReadySuggestions(suggestions, transform.id);
                            lp.emit("suggestionsready", result);
                            lp.currentPromise = null;
                            return suggestions;
                        });
                    };
                    LanguageProcessor.prototype.predictFromTarget = function (outputTarget) {
                        if (!outputTarget) {
                            return null;
                        }
                        var transcription = outputTarget.buildTranscriptionFrom(outputTarget, null);
                        return this.predict(transcription);
                    };
                    /**
                     * Called internally to do actual predictions after any relevant "invalidatesuggestions" events
                     * have been raised.
                     * @param transcription The triggering transcription (if it exists)
                     */
                    LanguageProcessor.prototype.predict_internal = function (transcription, resetContext) {
                        if (resetContext === void 0) { resetContext = false; }
                        if (!transcription) {
                            return null;
                        }
                        var context = new text.ContextWindow(transcription.preInput, this.configuration);
                        this.recordTranscription(transcription);
                        if (resetContext) {
                            this.lmEngine.resetContext(context);
                        }
                        var alternates = transcription.alternates;
                        if (!alternates || alternates.length == 0) {
                            alternates = [{
                                    sample: transcription.transform,
                                    p: 1.0
                                }];
                        }
                        var transform = transcription.transform;
                        var promise = this.currentPromise = this.lmEngine.predict(alternates, context);
                        var lp = this;
                        return promise.then(function (suggestions) {
                            if (promise == lp.currentPromise) {
                                var result = new ReadySuggestions(suggestions, transform.id);
                                lp.emit("suggestionsready", result);
                                lp.currentPromise = null;
                            }
                            return suggestions;
                        });
                    };
                    LanguageProcessor.prototype.recordTranscription = function (transcription) {
                        this.recentTranscriptions.push(transcription);
                        if (this.recentTranscriptions.length > LanguageProcessor.TRANSCRIPTION_BUFFER) {
                            this.recentTranscriptions.splice(0, 1);
                        }
                    };
                    /**
                     * Retrieves the context and output state of KMW immediately before the prediction with
                     * token `id` was generated.  Must correspond to a 'recent' one, as only so many are stored
                     * in `ModelManager`'s history buffer.
                     * @param id A unique identifier corresponding to a recent `Transcription`.
                     * @returns The matching `Transcription`, or `null` none is found.
                     */
                    LanguageProcessor.prototype.getPredictionState = function (id) {
                        var match = this.recentTranscriptions.filter(function (t) {
                            return t.token == id;
                        });
                        return match.length == 0 ? null : match[0];
                    };
                    LanguageProcessor.prototype.shutdown = function () {
                        this.lmEngine.shutdown();
                    };
                    Object.defineProperty(LanguageProcessor.prototype, "isActive", {
                        get: function () {
                            if (!this.canEnable()) {
                                this._mayPredict = false;
                                return false;
                            }
                            return (this.activeModel || false) && this._mayPredict;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    LanguageProcessor.prototype.canEnable = function () {
                        // Is overridden for dom-aware KMW in case of old IE versions.
                        return true;
                    };
                    Object.defineProperty(LanguageProcessor.prototype, "mayPredict", {
                        get: function () {
                            return this._mayPredict;
                        },
                        set: function (flag) {
                            if (!this.canEnable()) {
                                return;
                            }
                            var oldVal = this._mayPredict;
                            this._mayPredict = flag;
                            if (oldVal != flag) {
                                // If there's no model to be activated and we've reached this point,
                                // the banner should remain inactive, as it already was.
                                // If it there was one and we've reached this point, we're globally
                                // deactivating, so we're fine.
                                if (this.activeModel) {
                                    this.emit('statechange', flag ? 'active' : 'inactive');
                                }
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(LanguageProcessor.prototype, "mayCorrect", {
                        get: function () {
                            return this._mayCorrect;
                        },
                        set: function (flag) {
                            this._mayCorrect = flag;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(LanguageProcessor.prototype, "wordbreaksAfterSuggestions", {
                        get: function () {
                            return this.configuration.wordbreaksAfterSuggestions;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    LanguageProcessor.prototype.tryAcceptSuggestion = function (source) {
                        var returnObj = { shouldSwallow: false };
                        this.emit('tryaccept', source, returnObj);
                        return returnObj.shouldSwallow;
                    };
                    LanguageProcessor.prototype.tryRevertSuggestion = function () {
                        var returnObj = { shouldSwallow: false };
                        this.emit('tryrevert', returnObj);
                        return returnObj.shouldSwallow;
                    };
                    LanguageProcessor.TRANSCRIPTION_BUFFER = 10;
                    return LanguageProcessor;
                }(EventEmitter));
                prediction_1.LanguageProcessor = LanguageProcessor;
            })(prediction = text.prediction || (text.prediction = {}));
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
// Defines a 'polyfill' of sorts for NPM's events module
/// <reference path="../includes/events.ts" />
/// <reference path="../../node_modules/@keymanapp/keyboard-processor/src/text/keyboardProcessor.ts" />
/// <reference path="contextWindow.ts" />
/// <reference path="prediction/languageProcessor.ts" />
var com;
(function (com) {
    var keyman;
    (function (keyman) {
        var text;
        (function (text) {
            var InputProcessor = /** @class */ (function () {
                function InputProcessor(options) {
                    if (!options) {
                        options = InputProcessor.DEFAULT_OPTIONS;
                    }
                    this.kbdProcessor = new text.KeyboardProcessor(options);
                    this.lngProcessor = new text.prediction.LanguageProcessor();
                }
                Object.defineProperty(InputProcessor.prototype, "languageProcessor", {
                    get: function () {
                        return this.lngProcessor;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "keyboardProcessor", {
                    get: function () {
                        return this.kbdProcessor;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "keyboardInterface", {
                    get: function () {
                        return this.keyboardProcessor.keyboardInterface;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "activeKeyboard", {
                    get: function () {
                        return this.keyboardInterface.activeKeyboard;
                    },
                    set: function (keyboard) {
                        this.keyboardInterface.activeKeyboard = keyboard;
                        // All old deadkeys and keyboard-specific cache should immediately be invalidated
                        // on a keyboard change.
                        this.resetContext();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputProcessor.prototype, "activeModel", {
                    get: function () {
                        return this.languageProcessor.activeModel;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
             * Simulate a keystroke according to the touched keyboard button element
             *
             * Handles default output and keyboard processing for both OSK and physical keystrokes.
             *
             * @param       {Object}      keyEvent      The abstracted KeyEvent to use for keystroke processing
             * @param       {Object}      outputTarget  The OutputTarget receiving the KeyEvent
             * @returns     {Object}                    A RuleBehavior object describing the cumulative effects of
             *                                          all matched keyboard rules.
             */
                InputProcessor.prototype.processKeyEvent = function (keyEvent, outputTarget) {
                    var formFactor = keyEvent.device.formFactor;
                    var fromOSK = keyEvent.isSynthetic;
                    // The default OSK layout for desktop devices does not include nextlayer info, relying on modifier detection here.
                    // It's the OSK equivalent to doModifierPress on 'desktop' form factors.
                    if ((formFactor == keyman.utils.FormFactor.Desktop || !this.activeKeyboard || this.activeKeyboard.usesDesktopLayoutOnDevice(keyEvent.device)) && fromOSK) {
                        // If it's a desktop OSK style and this triggers a layer change,
                        // a modifier key was clicked.  No output expected, so it's safe to instantly exit.
                        if (this.keyboardProcessor.selectLayer(keyEvent)) {
                            return new text.RuleBehavior();
                        }
                    }
                    // Will handle keystroke-based non-layer change modifier & state keys, mapping them through the physical keyboard's version
                    // of state management.  `doModifierPress` must always run.
                    if (this.keyboardProcessor.doModifierPress(keyEvent, outputTarget, !fromOSK)) {
                        // If run on a desktop platform, we know that modifier & state key presses may not
                        // produce output, so we may make an immediate return safely.
                        if (!fromOSK) {
                            return new text.RuleBehavior();
                        }
                    }
                    // If suggestions exist AND space is pressed, accept the suggestion and do not process the keystroke.
                    // If a suggestion was just accepted AND backspace is pressed, revert the change and do not process the backspace.
                    // We check the first condition here, while the prediction UI handles the second through the try__() methods below.
                    if (this.languageProcessor.isActive) {
                        // The following code relies on JS's logical operator "short-circuit" properties to prevent unwanted triggering of the second condition.
                        // Can the suggestion UI revert a recent suggestion?  If so, do that and swallow the backspace.
                        if ((keyEvent.kName == "K_BKSP" || keyEvent.Lcode == text.Codes.keyCodes["K_BKSP"]) && this.languageProcessor.tryRevertSuggestion()) {
                            return new text.RuleBehavior();
                            // Can the suggestion UI accept an existing suggestion?  If so, do that and swallow the space character.
                        }
                        else if ((keyEvent.kName == "K_SPACE" || keyEvent.Lcode == text.Codes.keyCodes["K_SPACE"]) && this.languageProcessor.tryAcceptSuggestion('space')) {
                            return new text.RuleBehavior();
                        }
                    }
                    // // ...end I3363 (Build 301)
                    // Create a "mock" backup of the current outputTarget in its pre-input state.
                    // Current, long-existing assumption - it's DOM-backed.
                    var preInputMock = text.Mock.from(outputTarget);
                    // We presently need the true keystroke to run on the FULL context.  That index is still
                    // needed for some indexing operations when comparing two different output targets.
                    var ruleBehavior = this.keyboardProcessor.processKeystroke(keyEvent, outputTarget);
                    // Swap layer as appropriate.
                    if (keyEvent.kNextLayer) {
                        this.keyboardProcessor.selectLayer(keyEvent);
                    }
                    // Should we swallow any further processing of keystroke events for this keydown-keypress sequence?
                    if (ruleBehavior != null) {
                        var alternates = void 0;
                        // If we're performing a 'default command', it's not a standard 'typing' event - don't do fat-finger stuff.
                        // Also, don't do fat-finger stuff if predictive text isn't enabled.
                        if (this.languageProcessor.isActive && !ruleBehavior.triggersDefaultCommand) {
                            var keyDistribution = keyEvent.keyDistribution;
                            // We don't need to track absolute indexing during alternate-generation; 
                            // only position-relative, so it's better to use a sliding window for context
                            // when making alternates.  (Slightly worse for short text, matters greatly
                            // for long text.)
                            var contextWindow = new text.ContextWindow(preInputMock, text.ContextWindow.ENGINE_RULE_WINDOW);
                            var windowedMock = contextWindow.toMock();
                            // Note - we don't yet do fat-fingering with longpress keys.
                            if (keyDistribution && keyEvent.kbdLayer) {
                                // Tracks a 'deadline' for fat-finger ops, just in case both context is long enough
                                // and device is slow enough that the calculation takes too long.
                                //
                                // Consider use of https://developer.mozilla.org/en-US/docs/Web/API/Performance/now instead?
                                // Would allow finer-tuned control.
                                var TIMEOUT_THRESHOLD = Number.MAX_VALUE;
                                var _globalThis_1 = com.keyman.utils.getGlobalObject();
                                var timer = void 0;
                                // Available by default on `window` in browsers, but _not_ on `global` in Node, 
                                // surprisingly.  Since we can't use code dependent on `require` statements
                                // at present, we have to condition upon it actually existing.
                                if (_globalThis_1['performance'] && _globalThis_1['performance']['now']) {
                                    timer = function () {
                                        return _globalThis_1['performance']['now']();
                                    };
                                    TIMEOUT_THRESHOLD = timer() + 16; // + 16ms.
                                } // else {
                                // We _could_ just use Date.now() as a backup... but that (probably) only matters
                                // when unit testing.  So... we actually don't _need_ time thresholding when in 
                                // a Node environment.
                                // }
                                // Tracks a minimum probability for keystroke probability.  Anything less will not be
                                // included in alternate calculations. 
                                //
                                // Seek to match SearchSpace.EDIT_DISTANCE_COST_SCALE from the predictive-text engine.
                                // Reasoning for the selected value may be seen there.  Short version - keystrokes 
                                // that _appear_ very precise may otherwise not even consider directly-neighboring keys.
                                var KEYSTROKE_EPSILON = Math.exp(-5);
                                // Sort the distribution into probability-descending order.
                                keyDistribution.sort(function (a, b) { return b.p - a.p; });
                                var activeLayout = this.activeKeyboard.layout(keyEvent.device.formFactor);
                                alternates = [];
                                var totalMass_1 = 0; // Tracks sum of non-error probabilities.
                                for (var _i = 0, keyDistribution_1 = keyDistribution; _i < keyDistribution_1.length; _i++) {
                                    var pair = keyDistribution_1[_i];
                                    if (pair.p < KEYSTROKE_EPSILON) {
                                        break;
                                    }
                                    else if (timer && timer() >= TIMEOUT_THRESHOLD) {
                                        // Note:  it's always possible that the thread _executing_ our JS
                                        // got paused by the OS, even if JS itself is single-threaded.
                                        //
                                        // The case where `alternates` is initialized (line 167) but empty
                                        // (because of net-zero loop iterations) MUST be handled.
                                        break;
                                    }
                                    var mock = text.Mock.from(windowedMock);
                                    var altKey = activeLayout.getLayer(keyEvent.kbdLayer).getKey(pair.keyId);
                                    if (!altKey) {
                                        console.warn("Potential fat-finger key could not be found in layer!");
                                        continue;
                                    }
                                    var altEvent = altKey.constructKeyEvent(this.keyboardProcessor, keyEvent.device);
                                    var alternateBehavior = this.keyboardProcessor.processKeystroke(altEvent, mock);
                                    // If alternateBehavior.beep == true, ignore it.  It's a disallowed key sequence,
                                    // so we expect users to never intend their use.
                                    //
                                    // Also possible that this set of conditions fail for all evaluated alternates.
                                    if (alternateBehavior && !alternateBehavior.beep && pair.p > 0) {
                                        var transform = alternateBehavior.transcription.transform;
                                        // Ensure that the alternate's token id matches that of the current keystroke, as we only
                                        // record the matched rule's context (since they match)
                                        transform.id = ruleBehavior.transcription.token;
                                        alternates.push({ sample: transform, 'p': pair.p });
                                        totalMass_1 += pair.p;
                                    }
                                }
                                // Renormalizes the distribution, as any error (beep) results
                                // will result in a distribution that doesn't sum to 1 otherwise.
                                // All `.p` values are strictly positive, so totalMass is
                                // guaranteed to be > 0 if the array has entries.
                                alternates.forEach(function (alt) {
                                    alt.p /= totalMass_1;
                                });
                            }
                        }
                        // Now that we've done all the keystroke processing needed, ensure any extra effects triggered
                        // by the actual keystroke occur.
                        ruleBehavior.finalize(this.keyboardProcessor, outputTarget);
                        // -- All keystroke (and 'alternate') processing is now complete.  Time to finalize everything! --
                        // Notify the ModelManager of new input - it's predictive text time!
                        if (alternates && alternates.length > 0) {
                            ruleBehavior.transcription.alternates = alternates;
                        }
                        // Yes, even for ruleBehavior.triggersDefaultCommand.  Those tend to change the context.
                        ruleBehavior.predictionPromise = this.languageProcessor.predict(ruleBehavior.transcription);
                        // Text did not change (thus, no text "input") if we tabbed or merely moved the caret.
                        if (!ruleBehavior.triggersDefaultCommand) {
                            // For DOM-aware targets, this will trigger a DOM event page designers may listen for.
                            outputTarget.doInputEvent();
                        }
                    }
                    return ruleBehavior;
                };
                InputProcessor.prototype.resetContext = function (outputTarget) {
                    this.keyboardProcessor.resetContext();
                    this.languageProcessor.invalidateContext(outputTarget);
                };
                InputProcessor.DEFAULT_OPTIONS = {
                    baseLayout: 'us'
                };
                return InputProcessor;
            }());
            text.InputProcessor = InputProcessor;
        })(text = keyman.text || (keyman.text = {}));
    })(keyman = com.keyman || (com.keyman = {}));
})(com || (com = {}));
(function () {
    var ns = com.keyman.text;
    // Let the InputProcessor be available both in the browser and in Node.
    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
        module.exports = ns.InputProcessor;
        //@ts-ignore
        ns.InputProcessor.com = com; // Export the root namespace so that all InputProcessor classes are accessible by unit tests.
    }
}());
//# sourceMappingURL=index.js.map