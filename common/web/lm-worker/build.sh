#!/bin/bash
#
# Compiles the Language Modeling Layer for common use in predictive text and autocorrective applications.
# Designed for optimal compatibility with the Keyman Suite.
#

# Exit on command failure and when using unset variables:
set -eu

# Include some helper functions from resources

## START STANDARD BUILD SCRIPT INCLUDE
# adjust relative paths as necessary
THIS_SCRIPT="$(greadlink -f "${BASH_SOURCE[0]}" 2>/dev/null || readlink -f "${BASH_SOURCE[0]}")"
. "$(dirname "$THIS_SCRIPT")/../../../resources/build/build-utils.sh"
## END STANDARD BUILD SCRIPT INCLUDE

. "$KEYMAN_ROOT/resources/shellHelperFunctions.sh"

# This script runs from its own folder
cd "$(dirname "$THIS_SCRIPT")"

display_usage ( ) {
  echo "Usage: $0 [configure] [clean] [build] [test]"
  echo "          [--verbose|-v]"
  echo "       $0 -h|--help"
  echo
  echo "  clean                  removes build/ folder"
  echo "  configure              runs 'npm ci' on root folder"
  echo "  build                  builds wrapped version of package"
  echo "                           [if required will: configure]"
  echo "  test                   runs tests (builds as req'd)"
  echo "                           [if required will: build]"
}

WORKER_OUTPUT=build
WORKER_OUTPUT_FILENAME=$WORKER_OUTPUT/index.js

# Wraps JavaScript code in a way that can be embedded in a worker.
# To get the inner source code, include the file generated by this function,
# then use name.toString() where `name` is the name passed into this
# function.
wrap-worker-code ( ) {
  name="$1"
  js="$2"
  echo "// Autogenerated code. Do not modify!"
  echo "// --START:LMLayerWorkerCode--"
  printf "function %s () {\n" "${name}"

  # TODO: I don't know if this is still true, or if we can add the polyfills to
  # the project directly now?
  #
  # Since the worker is compiled with "allowJS=false" so that we can make
  # declaration files, we have to insert polyfills here.

  # This one's a minimal, targeted polyfill.  es6-shim could do the same, but
  # also adds a lot more code the worker doesn't need to use. Recommended by MDN
  # while keeping the worker lean and efficient.
  # TODO: determine which platforms+versions require this?
  cat "../../../node_modules/string.prototype.codepointat/codepointat.js" || die

  # Needed to ensure functionality on some older Android devices. (API 19-23 or
  # so)
  # TODO: determine exactly which versions require this?
  cat "../../../node_modules/string.prototype.startswith/startswith.js" || die

  # These two are straight from MDN - I didn't find any NPM ones that don't use
  # the node `require` statement for the second.  They're also relatively short
  # and simple, which is good.
  # TODO: determine which platforms+versions require this?
  cat "src/polyfills/array.fill.js" || die
  cat "src/polyfills/array.from.js" || die

  # For Object.values, for iteration over object-based associate arrays.
  # TODO: determine which platforms+versions require this?
  cat "src/polyfills/object.values.js" || die

  # Needed to support Symbol.iterator, as used by the correction algorithm.
  # TODO: determine which platforms+versions require this?
  cat "src/polyfills/symbol-es6.min.js" || die

  # Needed to 'support' String.normalize within iOS 9. For our limited use case
  # thereof; is definitely NOT a general polyfill. (The file size on a true one
  # would be quite high.)
  cat "src/polyfills/string.normalize.js" || die

  echo ""

  cat "${js}" || die
  printf "\n}\n"
  echo "// --END:LMLayerWorkerCode--"
}

################################ Main script ################################

builder_init "clean configure build test" "$@"

# TODO: build if out-of-date if test is specified
# TODO: configure if npm has not been run, and build is specified

if builder_has_action configure; then
  verify_npm_setup
  builder_report configure success
fi

if builder_has_action clean; then
  npm run clean
  builder_report clean success
fi

if builder_has_action build; then
  # Build worker with tsc first
  npm run build -- $builder_verbose || fail "Could not build worker."

  # Test if we've already done the wrapper (e.g. if build is already up to
  # date), and in that case don't re-wrap
  if ! grep -q "LMLayerWorkerCode" "${WORKER_OUTPUT_FILENAME}"; then
    # Wrap the worker code and create embedded_worker.js. Must be run after the
    # worker is built for the first time.
    echo "Wrapping worker in function LMLayerWorkerCode ${WORKER_OUTPUT_FILENAME}"
    wrap-worker-code LMLayerWorkerCode "${WORKER_OUTPUT_FILENAME}" > "${WORKER_OUTPUT_FILENAME}.tmp" || die
    # Replace the default output file
    mv "${WORKER_OUTPUT_FILENAME}.tmp" "${WORKER_OUTPUT_FILENAME}" || die
  fi

  builder_report build success
fi

if builder_has_action test; then
  npm test || fail "Tests failed"
  builder_report test success
fi
