import { assert } from 'chai';
import sinon from 'sinon';

import CloudQueryEngine from '../../../../../build/engine/keyboard-cache/obj/cloud/queryEngine.js';
import { default as StubAndKeyboardCache, toPrefixedKeyboardId as prefixed } from '../../../../../build/engine/keyboard-cache/obj/stubAndKeyboardCache.js';
import NodeCloudRequester from '../../../../../build/engine/keyboard-cache/obj/nodeCloudRequester.js';

import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe("Cloud-query interface", () => {
  /**
   * Performs mocking setup to facilitate unit testing for the `CloudQueryEngine` class.
   *
   * @param {*} queryResultsFile An absolute local filepath to a file containing the mocked results to generate.
   * @returns A fully-mocked `CloudQueryEngine` whose `.fetchCloudStubs()` call will yield a Promise for the
   *          expected mocked results.
   */
  function mockQuery(queryResultsFile) {
    const mockedRequester = new NodeCloudRequester();      // Would attempt to https-request.
    const mockingRequester = new NodeCloudRequester(true); // Used to replace that with a local request.

    const querier = new CloudQueryEngine(mockedRequester); // The query engine builds https-request query strings.
    // Promises are tracked via their queryId, which is generated by the requester.
    // We need to apply it before allowing the actual registration method to execute.
    const idInjector = {
      registerFromCloud: (x) => {
        x.timerid = idInjector.injectionId;

        querier.registerFromCloud(x);
      }
    }

    /*
      * Serves two purposes:
      *
      * 1. Captures the queryID generated by the https-based requester (being mocked) for application
      *    as seen above.
      * 2. Forwards the local-request (mocked) query's Promise as if it were produced by the https-based requester.
      */
    mockedRequester.request = sinon.fake(() => {
      let retObj = mockingRequester.request(queryResultsFile);

      // We need to capture + inject that timerId into the returned results!
      idInjector.injectionId = retObj.queryId;
      return retObj;
    });

    // Make sure the actual (local-request) requester 'registers' the query result correctly - including the
    // ability to apply the queryId expected by the registration method.
    mockingRequester.link(idInjector);

    return querier;
  }

  describe("Query URI construction", () => {
    it('sil_euro_latin@no,sv', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester);
      querier.fetchCloudStubs(['sil_euro_latin@no,sv']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv'));
      assert.isFalse(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv,'));
    });

    it('sil_cameroon_azerty', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester);
      querier.fetchCloudStubs(['sil_cameroon_azerty']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('&keyboardid=sil_cameroon_azerty'));
      assert.isFalse(queryURI.includes('&keyboardid=sil_cameroon_azerty@'));
    });

    it('@dz', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester);
      querier.fetchCloudStubs(['@dz']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('&keyboardid=@dz'));
      assert.isFalse(queryURI.includes('&keyboardid=@dz,'));
    });

    it('sil_euro_latin@no,sv + @dz', () => {
      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester);
      querier.fetchCloudStubs(['sil_euro_latin@no,sv', '@dz']);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      assert.isTrue(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv,@dz'));
      assert.isFalse(queryURI.includes('&keyboardid=sil_euro_latin@no,sil_euro_latin@sv,@dz,'));
    });

    it('drops requests for already fetched stubs', async () => {
      // #region Test setup: establishes `cache`, containing stubs for `sil_euro_latin@no,sv`.
      let setupQuerier = mockQuery(`${__dirname}/../../resources/query-mock-results/sil_euro_latin@no_sv.js.fixture`);
      let promise = setupQuerier.fetchCloudStubs(['sil_euro_latin@no,sv']);

      const setupStubs = await promise;

      const cache = new StubAndKeyboardCache();
      for(let stub of setupStubs) {
        cache.addStub(stub);
      }
      // #endregion

      const requester = new NodeCloudRequester();
      const mockedMethod = requester.request = sinon.fake(() => { return {promise: Promise.resolve()} });

      const querier = new CloudQueryEngine(requester);
      // `sil_euro_latin@no` is already in the `cache`.
      querier.fetchCloudStubs(['sil_euro_latin@no', '@dz'], cache);

      assert.isTrue(mockedMethod.called);
      const queryURI = mockedMethod.firstCall.args[0];
      // We should still be querying for stubs we haven't already acquired...
      assert.isTrue(queryURI.includes('@dz'));
      assert.isTrue(queryURI.includes('&keyboardid=@dz'));
      // ... while ensuring that we do not re-request already-acquired stubs.
      assert.isFalse(queryURI.includes('&keyboardid=sil_euro_latin@no'));
      assert.isFalse(queryURI.includes('sil_euro_latin'));
    });
  });

  describe('Stub fetching', () => {
    it('sil_euro_latin@no,sv', async () => {
      const querier = mockQuery(`${__dirname}/../../resources/query-mock-results/sil_euro_latin@no_sv.js.fixture`);
      const promise = querier.fetchCloudStubs(['sil_euro_latin@no,sv']);

      const stubs = await promise;

      assert.equal(stubs.length, 2);
      for(let stub of stubs) {
        assert.equal(stub.KI, prefixed('sil_euro_latin'));
        assert.equal(stub.KN, "EuroLatin (SIL)");
      }

      assert.sameOrderedMembers(stubs.map((stub) => stub.KLC), ['no', 'sv']);
      assert.sameOrderedMembers(stubs.map((stub) => stub.KL),  ['Norwegian', 'Swedish']);
    });

    it('sil_cameroon_azerty', async () => {
      const querier = mockQuery(`${__dirname}/../../resources/query-mock-results/sil_cameroon_azerty.js.fixture`);
      const promise = querier.fetchCloudStubs(['sil_cameroon_azerty']);

      const stubs = await promise;

      assert.equal(stubs.length, 278);
      for(let stub of stubs) {
        assert.equal(stub.KI, prefixed('sil_cameroon_azerty'));
        assert.equal(stub.KN, "Cameroon AZERTY");
      }

      assert.equal(stubs.find((stub) => stub.KLC == 'pny').KL, 'Pinyin');
    });

    it('@dz', async () => {
      const querier = mockQuery(`${__dirname}/../../resources/query-mock-results/@dz.js.fixture`);
      const promise = querier.fetchCloudStubs(['@dz']);

      const stubs = await promise;

      // `CloudQueryEngine` returns only a single stub.
      //
      // Within `CloudQueryEngine.registerLanguagesForKeyboard`:
      // > Register the default keyboard for the language code
      assert.equal(stubs.length, 1);
      // When available, a perfect match between keyboard and language name = "the default keyboard".
      assert.equal(stubs[0].KN, "Dzongkha");
    });

    it('drops requests for already fetched stubs', async () => {
      let querier = mockQuery(`${__dirname}/../../resources/query-mock-results/sil_euro_latin@no_sv.js.fixture`);
      let promise = querier.fetchCloudStubs(['sil_euro_latin@no,sv']);

      const setupStubs = await promise;

      const cache = new StubAndKeyboardCache();
      for(let stub of setupStubs) {
        cache.addStub(stub);
      }

      // Now for the real test.
      querier = mockQuery(`${__dirname}/../../resources/query-mock-results/sil_euro_latin@no_sv.js.fixture`);
      promise = querier.fetchCloudStubs(['sil_euro_latin@no'], cache);

      const stubs = await promise;

      assert.isEmpty(stubs);
    });
  });
});